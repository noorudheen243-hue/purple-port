
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ContentCalendar
 * 
 */
export type ContentCalendar = $Result.DefaultSelection<Prisma.$ContentCalendarPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model AdAccount
 * 
 */
export type AdAccount = $Result.DefaultSelection<Prisma.$AdAccountPayload>
/**
 * Model AdGroup
 * 
 */
export type AdGroup = $Result.DefaultSelection<Prisma.$AdGroupPayload>
/**
 * Model Ad
 * 
 */
export type Ad = $Result.DefaultSelection<Prisma.$AdPayload>
/**
 * Model SpendSnapshot
 * 
 */
export type SpendSnapshot = $Result.DefaultSelection<Prisma.$SpendSnapshotPayload>
/**
 * Model CampaignMetric
 * 
 */
export type CampaignMetric = $Result.DefaultSelection<Prisma.$CampaignMetricPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AccountHead
 * 
 */
export type AccountHead = $Result.DefaultSelection<Prisma.$AccountHeadPayload>
/**
 * Model Ledger
 * 
 */
export type Ledger = $Result.DefaultSelection<Prisma.$LedgerPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model JournalLine
 * 
 */
export type JournalLine = $Result.DefaultSelection<Prisma.$JournalLinePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskDependency
 * 
 */
export type TaskDependency = $Result.DefaultSelection<Prisma.$TaskDependencyPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model AssetComment
 * 
 */
export type AssetComment = $Result.DefaultSelection<Prisma.$AssetCommentPayload>
/**
 * Model TimeLog
 * 
 */
export type TimeLog = $Result.DefaultSelection<Prisma.$TimeLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.contentCalendar`: Exposes CRUD operations for the **ContentCalendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentCalendars
    * const contentCalendars = await prisma.contentCalendar.findMany()
    * ```
    */
  get contentCalendar(): Prisma.ContentCalendarDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.adAccount`: Exposes CRUD operations for the **AdAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdAccounts
    * const adAccounts = await prisma.adAccount.findMany()
    * ```
    */
  get adAccount(): Prisma.AdAccountDelegate<ExtArgs>;

  /**
   * `prisma.adGroup`: Exposes CRUD operations for the **AdGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdGroups
    * const adGroups = await prisma.adGroup.findMany()
    * ```
    */
  get adGroup(): Prisma.AdGroupDelegate<ExtArgs>;

  /**
   * `prisma.ad`: Exposes CRUD operations for the **Ad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ads
    * const ads = await prisma.ad.findMany()
    * ```
    */
  get ad(): Prisma.AdDelegate<ExtArgs>;

  /**
   * `prisma.spendSnapshot`: Exposes CRUD operations for the **SpendSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpendSnapshots
    * const spendSnapshots = await prisma.spendSnapshot.findMany()
    * ```
    */
  get spendSnapshot(): Prisma.SpendSnapshotDelegate<ExtArgs>;

  /**
   * `prisma.campaignMetric`: Exposes CRUD operations for the **CampaignMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMetrics
    * const campaignMetrics = await prisma.campaignMetric.findMany()
    * ```
    */
  get campaignMetric(): Prisma.CampaignMetricDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.accountHead`: Exposes CRUD operations for the **AccountHead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountHeads
    * const accountHeads = await prisma.accountHead.findMany()
    * ```
    */
  get accountHead(): Prisma.AccountHeadDelegate<ExtArgs>;

  /**
   * `prisma.ledger`: Exposes CRUD operations for the **Ledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ledgers
    * const ledgers = await prisma.ledger.findMany()
    * ```
    */
  get ledger(): Prisma.LedgerDelegate<ExtArgs>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs>;

  /**
   * `prisma.journalLine`: Exposes CRUD operations for the **JournalLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLines
    * const journalLines = await prisma.journalLine.findMany()
    * ```
    */
  get journalLine(): Prisma.JournalLineDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskDependency`: Exposes CRUD operations for the **TaskDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDependencies
    * const taskDependencies = await prisma.taskDependency.findMany()
    * ```
    */
  get taskDependency(): Prisma.TaskDependencyDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.assetComment`: Exposes CRUD operations for the **AssetComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetComments
    * const assetComments = await prisma.assetComment.findMany()
    * ```
    */
  get assetComment(): Prisma.AssetCommentDelegate<ExtArgs>;

  /**
   * `prisma.timeLog`: Exposes CRUD operations for the **TimeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeLogs
    * const timeLogs = await prisma.timeLog.findMany()
    * ```
    */
  get timeLog(): Prisma.TimeLogDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    ContentCalendar: 'ContentCalendar',
    Campaign: 'Campaign',
    AdAccount: 'AdAccount',
    AdGroup: 'AdGroup',
    Ad: 'Ad',
    SpendSnapshot: 'SpendSnapshot',
    CampaignMetric: 'CampaignMetric',
    AuditLog: 'AuditLog',
    AccountHead: 'AccountHead',
    Ledger: 'Ledger',
    JournalEntry: 'JournalEntry',
    JournalLine: 'JournalLine',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Task: 'Task',
    TaskDependency: 'TaskDependency',
    Asset: 'Asset',
    Comment: 'Comment',
    AssetComment: 'AssetComment',
    TimeLog: 'TimeLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "client" | "contentCalendar" | "campaign" | "adAccount" | "adGroup" | "ad" | "spendSnapshot" | "campaignMetric" | "auditLog" | "accountHead" | "ledger" | "journalEntry" | "journalLine" | "invoice" | "invoiceItem" | "task" | "taskDependency" | "asset" | "comment" | "assetComment" | "timeLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ContentCalendar: {
        payload: Prisma.$ContentCalendarPayload<ExtArgs>
        fields: Prisma.ContentCalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentCalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentCalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          findFirst: {
            args: Prisma.ContentCalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentCalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          findMany: {
            args: Prisma.ContentCalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>[]
          }
          create: {
            args: Prisma.ContentCalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          createMany: {
            args: Prisma.ContentCalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>[]
          }
          delete: {
            args: Prisma.ContentCalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          update: {
            args: Prisma.ContentCalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          deleteMany: {
            args: Prisma.ContentCalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentCalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentCalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCalendarPayload>
          }
          aggregate: {
            args: Prisma.ContentCalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentCalendar>
          }
          groupBy: {
            args: Prisma.ContentCalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentCalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCalendarCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCalendarCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      AdAccount: {
        payload: Prisma.$AdAccountPayload<ExtArgs>
        fields: Prisma.AdAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          findFirst: {
            args: Prisma.AdAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          findMany: {
            args: Prisma.AdAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>[]
          }
          create: {
            args: Prisma.AdAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          createMany: {
            args: Prisma.AdAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>[]
          }
          delete: {
            args: Prisma.AdAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          update: {
            args: Prisma.AdAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          deleteMany: {
            args: Prisma.AdAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          aggregate: {
            args: Prisma.AdAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdAccount>
          }
          groupBy: {
            args: Prisma.AdAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdAccountCountArgs<ExtArgs>
            result: $Utils.Optional<AdAccountCountAggregateOutputType> | number
          }
        }
      }
      AdGroup: {
        payload: Prisma.$AdGroupPayload<ExtArgs>
        fields: Prisma.AdGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>
          }
          findFirst: {
            args: Prisma.AdGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>
          }
          findMany: {
            args: Prisma.AdGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>[]
          }
          create: {
            args: Prisma.AdGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>
          }
          createMany: {
            args: Prisma.AdGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>[]
          }
          delete: {
            args: Prisma.AdGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>
          }
          update: {
            args: Prisma.AdGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>
          }
          deleteMany: {
            args: Prisma.AdGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdGroupPayload>
          }
          aggregate: {
            args: Prisma.AdGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdGroup>
          }
          groupBy: {
            args: Prisma.AdGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdGroupCountArgs<ExtArgs>
            result: $Utils.Optional<AdGroupCountAggregateOutputType> | number
          }
        }
      }
      Ad: {
        payload: Prisma.$AdPayload<ExtArgs>
        fields: Prisma.AdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findFirst: {
            args: Prisma.AdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findMany: {
            args: Prisma.AdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          create: {
            args: Prisma.AdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          createMany: {
            args: Prisma.AdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          delete: {
            args: Prisma.AdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          update: {
            args: Prisma.AdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          deleteMany: {
            args: Prisma.AdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          aggregate: {
            args: Prisma.AdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAd>
          }
          groupBy: {
            args: Prisma.AdGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdCountArgs<ExtArgs>
            result: $Utils.Optional<AdCountAggregateOutputType> | number
          }
        }
      }
      SpendSnapshot: {
        payload: Prisma.$SpendSnapshotPayload<ExtArgs>
        fields: Prisma.SpendSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpendSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpendSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>
          }
          findFirst: {
            args: Prisma.SpendSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpendSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>
          }
          findMany: {
            args: Prisma.SpendSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>[]
          }
          create: {
            args: Prisma.SpendSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>
          }
          createMany: {
            args: Prisma.SpendSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpendSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>[]
          }
          delete: {
            args: Prisma.SpendSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>
          }
          update: {
            args: Prisma.SpendSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.SpendSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpendSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpendSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendSnapshotPayload>
          }
          aggregate: {
            args: Prisma.SpendSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpendSnapshot>
          }
          groupBy: {
            args: Prisma.SpendSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpendSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpendSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<SpendSnapshotCountAggregateOutputType> | number
          }
        }
      }
      CampaignMetric: {
        payload: Prisma.$CampaignMetricPayload<ExtArgs>
        fields: Prisma.CampaignMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>
          }
          findFirst: {
            args: Prisma.CampaignMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>
          }
          findMany: {
            args: Prisma.CampaignMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>[]
          }
          create: {
            args: Prisma.CampaignMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>
          }
          createMany: {
            args: Prisma.CampaignMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>[]
          }
          delete: {
            args: Prisma.CampaignMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>
          }
          update: {
            args: Prisma.CampaignMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>
          }
          deleteMany: {
            args: Prisma.CampaignMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricPayload>
          }
          aggregate: {
            args: Prisma.CampaignMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMetric>
          }
          groupBy: {
            args: Prisma.CampaignMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMetricCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMetricCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AccountHead: {
        payload: Prisma.$AccountHeadPayload<ExtArgs>
        fields: Prisma.AccountHeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountHeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountHeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          findFirst: {
            args: Prisma.AccountHeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountHeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          findMany: {
            args: Prisma.AccountHeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>[]
          }
          create: {
            args: Prisma.AccountHeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          createMany: {
            args: Prisma.AccountHeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountHeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>[]
          }
          delete: {
            args: Prisma.AccountHeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          update: {
            args: Prisma.AccountHeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          deleteMany: {
            args: Prisma.AccountHeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountHeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountHeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountHeadPayload>
          }
          aggregate: {
            args: Prisma.AccountHeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountHead>
          }
          groupBy: {
            args: Prisma.AccountHeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountHeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountHeadCountArgs<ExtArgs>
            result: $Utils.Optional<AccountHeadCountAggregateOutputType> | number
          }
        }
      }
      Ledger: {
        payload: Prisma.$LedgerPayload<ExtArgs>
        fields: Prisma.LedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          findFirst: {
            args: Prisma.LedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          findMany: {
            args: Prisma.LedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>[]
          }
          create: {
            args: Prisma.LedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          createMany: {
            args: Prisma.LedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>[]
          }
          delete: {
            args: Prisma.LedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          update: {
            args: Prisma.LedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          deleteMany: {
            args: Prisma.LedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          aggregate: {
            args: Prisma.LedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedger>
          }
          groupBy: {
            args: Prisma.LedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      JournalLine: {
        payload: Prisma.$JournalLinePayload<ExtArgs>
        fields: Prisma.JournalLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findFirst: {
            args: Prisma.JournalLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findMany: {
            args: Prisma.JournalLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          create: {
            args: Prisma.JournalLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          createMany: {
            args: Prisma.JournalLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          delete: {
            args: Prisma.JournalLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          update: {
            args: Prisma.JournalLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          deleteMany: {
            args: Prisma.JournalLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          aggregate: {
            args: Prisma.JournalLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLine>
          }
          groupBy: {
            args: Prisma.JournalLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLineCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLineCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskDependency: {
        payload: Prisma.$TaskDependencyPayload<ExtArgs>
        fields: Prisma.TaskDependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          findFirst: {
            args: Prisma.TaskDependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          findMany: {
            args: Prisma.TaskDependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
          }
          create: {
            args: Prisma.TaskDependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          createMany: {
            args: Prisma.TaskDependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskDependencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
          }
          delete: {
            args: Prisma.TaskDependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          update: {
            args: Prisma.TaskDependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          deleteMany: {
            args: Prisma.TaskDependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          aggregate: {
            args: Prisma.TaskDependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDependency>
          }
          groupBy: {
            args: Prisma.TaskDependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDependencyCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDependencyCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      AssetComment: {
        payload: Prisma.$AssetCommentPayload<ExtArgs>
        fields: Prisma.AssetCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>
          }
          findFirst: {
            args: Prisma.AssetCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>
          }
          findMany: {
            args: Prisma.AssetCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>[]
          }
          create: {
            args: Prisma.AssetCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>
          }
          createMany: {
            args: Prisma.AssetCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>[]
          }
          delete: {
            args: Prisma.AssetCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>
          }
          update: {
            args: Prisma.AssetCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>
          }
          deleteMany: {
            args: Prisma.AssetCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCommentPayload>
          }
          aggregate: {
            args: Prisma.AssetCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetComment>
          }
          groupBy: {
            args: Prisma.AssetCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCommentCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCommentCountAggregateOutputType> | number
          }
        }
      }
      TimeLog: {
        payload: Prisma.$TimeLogPayload<ExtArgs>
        fields: Prisma.TimeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findFirst: {
            args: Prisma.TimeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findMany: {
            args: Prisma.TimeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          create: {
            args: Prisma.TimeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          createMany: {
            args: Prisma.TimeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          delete: {
            args: Prisma.TimeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          update: {
            args: Prisma.TimeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          deleteMany: {
            args: Prisma.TimeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          aggregate: {
            args: Prisma.TimeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeLog>
          }
          groupBy: {
            args: Prisma.TimeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TimeLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    clientsManaged: number
    tasksAssigned: number
    tasksReported: number
    timeLogs: number
    comments: number
    notifications: number
    assetsUploaded: number
    assetComments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientsManaged?: boolean | UserCountOutputTypeCountClientsManagedArgs
    tasksAssigned?: boolean | UserCountOutputTypeCountTasksAssignedArgs
    tasksReported?: boolean | UserCountOutputTypeCountTasksReportedArgs
    timeLogs?: boolean | UserCountOutputTypeCountTimeLogsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    assetsUploaded?: boolean | UserCountOutputTypeCountAssetsUploadedArgs
    assetComments?: boolean | UserCountOutputTypeCountAssetCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsManagedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksReportedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetsUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCommentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    campaigns: number
    tasks: number
    ad_accounts: number
    contentCalendars: number
    ledgers: number
    invoices: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | ClientCountOutputTypeCountCampaignsArgs
    tasks?: boolean | ClientCountOutputTypeCountTasksArgs
    ad_accounts?: boolean | ClientCountOutputTypeCountAd_accountsArgs
    contentCalendars?: boolean | ClientCountOutputTypeCountContentCalendarsArgs
    ledgers?: boolean | ClientCountOutputTypeCountLedgersArgs
    invoices?: boolean | ClientCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAd_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdAccountWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountContentCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCalendarWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLedgersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    tasks: number
    ad_groups: number
    metrics: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | CampaignCountOutputTypeCountTasksArgs
    ad_groups?: boolean | CampaignCountOutputTypeCountAd_groupsArgs
    metrics?: boolean | CampaignCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAd_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdGroupWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMetricWhereInput
  }


  /**
   * Count Type AdAccountCountOutputType
   */

  export type AdAccountCountOutputType = {
    ad_groups: number
  }

  export type AdAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad_groups?: boolean | AdAccountCountOutputTypeCountAd_groupsArgs
  }

  // Custom InputTypes
  /**
   * AdAccountCountOutputType without action
   */
  export type AdAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccountCountOutputType
     */
    select?: AdAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdAccountCountOutputType without action
   */
  export type AdAccountCountOutputTypeCountAd_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdGroupWhereInput
  }


  /**
   * Count Type AdGroupCountOutputType
   */

  export type AdGroupCountOutputType = {
    ads: number
  }

  export type AdGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ads?: boolean | AdGroupCountOutputTypeCountAdsArgs
  }

  // Custom InputTypes
  /**
   * AdGroupCountOutputType without action
   */
  export type AdGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroupCountOutputType
     */
    select?: AdGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdGroupCountOutputType without action
   */
  export type AdGroupCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Count Type AdCountOutputType
   */

  export type AdCountOutputType = {
    snapshots: number
  }

  export type AdCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshots?: boolean | AdCountOutputTypeCountSnapshotsArgs
  }

  // Custom InputTypes
  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCountOutputType
     */
    select?: AdCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendSnapshotWhereInput
  }


  /**
   * Count Type AccountHeadCountOutputType
   */

  export type AccountHeadCountOutputType = {
    ledgers: number
    journalLines: number
  }

  export type AccountHeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgers?: boolean | AccountHeadCountOutputTypeCountLedgersArgs
    journalLines?: boolean | AccountHeadCountOutputTypeCountJournalLinesArgs
  }

  // Custom InputTypes
  /**
   * AccountHeadCountOutputType without action
   */
  export type AccountHeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHeadCountOutputType
     */
    select?: AccountHeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountHeadCountOutputType without action
   */
  export type AccountHeadCountOutputTypeCountLedgersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
  }

  /**
   * AccountHeadCountOutputType without action
   */
  export type AccountHeadCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }


  /**
   * Count Type JournalEntryCountOutputType
   */

  export type JournalEntryCountOutputType = {
    lines: number
  }

  export type JournalEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | JournalEntryCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntryCountOutputType
     */
    select?: JournalEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    sub_tasks: number
    dependencies: number
    dependents: number
    assets: number
    comments: number
    timeLogs: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sub_tasks?: boolean | TaskCountOutputTypeCountSub_tasksArgs
    dependencies?: boolean | TaskCountOutputTypeCountDependenciesArgs
    dependents?: boolean | TaskCountOutputTypeCountDependentsArgs
    assets?: boolean | TaskCountOutputTypeCountAssetsArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    timeLogs?: boolean | TaskCountOutputTypeCountTimeLogsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSub_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    comments: number
    ads: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | AssetCountOutputTypeCountCommentsArgs
    ads?: boolean | AssetCountOutputTypeCountAdsArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCommentWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    full_name: string | null
    designation: string | null
    role: string | null
    department: string | null
    avatar_url: string | null
    staff_id_number: string | null
    joining_date: Date | null
    dob: Date | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    full_name: string | null
    designation: string | null
    role: string | null
    department: string | null
    avatar_url: string | null
    staff_id_number: string | null
    joining_date: Date | null
    dob: Date | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    full_name: number
    designation: number
    role: number
    department: number
    avatar_url: number
    staff_id_number: number
    joining_date: number
    dob: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    designation?: true
    role?: true
    department?: true
    avatar_url?: true
    staff_id_number?: true
    joining_date?: true
    dob?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    designation?: true
    role?: true
    department?: true
    avatar_url?: true
    staff_id_number?: true
    joining_date?: true
    dob?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    designation?: true
    role?: true
    department?: true
    avatar_url?: true
    staff_id_number?: true
    joining_date?: true
    dob?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    full_name: string
    designation: string | null
    role: string
    department: string
    avatar_url: string | null
    staff_id_number: string | null
    joining_date: Date | null
    dob: Date | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    designation?: boolean
    role?: boolean
    department?: boolean
    avatar_url?: boolean
    staff_id_number?: boolean
    joining_date?: boolean
    dob?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientsManaged?: boolean | User$clientsManagedArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    tasksReported?: boolean | User$tasksReportedArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    assetsUploaded?: boolean | User$assetsUploadedArgs<ExtArgs>
    assetComments?: boolean | User$assetCommentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    designation?: boolean
    role?: boolean
    department?: boolean
    avatar_url?: boolean
    staff_id_number?: boolean
    joining_date?: boolean
    dob?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    designation?: boolean
    role?: boolean
    department?: boolean
    avatar_url?: boolean
    staff_id_number?: boolean
    joining_date?: boolean
    dob?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientsManaged?: boolean | User$clientsManagedArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    tasksReported?: boolean | User$tasksReportedArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    assetsUploaded?: boolean | User$assetsUploadedArgs<ExtArgs>
    assetComments?: boolean | User$assetCommentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clientsManaged: Prisma.$ClientPayload<ExtArgs>[]
      tasksAssigned: Prisma.$TaskPayload<ExtArgs>[]
      tasksReported: Prisma.$TaskPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      assetsUploaded: Prisma.$AssetPayload<ExtArgs>[]
      assetComments: Prisma.$AssetCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      full_name: string
      designation: string | null
      role: string
      department: string
      avatar_url: string | null
      staff_id_number: string | null
      joining_date: Date | null
      dob: Date | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientsManaged<T extends User$clientsManagedArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsManagedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany"> | Null>
    tasksAssigned<T extends User$tasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    tasksReported<T extends User$tasksReportedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksReportedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    timeLogs<T extends User$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    assetsUploaded<T extends User$assetsUploadedArgs<ExtArgs> = {}>(args?: Subset<T, User$assetsUploadedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    assetComments<T extends User$assetCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assetCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly designation: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly avatar_url: FieldRef<"User", 'String'>
    readonly staff_id_number: FieldRef<"User", 'String'>
    readonly joining_date: FieldRef<"User", 'DateTime'>
    readonly dob: FieldRef<"User", 'DateTime'>
    readonly address: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.clientsManaged
   */
  export type User$clientsManagedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.tasksAssigned
   */
  export type User$tasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.tasksReported
   */
  export type User$tasksReportedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.timeLogs
   */
  export type User$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.assetsUploaded
   */
  export type User$assetsUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * User.assetComments
   */
  export type User$assetCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    where?: AssetCommentWhereInput
    orderBy?: AssetCommentOrderByWithRelationInput | AssetCommentOrderByWithRelationInput[]
    cursor?: AssetCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetCommentScalarFieldEnum | AssetCommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand_colors: string | null
    logo_url: string | null
    industry: string | null
    contract_type: string | null
    client_number: string | null
    onboarding_date: Date | null
    address: string | null
    contact_person: string | null
    contact_number: string | null
    website: string | null
    email: string | null
    whatsapp: string | null
    facebook: string | null
    instagram: string | null
    linkedin: string | null
    youtube: string | null
    competitorDetails: string | null
    customerAvatar: string | null
    contentSuggestions: string | null
    referenceLinks: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    account_manager_id: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand_colors: string | null
    logo_url: string | null
    industry: string | null
    contract_type: string | null
    client_number: string | null
    onboarding_date: Date | null
    address: string | null
    contact_person: string | null
    contact_number: string | null
    website: string | null
    email: string | null
    whatsapp: string | null
    facebook: string | null
    instagram: string | null
    linkedin: string | null
    youtube: string | null
    competitorDetails: string | null
    customerAvatar: string | null
    contentSuggestions: string | null
    referenceLinks: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    account_manager_id: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    brand_colors: number
    logo_url: number
    industry: number
    contract_type: number
    client_number: number
    onboarding_date: number
    address: number
    contact_person: number
    contact_number: number
    website: number
    email: number
    whatsapp: number
    facebook: number
    instagram: number
    linkedin: number
    youtube: number
    competitorDetails: number
    customerAvatar: number
    contentSuggestions: number
    referenceLinks: number
    status: number
    createdAt: number
    updatedAt: number
    account_manager_id: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    brand_colors?: true
    logo_url?: true
    industry?: true
    contract_type?: true
    client_number?: true
    onboarding_date?: true
    address?: true
    contact_person?: true
    contact_number?: true
    website?: true
    email?: true
    whatsapp?: true
    facebook?: true
    instagram?: true
    linkedin?: true
    youtube?: true
    competitorDetails?: true
    customerAvatar?: true
    contentSuggestions?: true
    referenceLinks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    account_manager_id?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    brand_colors?: true
    logo_url?: true
    industry?: true
    contract_type?: true
    client_number?: true
    onboarding_date?: true
    address?: true
    contact_person?: true
    contact_number?: true
    website?: true
    email?: true
    whatsapp?: true
    facebook?: true
    instagram?: true
    linkedin?: true
    youtube?: true
    competitorDetails?: true
    customerAvatar?: true
    contentSuggestions?: true
    referenceLinks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    account_manager_id?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    brand_colors?: true
    logo_url?: true
    industry?: true
    contract_type?: true
    client_number?: true
    onboarding_date?: true
    address?: true
    contact_person?: true
    contact_number?: true
    website?: true
    email?: true
    whatsapp?: true
    facebook?: true
    instagram?: true
    linkedin?: true
    youtube?: true
    competitorDetails?: true
    customerAvatar?: true
    contentSuggestions?: true
    referenceLinks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    account_manager_id?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    brand_colors: string | null
    logo_url: string | null
    industry: string | null
    contract_type: string | null
    client_number: string | null
    onboarding_date: Date | null
    address: string | null
    contact_person: string | null
    contact_number: string | null
    website: string | null
    email: string | null
    whatsapp: string | null
    facebook: string | null
    instagram: string | null
    linkedin: string | null
    youtube: string | null
    competitorDetails: string | null
    customerAvatar: string | null
    contentSuggestions: string | null
    referenceLinks: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    account_manager_id: string | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand_colors?: boolean
    logo_url?: boolean
    industry?: boolean
    contract_type?: boolean
    client_number?: boolean
    onboarding_date?: boolean
    address?: boolean
    contact_person?: boolean
    contact_number?: boolean
    website?: boolean
    email?: boolean
    whatsapp?: boolean
    facebook?: boolean
    instagram?: boolean
    linkedin?: boolean
    youtube?: boolean
    competitorDetails?: boolean
    customerAvatar?: boolean
    contentSuggestions?: boolean
    referenceLinks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account_manager_id?: boolean
    account_manager?: boolean | Client$account_managerArgs<ExtArgs>
    campaigns?: boolean | Client$campaignsArgs<ExtArgs>
    tasks?: boolean | Client$tasksArgs<ExtArgs>
    ad_accounts?: boolean | Client$ad_accountsArgs<ExtArgs>
    contentCalendars?: boolean | Client$contentCalendarsArgs<ExtArgs>
    ledgers?: boolean | Client$ledgersArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand_colors?: boolean
    logo_url?: boolean
    industry?: boolean
    contract_type?: boolean
    client_number?: boolean
    onboarding_date?: boolean
    address?: boolean
    contact_person?: boolean
    contact_number?: boolean
    website?: boolean
    email?: boolean
    whatsapp?: boolean
    facebook?: boolean
    instagram?: boolean
    linkedin?: boolean
    youtube?: boolean
    competitorDetails?: boolean
    customerAvatar?: boolean
    contentSuggestions?: boolean
    referenceLinks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account_manager_id?: boolean
    account_manager?: boolean | Client$account_managerArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    brand_colors?: boolean
    logo_url?: boolean
    industry?: boolean
    contract_type?: boolean
    client_number?: boolean
    onboarding_date?: boolean
    address?: boolean
    contact_person?: boolean
    contact_number?: boolean
    website?: boolean
    email?: boolean
    whatsapp?: boolean
    facebook?: boolean
    instagram?: boolean
    linkedin?: boolean
    youtube?: boolean
    competitorDetails?: boolean
    customerAvatar?: boolean
    contentSuggestions?: boolean
    referenceLinks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account_manager_id?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_manager?: boolean | Client$account_managerArgs<ExtArgs>
    campaigns?: boolean | Client$campaignsArgs<ExtArgs>
    tasks?: boolean | Client$tasksArgs<ExtArgs>
    ad_accounts?: boolean | Client$ad_accountsArgs<ExtArgs>
    contentCalendars?: boolean | Client$contentCalendarsArgs<ExtArgs>
    ledgers?: boolean | Client$ledgersArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_manager?: boolean | Client$account_managerArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      account_manager: Prisma.$UserPayload<ExtArgs> | null
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      ad_accounts: Prisma.$AdAccountPayload<ExtArgs>[]
      contentCalendars: Prisma.$ContentCalendarPayload<ExtArgs>[]
      ledgers: Prisma.$LedgerPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand_colors: string | null
      logo_url: string | null
      industry: string | null
      contract_type: string | null
      client_number: string | null
      onboarding_date: Date | null
      address: string | null
      contact_person: string | null
      contact_number: string | null
      website: string | null
      email: string | null
      whatsapp: string | null
      facebook: string | null
      instagram: string | null
      linkedin: string | null
      youtube: string | null
      competitorDetails: string | null
      customerAvatar: string | null
      contentSuggestions: string | null
      referenceLinks: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      account_manager_id: string | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account_manager<T extends Client$account_managerArgs<ExtArgs> = {}>(args?: Subset<T, Client$account_managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    campaigns<T extends Client$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Client$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Client$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Client$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    ad_accounts<T extends Client$ad_accountsArgs<ExtArgs> = {}>(args?: Subset<T, Client$ad_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findMany"> | Null>
    contentCalendars<T extends Client$contentCalendarsArgs<ExtArgs> = {}>(args?: Subset<T, Client$contentCalendarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findMany"> | Null>
    ledgers<T extends Client$ledgersArgs<ExtArgs> = {}>(args?: Subset<T, Client$ledgersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Client$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Client$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly brand_colors: FieldRef<"Client", 'String'>
    readonly logo_url: FieldRef<"Client", 'String'>
    readonly industry: FieldRef<"Client", 'String'>
    readonly contract_type: FieldRef<"Client", 'String'>
    readonly client_number: FieldRef<"Client", 'String'>
    readonly onboarding_date: FieldRef<"Client", 'DateTime'>
    readonly address: FieldRef<"Client", 'String'>
    readonly contact_person: FieldRef<"Client", 'String'>
    readonly contact_number: FieldRef<"Client", 'String'>
    readonly website: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly whatsapp: FieldRef<"Client", 'String'>
    readonly facebook: FieldRef<"Client", 'String'>
    readonly instagram: FieldRef<"Client", 'String'>
    readonly linkedin: FieldRef<"Client", 'String'>
    readonly youtube: FieldRef<"Client", 'String'>
    readonly competitorDetails: FieldRef<"Client", 'String'>
    readonly customerAvatar: FieldRef<"Client", 'String'>
    readonly contentSuggestions: FieldRef<"Client", 'String'>
    readonly referenceLinks: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly account_manager_id: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client.account_manager
   */
  export type Client$account_managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Client.campaigns
   */
  export type Client$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Client.tasks
   */
  export type Client$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Client.ad_accounts
   */
  export type Client$ad_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    where?: AdAccountWhereInput
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    cursor?: AdAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * Client.contentCalendars
   */
  export type Client$contentCalendarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    where?: ContentCalendarWhereInput
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    cursor?: ContentCalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * Client.ledgers
   */
  export type Client$ledgersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    where?: LedgerWhereInput
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    cursor?: LedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Client.invoices
   */
  export type Client$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ContentCalendar
   */

  export type AggregateContentCalendar = {
    _count: ContentCalendarCountAggregateOutputType | null
    _avg: ContentCalendarAvgAggregateOutputType | null
    _sum: ContentCalendarSumAggregateOutputType | null
    _min: ContentCalendarMinAggregateOutputType | null
    _max: ContentCalendarMaxAggregateOutputType | null
  }

  export type ContentCalendarAvgAggregateOutputType = {
    quantity: number | null
    completed: number | null
    inProgress: number | null
  }

  export type ContentCalendarSumAggregateOutputType = {
    quantity: number | null
    completed: number | null
    inProgress: number | null
  }

  export type ContentCalendarMinAggregateOutputType = {
    id: string | null
    date: Date | null
    creativeType: string | null
    quantity: number | null
    completed: number | null
    inProgress: number | null
    createdAt: Date | null
    updatedAt: Date | null
    client_id: string | null
  }

  export type ContentCalendarMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    creativeType: string | null
    quantity: number | null
    completed: number | null
    inProgress: number | null
    createdAt: Date | null
    updatedAt: Date | null
    client_id: string | null
  }

  export type ContentCalendarCountAggregateOutputType = {
    id: number
    date: number
    creativeType: number
    quantity: number
    completed: number
    inProgress: number
    createdAt: number
    updatedAt: number
    client_id: number
    _all: number
  }


  export type ContentCalendarAvgAggregateInputType = {
    quantity?: true
    completed?: true
    inProgress?: true
  }

  export type ContentCalendarSumAggregateInputType = {
    quantity?: true
    completed?: true
    inProgress?: true
  }

  export type ContentCalendarMinAggregateInputType = {
    id?: true
    date?: true
    creativeType?: true
    quantity?: true
    completed?: true
    inProgress?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
  }

  export type ContentCalendarMaxAggregateInputType = {
    id?: true
    date?: true
    creativeType?: true
    quantity?: true
    completed?: true
    inProgress?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
  }

  export type ContentCalendarCountAggregateInputType = {
    id?: true
    date?: true
    creativeType?: true
    quantity?: true
    completed?: true
    inProgress?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
    _all?: true
  }

  export type ContentCalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentCalendar to aggregate.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentCalendars
    **/
    _count?: true | ContentCalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentCalendarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentCalendarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentCalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentCalendarMaxAggregateInputType
  }

  export type GetContentCalendarAggregateType<T extends ContentCalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateContentCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentCalendar[P]>
      : GetScalarType<T[P], AggregateContentCalendar[P]>
  }




  export type ContentCalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCalendarWhereInput
    orderBy?: ContentCalendarOrderByWithAggregationInput | ContentCalendarOrderByWithAggregationInput[]
    by: ContentCalendarScalarFieldEnum[] | ContentCalendarScalarFieldEnum
    having?: ContentCalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCalendarCountAggregateInputType | true
    _avg?: ContentCalendarAvgAggregateInputType
    _sum?: ContentCalendarSumAggregateInputType
    _min?: ContentCalendarMinAggregateInputType
    _max?: ContentCalendarMaxAggregateInputType
  }

  export type ContentCalendarGroupByOutputType = {
    id: string
    date: Date
    creativeType: string
    quantity: number
    completed: number
    inProgress: number
    createdAt: Date
    updatedAt: Date
    client_id: string
    _count: ContentCalendarCountAggregateOutputType | null
    _avg: ContentCalendarAvgAggregateOutputType | null
    _sum: ContentCalendarSumAggregateOutputType | null
    _min: ContentCalendarMinAggregateOutputType | null
    _max: ContentCalendarMaxAggregateOutputType | null
  }

  type GetContentCalendarGroupByPayload<T extends ContentCalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentCalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentCalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentCalendarGroupByOutputType[P]>
            : GetScalarType<T[P], ContentCalendarGroupByOutputType[P]>
        }
      >
    >


  export type ContentCalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    creativeType?: boolean
    quantity?: boolean
    completed?: boolean
    inProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCalendar"]>

  export type ContentCalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    creativeType?: boolean
    quantity?: boolean
    completed?: boolean
    inProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentCalendar"]>

  export type ContentCalendarSelectScalar = {
    id?: boolean
    date?: boolean
    creativeType?: boolean
    quantity?: boolean
    completed?: boolean
    inProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
  }

  export type ContentCalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ContentCalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ContentCalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentCalendar"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      creativeType: string
      quantity: number
      completed: number
      inProgress: number
      createdAt: Date
      updatedAt: Date
      client_id: string
    }, ExtArgs["result"]["contentCalendar"]>
    composites: {}
  }

  type ContentCalendarGetPayload<S extends boolean | null | undefined | ContentCalendarDefaultArgs> = $Result.GetResult<Prisma.$ContentCalendarPayload, S>

  type ContentCalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentCalendarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentCalendarCountAggregateInputType | true
    }

  export interface ContentCalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentCalendar'], meta: { name: 'ContentCalendar' } }
    /**
     * Find zero or one ContentCalendar that matches the filter.
     * @param {ContentCalendarFindUniqueArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentCalendarFindUniqueArgs>(args: SelectSubset<T, ContentCalendarFindUniqueArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentCalendar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentCalendarFindUniqueOrThrowArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentCalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentCalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentCalendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarFindFirstArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentCalendarFindFirstArgs>(args?: SelectSubset<T, ContentCalendarFindFirstArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentCalendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarFindFirstOrThrowArgs} args - Arguments to find a ContentCalendar
     * @example
     * // Get one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentCalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentCalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentCalendars
     * const contentCalendars = await prisma.contentCalendar.findMany()
     * 
     * // Get first 10 ContentCalendars
     * const contentCalendars = await prisma.contentCalendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentCalendarWithIdOnly = await prisma.contentCalendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentCalendarFindManyArgs>(args?: SelectSubset<T, ContentCalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentCalendar.
     * @param {ContentCalendarCreateArgs} args - Arguments to create a ContentCalendar.
     * @example
     * // Create one ContentCalendar
     * const ContentCalendar = await prisma.contentCalendar.create({
     *   data: {
     *     // ... data to create a ContentCalendar
     *   }
     * })
     * 
     */
    create<T extends ContentCalendarCreateArgs>(args: SelectSubset<T, ContentCalendarCreateArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentCalendars.
     * @param {ContentCalendarCreateManyArgs} args - Arguments to create many ContentCalendars.
     * @example
     * // Create many ContentCalendars
     * const contentCalendar = await prisma.contentCalendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCalendarCreateManyArgs>(args?: SelectSubset<T, ContentCalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentCalendars and returns the data saved in the database.
     * @param {ContentCalendarCreateManyAndReturnArgs} args - Arguments to create many ContentCalendars.
     * @example
     * // Create many ContentCalendars
     * const contentCalendar = await prisma.contentCalendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentCalendars and only return the `id`
     * const contentCalendarWithIdOnly = await prisma.contentCalendar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentCalendar.
     * @param {ContentCalendarDeleteArgs} args - Arguments to delete one ContentCalendar.
     * @example
     * // Delete one ContentCalendar
     * const ContentCalendar = await prisma.contentCalendar.delete({
     *   where: {
     *     // ... filter to delete one ContentCalendar
     *   }
     * })
     * 
     */
    delete<T extends ContentCalendarDeleteArgs>(args: SelectSubset<T, ContentCalendarDeleteArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentCalendar.
     * @param {ContentCalendarUpdateArgs} args - Arguments to update one ContentCalendar.
     * @example
     * // Update one ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentCalendarUpdateArgs>(args: SelectSubset<T, ContentCalendarUpdateArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentCalendars.
     * @param {ContentCalendarDeleteManyArgs} args - Arguments to filter ContentCalendars to delete.
     * @example
     * // Delete a few ContentCalendars
     * const { count } = await prisma.contentCalendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentCalendarDeleteManyArgs>(args?: SelectSubset<T, ContentCalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentCalendars
     * const contentCalendar = await prisma.contentCalendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentCalendarUpdateManyArgs>(args: SelectSubset<T, ContentCalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentCalendar.
     * @param {ContentCalendarUpsertArgs} args - Arguments to update or create a ContentCalendar.
     * @example
     * // Update or create a ContentCalendar
     * const contentCalendar = await prisma.contentCalendar.upsert({
     *   create: {
     *     // ... data to create a ContentCalendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentCalendar we want to update
     *   }
     * })
     */
    upsert<T extends ContentCalendarUpsertArgs>(args: SelectSubset<T, ContentCalendarUpsertArgs<ExtArgs>>): Prisma__ContentCalendarClient<$Result.GetResult<Prisma.$ContentCalendarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarCountArgs} args - Arguments to filter ContentCalendars to count.
     * @example
     * // Count the number of ContentCalendars
     * const count = await prisma.contentCalendar.count({
     *   where: {
     *     // ... the filter for the ContentCalendars we want to count
     *   }
     * })
    **/
    count<T extends ContentCalendarCountArgs>(
      args?: Subset<T, ContentCalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentCalendarAggregateArgs>(args: Subset<T, ContentCalendarAggregateArgs>): Prisma.PrismaPromise<GetContentCalendarAggregateType<T>>

    /**
     * Group by ContentCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentCalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentCalendarGroupByArgs['orderBy'] }
        : { orderBy?: ContentCalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentCalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentCalendar model
   */
  readonly fields: ContentCalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentCalendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentCalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentCalendar model
   */ 
  interface ContentCalendarFieldRefs {
    readonly id: FieldRef<"ContentCalendar", 'String'>
    readonly date: FieldRef<"ContentCalendar", 'DateTime'>
    readonly creativeType: FieldRef<"ContentCalendar", 'String'>
    readonly quantity: FieldRef<"ContentCalendar", 'Int'>
    readonly completed: FieldRef<"ContentCalendar", 'Int'>
    readonly inProgress: FieldRef<"ContentCalendar", 'Int'>
    readonly createdAt: FieldRef<"ContentCalendar", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentCalendar", 'DateTime'>
    readonly client_id: FieldRef<"ContentCalendar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentCalendar findUnique
   */
  export type ContentCalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar findUniqueOrThrow
   */
  export type ContentCalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar findFirst
   */
  export type ContentCalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentCalendars.
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentCalendars.
     */
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * ContentCalendar findFirstOrThrow
   */
  export type ContentCalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendar to fetch.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentCalendars.
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentCalendars.
     */
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * ContentCalendar findMany
   */
  export type ContentCalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter, which ContentCalendars to fetch.
     */
    where?: ContentCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentCalendars to fetch.
     */
    orderBy?: ContentCalendarOrderByWithRelationInput | ContentCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentCalendars.
     */
    cursor?: ContentCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentCalendars.
     */
    skip?: number
    distinct?: ContentCalendarScalarFieldEnum | ContentCalendarScalarFieldEnum[]
  }

  /**
   * ContentCalendar create
   */
  export type ContentCalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentCalendar.
     */
    data: XOR<ContentCalendarCreateInput, ContentCalendarUncheckedCreateInput>
  }

  /**
   * ContentCalendar createMany
   */
  export type ContentCalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentCalendars.
     */
    data: ContentCalendarCreateManyInput | ContentCalendarCreateManyInput[]
  }

  /**
   * ContentCalendar createManyAndReturn
   */
  export type ContentCalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentCalendars.
     */
    data: ContentCalendarCreateManyInput | ContentCalendarCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentCalendar update
   */
  export type ContentCalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentCalendar.
     */
    data: XOR<ContentCalendarUpdateInput, ContentCalendarUncheckedUpdateInput>
    /**
     * Choose, which ContentCalendar to update.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar updateMany
   */
  export type ContentCalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentCalendars.
     */
    data: XOR<ContentCalendarUpdateManyMutationInput, ContentCalendarUncheckedUpdateManyInput>
    /**
     * Filter which ContentCalendars to update
     */
    where?: ContentCalendarWhereInput
  }

  /**
   * ContentCalendar upsert
   */
  export type ContentCalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentCalendar to update in case it exists.
     */
    where: ContentCalendarWhereUniqueInput
    /**
     * In case the ContentCalendar found by the `where` argument doesn't exist, create a new ContentCalendar with this data.
     */
    create: XOR<ContentCalendarCreateInput, ContentCalendarUncheckedCreateInput>
    /**
     * In case the ContentCalendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentCalendarUpdateInput, ContentCalendarUncheckedUpdateInput>
  }

  /**
   * ContentCalendar delete
   */
  export type ContentCalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
    /**
     * Filter which ContentCalendar to delete.
     */
    where: ContentCalendarWhereUniqueInput
  }

  /**
   * ContentCalendar deleteMany
   */
  export type ContentCalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentCalendars to delete
     */
    where?: ContentCalendarWhereInput
  }

  /**
   * ContentCalendar without action
   */
  export type ContentCalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCalendar
     */
    select?: ContentCalendarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCalendarInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    budget: number | null
  }

  export type CampaignSumAggregateOutputType = {
    budget: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    title: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    budget: number | null
    goals: string | null
    createdAt: Date | null
    updatedAt: Date | null
    client_id: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    title: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    budget: number | null
    goals: string | null
    createdAt: Date | null
    updatedAt: Date | null
    client_id: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    title: number
    start_date: number
    end_date: number
    status: number
    budget: number
    goals: number
    createdAt: number
    updatedAt: number
    client_id: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    budget?: true
  }

  export type CampaignSumAggregateInputType = {
    budget?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    title?: true
    start_date?: true
    end_date?: true
    status?: true
    budget?: true
    goals?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    title?: true
    start_date?: true
    end_date?: true
    status?: true
    budget?: true
    goals?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    title?: true
    start_date?: true
    end_date?: true
    status?: true
    budget?: true
    goals?: true
    createdAt?: true
    updatedAt?: true
    client_id?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    title: string
    start_date: Date
    end_date: Date
    status: string
    budget: number | null
    goals: string | null
    createdAt: Date
    updatedAt: Date
    client_id: string
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    budget?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tasks?: boolean | Campaign$tasksArgs<ExtArgs>
    ad_groups?: boolean | Campaign$ad_groupsArgs<ExtArgs>
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    budget?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    title?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    budget?: boolean
    goals?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client_id?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tasks?: boolean | Campaign$tasksArgs<ExtArgs>
    ad_groups?: boolean | Campaign$ad_groupsArgs<ExtArgs>
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      ad_groups: Prisma.$AdGroupPayload<ExtArgs>[]
      metrics: Prisma.$CampaignMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      start_date: Date
      end_date: Date
      status: string
      budget: number | null
      goals: string | null
      createdAt: Date
      updatedAt: Date
      client_id: string
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends Campaign$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    ad_groups<T extends Campaign$ad_groupsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$ad_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findMany"> | Null>
    metrics<T extends Campaign$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly title: FieldRef<"Campaign", 'String'>
    readonly start_date: FieldRef<"Campaign", 'DateTime'>
    readonly end_date: FieldRef<"Campaign", 'DateTime'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly budget: FieldRef<"Campaign", 'Float'>
    readonly goals: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly client_id: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.tasks
   */
  export type Campaign$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Campaign.ad_groups
   */
  export type Campaign$ad_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    where?: AdGroupWhereInput
    orderBy?: AdGroupOrderByWithRelationInput | AdGroupOrderByWithRelationInput[]
    cursor?: AdGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdGroupScalarFieldEnum | AdGroupScalarFieldEnum[]
  }

  /**
   * Campaign.metrics
   */
  export type Campaign$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    where?: CampaignMetricWhereInput
    orderBy?: CampaignMetricOrderByWithRelationInput | CampaignMetricOrderByWithRelationInput[]
    cursor?: CampaignMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMetricScalarFieldEnum | CampaignMetricScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model AdAccount
   */

  export type AggregateAdAccount = {
    _count: AdAccountCountAggregateOutputType | null
    _min: AdAccountMinAggregateOutputType | null
    _max: AdAccountMaxAggregateOutputType | null
  }

  export type AdAccountMinAggregateOutputType = {
    id: string | null
    platform: string | null
    external_id: string | null
    status: string | null
    currency: string | null
    client_id: string | null
  }

  export type AdAccountMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    external_id: string | null
    status: string | null
    currency: string | null
    client_id: string | null
  }

  export type AdAccountCountAggregateOutputType = {
    id: number
    platform: number
    external_id: number
    status: number
    currency: number
    client_id: number
    _all: number
  }


  export type AdAccountMinAggregateInputType = {
    id?: true
    platform?: true
    external_id?: true
    status?: true
    currency?: true
    client_id?: true
  }

  export type AdAccountMaxAggregateInputType = {
    id?: true
    platform?: true
    external_id?: true
    status?: true
    currency?: true
    client_id?: true
  }

  export type AdAccountCountAggregateInputType = {
    id?: true
    platform?: true
    external_id?: true
    status?: true
    currency?: true
    client_id?: true
    _all?: true
  }

  export type AdAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdAccount to aggregate.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdAccounts
    **/
    _count?: true | AdAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdAccountMaxAggregateInputType
  }

  export type GetAdAccountAggregateType<T extends AdAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAdAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdAccount[P]>
      : GetScalarType<T[P], AggregateAdAccount[P]>
  }




  export type AdAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdAccountWhereInput
    orderBy?: AdAccountOrderByWithAggregationInput | AdAccountOrderByWithAggregationInput[]
    by: AdAccountScalarFieldEnum[] | AdAccountScalarFieldEnum
    having?: AdAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdAccountCountAggregateInputType | true
    _min?: AdAccountMinAggregateInputType
    _max?: AdAccountMaxAggregateInputType
  }

  export type AdAccountGroupByOutputType = {
    id: string
    platform: string
    external_id: string
    status: string
    currency: string
    client_id: string
    _count: AdAccountCountAggregateOutputType | null
    _min: AdAccountMinAggregateOutputType | null
    _max: AdAccountMaxAggregateOutputType | null
  }

  type GetAdAccountGroupByPayload<T extends AdAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdAccountGroupByOutputType[P]>
            : GetScalarType<T[P], AdAccountGroupByOutputType[P]>
        }
      >
    >


  export type AdAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    external_id?: boolean
    status?: boolean
    currency?: boolean
    client_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    ad_groups?: boolean | AdAccount$ad_groupsArgs<ExtArgs>
    _count?: boolean | AdAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adAccount"]>

  export type AdAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    external_id?: boolean
    status?: boolean
    currency?: boolean
    client_id?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adAccount"]>

  export type AdAccountSelectScalar = {
    id?: boolean
    platform?: boolean
    external_id?: boolean
    status?: boolean
    currency?: boolean
    client_id?: boolean
  }

  export type AdAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    ad_groups?: boolean | AdAccount$ad_groupsArgs<ExtArgs>
    _count?: boolean | AdAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $AdAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdAccount"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      ad_groups: Prisma.$AdGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      external_id: string
      status: string
      currency: string
      client_id: string
    }, ExtArgs["result"]["adAccount"]>
    composites: {}
  }

  type AdAccountGetPayload<S extends boolean | null | undefined | AdAccountDefaultArgs> = $Result.GetResult<Prisma.$AdAccountPayload, S>

  type AdAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdAccountCountAggregateInputType | true
    }

  export interface AdAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdAccount'], meta: { name: 'AdAccount' } }
    /**
     * Find zero or one AdAccount that matches the filter.
     * @param {AdAccountFindUniqueArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdAccountFindUniqueArgs>(args: SelectSubset<T, AdAccountFindUniqueArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdAccountFindUniqueOrThrowArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AdAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindFirstArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdAccountFindFirstArgs>(args?: SelectSubset<T, AdAccountFindFirstArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindFirstOrThrowArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AdAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdAccounts
     * const adAccounts = await prisma.adAccount.findMany()
     * 
     * // Get first 10 AdAccounts
     * const adAccounts = await prisma.adAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adAccountWithIdOnly = await prisma.adAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdAccountFindManyArgs>(args?: SelectSubset<T, AdAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdAccount.
     * @param {AdAccountCreateArgs} args - Arguments to create a AdAccount.
     * @example
     * // Create one AdAccount
     * const AdAccount = await prisma.adAccount.create({
     *   data: {
     *     // ... data to create a AdAccount
     *   }
     * })
     * 
     */
    create<T extends AdAccountCreateArgs>(args: SelectSubset<T, AdAccountCreateArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdAccounts.
     * @param {AdAccountCreateManyArgs} args - Arguments to create many AdAccounts.
     * @example
     * // Create many AdAccounts
     * const adAccount = await prisma.adAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdAccountCreateManyArgs>(args?: SelectSubset<T, AdAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdAccounts and returns the data saved in the database.
     * @param {AdAccountCreateManyAndReturnArgs} args - Arguments to create many AdAccounts.
     * @example
     * // Create many AdAccounts
     * const adAccount = await prisma.adAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdAccounts and only return the `id`
     * const adAccountWithIdOnly = await prisma.adAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AdAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdAccount.
     * @param {AdAccountDeleteArgs} args - Arguments to delete one AdAccount.
     * @example
     * // Delete one AdAccount
     * const AdAccount = await prisma.adAccount.delete({
     *   where: {
     *     // ... filter to delete one AdAccount
     *   }
     * })
     * 
     */
    delete<T extends AdAccountDeleteArgs>(args: SelectSubset<T, AdAccountDeleteArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdAccount.
     * @param {AdAccountUpdateArgs} args - Arguments to update one AdAccount.
     * @example
     * // Update one AdAccount
     * const adAccount = await prisma.adAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdAccountUpdateArgs>(args: SelectSubset<T, AdAccountUpdateArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdAccounts.
     * @param {AdAccountDeleteManyArgs} args - Arguments to filter AdAccounts to delete.
     * @example
     * // Delete a few AdAccounts
     * const { count } = await prisma.adAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdAccountDeleteManyArgs>(args?: SelectSubset<T, AdAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdAccounts
     * const adAccount = await prisma.adAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdAccountUpdateManyArgs>(args: SelectSubset<T, AdAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdAccount.
     * @param {AdAccountUpsertArgs} args - Arguments to update or create a AdAccount.
     * @example
     * // Update or create a AdAccount
     * const adAccount = await prisma.adAccount.upsert({
     *   create: {
     *     // ... data to create a AdAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdAccount we want to update
     *   }
     * })
     */
    upsert<T extends AdAccountUpsertArgs>(args: SelectSubset<T, AdAccountUpsertArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountCountArgs} args - Arguments to filter AdAccounts to count.
     * @example
     * // Count the number of AdAccounts
     * const count = await prisma.adAccount.count({
     *   where: {
     *     // ... the filter for the AdAccounts we want to count
     *   }
     * })
    **/
    count<T extends AdAccountCountArgs>(
      args?: Subset<T, AdAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAccountAggregateArgs>(args: Subset<T, AdAccountAggregateArgs>): Prisma.PrismaPromise<GetAdAccountAggregateType<T>>

    /**
     * Group by AdAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdAccountGroupByArgs['orderBy'] }
        : { orderBy?: AdAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdAccount model
   */
  readonly fields: AdAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ad_groups<T extends AdAccount$ad_groupsArgs<ExtArgs> = {}>(args?: Subset<T, AdAccount$ad_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdAccount model
   */ 
  interface AdAccountFieldRefs {
    readonly id: FieldRef<"AdAccount", 'String'>
    readonly platform: FieldRef<"AdAccount", 'String'>
    readonly external_id: FieldRef<"AdAccount", 'String'>
    readonly status: FieldRef<"AdAccount", 'String'>
    readonly currency: FieldRef<"AdAccount", 'String'>
    readonly client_id: FieldRef<"AdAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdAccount findUnique
   */
  export type AdAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount findUniqueOrThrow
   */
  export type AdAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount findFirst
   */
  export type AdAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdAccounts.
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdAccounts.
     */
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * AdAccount findFirstOrThrow
   */
  export type AdAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdAccounts.
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdAccounts.
     */
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * AdAccount findMany
   */
  export type AdAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccounts to fetch.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdAccounts.
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * AdAccount create
   */
  export type AdAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a AdAccount.
     */
    data: XOR<AdAccountCreateInput, AdAccountUncheckedCreateInput>
  }

  /**
   * AdAccount createMany
   */
  export type AdAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdAccounts.
     */
    data: AdAccountCreateManyInput | AdAccountCreateManyInput[]
  }

  /**
   * AdAccount createManyAndReturn
   */
  export type AdAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdAccounts.
     */
    data: AdAccountCreateManyInput | AdAccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdAccount update
   */
  export type AdAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a AdAccount.
     */
    data: XOR<AdAccountUpdateInput, AdAccountUncheckedUpdateInput>
    /**
     * Choose, which AdAccount to update.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount updateMany
   */
  export type AdAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdAccounts.
     */
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyInput>
    /**
     * Filter which AdAccounts to update
     */
    where?: AdAccountWhereInput
  }

  /**
   * AdAccount upsert
   */
  export type AdAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the AdAccount to update in case it exists.
     */
    where: AdAccountWhereUniqueInput
    /**
     * In case the AdAccount found by the `where` argument doesn't exist, create a new AdAccount with this data.
     */
    create: XOR<AdAccountCreateInput, AdAccountUncheckedCreateInput>
    /**
     * In case the AdAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdAccountUpdateInput, AdAccountUncheckedUpdateInput>
  }

  /**
   * AdAccount delete
   */
  export type AdAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter which AdAccount to delete.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount deleteMany
   */
  export type AdAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdAccounts to delete
     */
    where?: AdAccountWhereInput
  }

  /**
   * AdAccount.ad_groups
   */
  export type AdAccount$ad_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    where?: AdGroupWhereInput
    orderBy?: AdGroupOrderByWithRelationInput | AdGroupOrderByWithRelationInput[]
    cursor?: AdGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdGroupScalarFieldEnum | AdGroupScalarFieldEnum[]
  }

  /**
   * AdAccount without action
   */
  export type AdAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
  }


  /**
   * Model AdGroup
   */

  export type AggregateAdGroup = {
    _count: AdGroupCountAggregateOutputType | null
    _min: AdGroupMinAggregateOutputType | null
    _max: AdGroupMaxAggregateOutputType | null
  }

  export type AdGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    external_id: string | null
    status: string | null
    campaign_id: string | null
    ad_account_id: string | null
  }

  export type AdGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    external_id: string | null
    status: string | null
    campaign_id: string | null
    ad_account_id: string | null
  }

  export type AdGroupCountAggregateOutputType = {
    id: number
    name: number
    external_id: number
    status: number
    campaign_id: number
    ad_account_id: number
    _all: number
  }


  export type AdGroupMinAggregateInputType = {
    id?: true
    name?: true
    external_id?: true
    status?: true
    campaign_id?: true
    ad_account_id?: true
  }

  export type AdGroupMaxAggregateInputType = {
    id?: true
    name?: true
    external_id?: true
    status?: true
    campaign_id?: true
    ad_account_id?: true
  }

  export type AdGroupCountAggregateInputType = {
    id?: true
    name?: true
    external_id?: true
    status?: true
    campaign_id?: true
    ad_account_id?: true
    _all?: true
  }

  export type AdGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdGroup to aggregate.
     */
    where?: AdGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdGroups to fetch.
     */
    orderBy?: AdGroupOrderByWithRelationInput | AdGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdGroups
    **/
    _count?: true | AdGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdGroupMaxAggregateInputType
  }

  export type GetAdGroupAggregateType<T extends AdGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateAdGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdGroup[P]>
      : GetScalarType<T[P], AggregateAdGroup[P]>
  }




  export type AdGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdGroupWhereInput
    orderBy?: AdGroupOrderByWithAggregationInput | AdGroupOrderByWithAggregationInput[]
    by: AdGroupScalarFieldEnum[] | AdGroupScalarFieldEnum
    having?: AdGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdGroupCountAggregateInputType | true
    _min?: AdGroupMinAggregateInputType
    _max?: AdGroupMaxAggregateInputType
  }

  export type AdGroupGroupByOutputType = {
    id: string
    name: string
    external_id: string | null
    status: string
    campaign_id: string
    ad_account_id: string | null
    _count: AdGroupCountAggregateOutputType | null
    _min: AdGroupMinAggregateOutputType | null
    _max: AdGroupMaxAggregateOutputType | null
  }

  type GetAdGroupGroupByPayload<T extends AdGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdGroupGroupByOutputType[P]>
            : GetScalarType<T[P], AdGroupGroupByOutputType[P]>
        }
      >
    >


  export type AdGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    external_id?: boolean
    status?: boolean
    campaign_id?: boolean
    ad_account_id?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    ad_account?: boolean | AdGroup$ad_accountArgs<ExtArgs>
    ads?: boolean | AdGroup$adsArgs<ExtArgs>
    _count?: boolean | AdGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adGroup"]>

  export type AdGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    external_id?: boolean
    status?: boolean
    campaign_id?: boolean
    ad_account_id?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    ad_account?: boolean | AdGroup$ad_accountArgs<ExtArgs>
  }, ExtArgs["result"]["adGroup"]>

  export type AdGroupSelectScalar = {
    id?: boolean
    name?: boolean
    external_id?: boolean
    status?: boolean
    campaign_id?: boolean
    ad_account_id?: boolean
  }

  export type AdGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    ad_account?: boolean | AdGroup$ad_accountArgs<ExtArgs>
    ads?: boolean | AdGroup$adsArgs<ExtArgs>
    _count?: boolean | AdGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    ad_account?: boolean | AdGroup$ad_accountArgs<ExtArgs>
  }

  export type $AdGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdGroup"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      ad_account: Prisma.$AdAccountPayload<ExtArgs> | null
      ads: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      external_id: string | null
      status: string
      campaign_id: string
      ad_account_id: string | null
    }, ExtArgs["result"]["adGroup"]>
    composites: {}
  }

  type AdGroupGetPayload<S extends boolean | null | undefined | AdGroupDefaultArgs> = $Result.GetResult<Prisma.$AdGroupPayload, S>

  type AdGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdGroupCountAggregateInputType | true
    }

  export interface AdGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdGroup'], meta: { name: 'AdGroup' } }
    /**
     * Find zero or one AdGroup that matches the filter.
     * @param {AdGroupFindUniqueArgs} args - Arguments to find a AdGroup
     * @example
     * // Get one AdGroup
     * const adGroup = await prisma.adGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdGroupFindUniqueArgs>(args: SelectSubset<T, AdGroupFindUniqueArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdGroupFindUniqueOrThrowArgs} args - Arguments to find a AdGroup
     * @example
     * // Get one AdGroup
     * const adGroup = await prisma.adGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, AdGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupFindFirstArgs} args - Arguments to find a AdGroup
     * @example
     * // Get one AdGroup
     * const adGroup = await prisma.adGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdGroupFindFirstArgs>(args?: SelectSubset<T, AdGroupFindFirstArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupFindFirstOrThrowArgs} args - Arguments to find a AdGroup
     * @example
     * // Get one AdGroup
     * const adGroup = await prisma.adGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, AdGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdGroups
     * const adGroups = await prisma.adGroup.findMany()
     * 
     * // Get first 10 AdGroups
     * const adGroups = await prisma.adGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adGroupWithIdOnly = await prisma.adGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdGroupFindManyArgs>(args?: SelectSubset<T, AdGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdGroup.
     * @param {AdGroupCreateArgs} args - Arguments to create a AdGroup.
     * @example
     * // Create one AdGroup
     * const AdGroup = await prisma.adGroup.create({
     *   data: {
     *     // ... data to create a AdGroup
     *   }
     * })
     * 
     */
    create<T extends AdGroupCreateArgs>(args: SelectSubset<T, AdGroupCreateArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdGroups.
     * @param {AdGroupCreateManyArgs} args - Arguments to create many AdGroups.
     * @example
     * // Create many AdGroups
     * const adGroup = await prisma.adGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdGroupCreateManyArgs>(args?: SelectSubset<T, AdGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdGroups and returns the data saved in the database.
     * @param {AdGroupCreateManyAndReturnArgs} args - Arguments to create many AdGroups.
     * @example
     * // Create many AdGroups
     * const adGroup = await prisma.adGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdGroups and only return the `id`
     * const adGroupWithIdOnly = await prisma.adGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, AdGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdGroup.
     * @param {AdGroupDeleteArgs} args - Arguments to delete one AdGroup.
     * @example
     * // Delete one AdGroup
     * const AdGroup = await prisma.adGroup.delete({
     *   where: {
     *     // ... filter to delete one AdGroup
     *   }
     * })
     * 
     */
    delete<T extends AdGroupDeleteArgs>(args: SelectSubset<T, AdGroupDeleteArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdGroup.
     * @param {AdGroupUpdateArgs} args - Arguments to update one AdGroup.
     * @example
     * // Update one AdGroup
     * const adGroup = await prisma.adGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdGroupUpdateArgs>(args: SelectSubset<T, AdGroupUpdateArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdGroups.
     * @param {AdGroupDeleteManyArgs} args - Arguments to filter AdGroups to delete.
     * @example
     * // Delete a few AdGroups
     * const { count } = await prisma.adGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdGroupDeleteManyArgs>(args?: SelectSubset<T, AdGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdGroups
     * const adGroup = await prisma.adGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdGroupUpdateManyArgs>(args: SelectSubset<T, AdGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdGroup.
     * @param {AdGroupUpsertArgs} args - Arguments to update or create a AdGroup.
     * @example
     * // Update or create a AdGroup
     * const adGroup = await prisma.adGroup.upsert({
     *   create: {
     *     // ... data to create a AdGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdGroup we want to update
     *   }
     * })
     */
    upsert<T extends AdGroupUpsertArgs>(args: SelectSubset<T, AdGroupUpsertArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupCountArgs} args - Arguments to filter AdGroups to count.
     * @example
     * // Count the number of AdGroups
     * const count = await prisma.adGroup.count({
     *   where: {
     *     // ... the filter for the AdGroups we want to count
     *   }
     * })
    **/
    count<T extends AdGroupCountArgs>(
      args?: Subset<T, AdGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdGroupAggregateArgs>(args: Subset<T, AdGroupAggregateArgs>): Prisma.PrismaPromise<GetAdGroupAggregateType<T>>

    /**
     * Group by AdGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdGroupGroupByArgs['orderBy'] }
        : { orderBy?: AdGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdGroup model
   */
  readonly fields: AdGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ad_account<T extends AdGroup$ad_accountArgs<ExtArgs> = {}>(args?: Subset<T, AdGroup$ad_accountArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ads<T extends AdGroup$adsArgs<ExtArgs> = {}>(args?: Subset<T, AdGroup$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdGroup model
   */ 
  interface AdGroupFieldRefs {
    readonly id: FieldRef<"AdGroup", 'String'>
    readonly name: FieldRef<"AdGroup", 'String'>
    readonly external_id: FieldRef<"AdGroup", 'String'>
    readonly status: FieldRef<"AdGroup", 'String'>
    readonly campaign_id: FieldRef<"AdGroup", 'String'>
    readonly ad_account_id: FieldRef<"AdGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdGroup findUnique
   */
  export type AdGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * Filter, which AdGroup to fetch.
     */
    where: AdGroupWhereUniqueInput
  }

  /**
   * AdGroup findUniqueOrThrow
   */
  export type AdGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * Filter, which AdGroup to fetch.
     */
    where: AdGroupWhereUniqueInput
  }

  /**
   * AdGroup findFirst
   */
  export type AdGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * Filter, which AdGroup to fetch.
     */
    where?: AdGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdGroups to fetch.
     */
    orderBy?: AdGroupOrderByWithRelationInput | AdGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdGroups.
     */
    cursor?: AdGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdGroups.
     */
    distinct?: AdGroupScalarFieldEnum | AdGroupScalarFieldEnum[]
  }

  /**
   * AdGroup findFirstOrThrow
   */
  export type AdGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * Filter, which AdGroup to fetch.
     */
    where?: AdGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdGroups to fetch.
     */
    orderBy?: AdGroupOrderByWithRelationInput | AdGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdGroups.
     */
    cursor?: AdGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdGroups.
     */
    distinct?: AdGroupScalarFieldEnum | AdGroupScalarFieldEnum[]
  }

  /**
   * AdGroup findMany
   */
  export type AdGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * Filter, which AdGroups to fetch.
     */
    where?: AdGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdGroups to fetch.
     */
    orderBy?: AdGroupOrderByWithRelationInput | AdGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdGroups.
     */
    cursor?: AdGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdGroups.
     */
    skip?: number
    distinct?: AdGroupScalarFieldEnum | AdGroupScalarFieldEnum[]
  }

  /**
   * AdGroup create
   */
  export type AdGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a AdGroup.
     */
    data: XOR<AdGroupCreateInput, AdGroupUncheckedCreateInput>
  }

  /**
   * AdGroup createMany
   */
  export type AdGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdGroups.
     */
    data: AdGroupCreateManyInput | AdGroupCreateManyInput[]
  }

  /**
   * AdGroup createManyAndReturn
   */
  export type AdGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdGroups.
     */
    data: AdGroupCreateManyInput | AdGroupCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdGroup update
   */
  export type AdGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a AdGroup.
     */
    data: XOR<AdGroupUpdateInput, AdGroupUncheckedUpdateInput>
    /**
     * Choose, which AdGroup to update.
     */
    where: AdGroupWhereUniqueInput
  }

  /**
   * AdGroup updateMany
   */
  export type AdGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdGroups.
     */
    data: XOR<AdGroupUpdateManyMutationInput, AdGroupUncheckedUpdateManyInput>
    /**
     * Filter which AdGroups to update
     */
    where?: AdGroupWhereInput
  }

  /**
   * AdGroup upsert
   */
  export type AdGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the AdGroup to update in case it exists.
     */
    where: AdGroupWhereUniqueInput
    /**
     * In case the AdGroup found by the `where` argument doesn't exist, create a new AdGroup with this data.
     */
    create: XOR<AdGroupCreateInput, AdGroupUncheckedCreateInput>
    /**
     * In case the AdGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdGroupUpdateInput, AdGroupUncheckedUpdateInput>
  }

  /**
   * AdGroup delete
   */
  export type AdGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
    /**
     * Filter which AdGroup to delete.
     */
    where: AdGroupWhereUniqueInput
  }

  /**
   * AdGroup deleteMany
   */
  export type AdGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdGroups to delete
     */
    where?: AdGroupWhereInput
  }

  /**
   * AdGroup.ad_account
   */
  export type AdGroup$ad_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    where?: AdAccountWhereInput
  }

  /**
   * AdGroup.ads
   */
  export type AdGroup$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * AdGroup without action
   */
  export type AdGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdGroup
     */
    select?: AdGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdGroupInclude<ExtArgs> | null
  }


  /**
   * Model Ad
   */

  export type AggregateAd = {
    _count: AdCountAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  export type AdMinAggregateOutputType = {
    id: string | null
    name: string | null
    external_id: string | null
    status: string | null
    type: string | null
    ad_group_id: string | null
    creative_id: string | null
  }

  export type AdMaxAggregateOutputType = {
    id: string | null
    name: string | null
    external_id: string | null
    status: string | null
    type: string | null
    ad_group_id: string | null
    creative_id: string | null
  }

  export type AdCountAggregateOutputType = {
    id: number
    name: number
    external_id: number
    status: number
    type: number
    ad_group_id: number
    creative_id: number
    _all: number
  }


  export type AdMinAggregateInputType = {
    id?: true
    name?: true
    external_id?: true
    status?: true
    type?: true
    ad_group_id?: true
    creative_id?: true
  }

  export type AdMaxAggregateInputType = {
    id?: true
    name?: true
    external_id?: true
    status?: true
    type?: true
    ad_group_id?: true
    creative_id?: true
  }

  export type AdCountAggregateInputType = {
    id?: true
    name?: true
    external_id?: true
    status?: true
    type?: true
    ad_group_id?: true
    creative_id?: true
    _all?: true
  }

  export type AdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ad to aggregate.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ads
    **/
    _count?: true | AdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdMaxAggregateInputType
  }

  export type GetAdAggregateType<T extends AdAggregateArgs> = {
        [P in keyof T & keyof AggregateAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAd[P]>
      : GetScalarType<T[P], AggregateAd[P]>
  }




  export type AdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
    orderBy?: AdOrderByWithAggregationInput | AdOrderByWithAggregationInput[]
    by: AdScalarFieldEnum[] | AdScalarFieldEnum
    having?: AdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdCountAggregateInputType | true
    _min?: AdMinAggregateInputType
    _max?: AdMaxAggregateInputType
  }

  export type AdGroupByOutputType = {
    id: string
    name: string
    external_id: string | null
    status: string
    type: string | null
    ad_group_id: string
    creative_id: string | null
    _count: AdCountAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  type GetAdGroupByPayload<T extends AdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdGroupByOutputType[P]>
            : GetScalarType<T[P], AdGroupByOutputType[P]>
        }
      >
    >


  export type AdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    external_id?: boolean
    status?: boolean
    type?: boolean
    ad_group_id?: boolean
    creative_id?: boolean
    ad_group?: boolean | AdGroupDefaultArgs<ExtArgs>
    creative?: boolean | Ad$creativeArgs<ExtArgs>
    snapshots?: boolean | Ad$snapshotsArgs<ExtArgs>
    _count?: boolean | AdCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    external_id?: boolean
    status?: boolean
    type?: boolean
    ad_group_id?: boolean
    creative_id?: boolean
    ad_group?: boolean | AdGroupDefaultArgs<ExtArgs>
    creative?: boolean | Ad$creativeArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectScalar = {
    id?: boolean
    name?: boolean
    external_id?: boolean
    status?: boolean
    type?: boolean
    ad_group_id?: boolean
    creative_id?: boolean
  }

  export type AdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad_group?: boolean | AdGroupDefaultArgs<ExtArgs>
    creative?: boolean | Ad$creativeArgs<ExtArgs>
    snapshots?: boolean | Ad$snapshotsArgs<ExtArgs>
    _count?: boolean | AdCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad_group?: boolean | AdGroupDefaultArgs<ExtArgs>
    creative?: boolean | Ad$creativeArgs<ExtArgs>
  }

  export type $AdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ad"
    objects: {
      ad_group: Prisma.$AdGroupPayload<ExtArgs>
      creative: Prisma.$AssetPayload<ExtArgs> | null
      snapshots: Prisma.$SpendSnapshotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      external_id: string | null
      status: string
      type: string | null
      ad_group_id: string
      creative_id: string | null
    }, ExtArgs["result"]["ad"]>
    composites: {}
  }

  type AdGetPayload<S extends boolean | null | undefined | AdDefaultArgs> = $Result.GetResult<Prisma.$AdPayload, S>

  type AdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdCountAggregateInputType | true
    }

  export interface AdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ad'], meta: { name: 'Ad' } }
    /**
     * Find zero or one Ad that matches the filter.
     * @param {AdFindUniqueArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdFindUniqueArgs>(args: SelectSubset<T, AdFindUniqueArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ad that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdFindUniqueOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdFindUniqueOrThrowArgs>(args: SelectSubset<T, AdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdFindFirstArgs>(args?: SelectSubset<T, AdFindFirstArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdFindFirstOrThrowArgs>(args?: SelectSubset<T, AdFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ads
     * const ads = await prisma.ad.findMany()
     * 
     * // Get first 10 Ads
     * const ads = await prisma.ad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adWithIdOnly = await prisma.ad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdFindManyArgs>(args?: SelectSubset<T, AdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ad.
     * @param {AdCreateArgs} args - Arguments to create a Ad.
     * @example
     * // Create one Ad
     * const Ad = await prisma.ad.create({
     *   data: {
     *     // ... data to create a Ad
     *   }
     * })
     * 
     */
    create<T extends AdCreateArgs>(args: SelectSubset<T, AdCreateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ads.
     * @param {AdCreateManyArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdCreateManyArgs>(args?: SelectSubset<T, AdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ads and returns the data saved in the database.
     * @param {AdCreateManyAndReturnArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdCreateManyAndReturnArgs>(args?: SelectSubset<T, AdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ad.
     * @param {AdDeleteArgs} args - Arguments to delete one Ad.
     * @example
     * // Delete one Ad
     * const Ad = await prisma.ad.delete({
     *   where: {
     *     // ... filter to delete one Ad
     *   }
     * })
     * 
     */
    delete<T extends AdDeleteArgs>(args: SelectSubset<T, AdDeleteArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ad.
     * @param {AdUpdateArgs} args - Arguments to update one Ad.
     * @example
     * // Update one Ad
     * const ad = await prisma.ad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdUpdateArgs>(args: SelectSubset<T, AdUpdateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ads.
     * @param {AdDeleteManyArgs} args - Arguments to filter Ads to delete.
     * @example
     * // Delete a few Ads
     * const { count } = await prisma.ad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdDeleteManyArgs>(args?: SelectSubset<T, AdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdUpdateManyArgs>(args: SelectSubset<T, AdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ad.
     * @param {AdUpsertArgs} args - Arguments to update or create a Ad.
     * @example
     * // Update or create a Ad
     * const ad = await prisma.ad.upsert({
     *   create: {
     *     // ... data to create a Ad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ad we want to update
     *   }
     * })
     */
    upsert<T extends AdUpsertArgs>(args: SelectSubset<T, AdUpsertArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCountArgs} args - Arguments to filter Ads to count.
     * @example
     * // Count the number of Ads
     * const count = await prisma.ad.count({
     *   where: {
     *     // ... the filter for the Ads we want to count
     *   }
     * })
    **/
    count<T extends AdCountArgs>(
      args?: Subset<T, AdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAggregateArgs>(args: Subset<T, AdAggregateArgs>): Prisma.PrismaPromise<GetAdAggregateType<T>>

    /**
     * Group by Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdGroupByArgs['orderBy'] }
        : { orderBy?: AdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ad model
   */
  readonly fields: AdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ad_group<T extends AdGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdGroupDefaultArgs<ExtArgs>>): Prisma__AdGroupClient<$Result.GetResult<Prisma.$AdGroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creative<T extends Ad$creativeArgs<ExtArgs> = {}>(args?: Subset<T, Ad$creativeArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    snapshots<T extends Ad$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Ad$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ad model
   */ 
  interface AdFieldRefs {
    readonly id: FieldRef<"Ad", 'String'>
    readonly name: FieldRef<"Ad", 'String'>
    readonly external_id: FieldRef<"Ad", 'String'>
    readonly status: FieldRef<"Ad", 'String'>
    readonly type: FieldRef<"Ad", 'String'>
    readonly ad_group_id: FieldRef<"Ad", 'String'>
    readonly creative_id: FieldRef<"Ad", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ad findUnique
   */
  export type AdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findUniqueOrThrow
   */
  export type AdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findFirst
   */
  export type AdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findFirstOrThrow
   */
  export type AdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findMany
   */
  export type AdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ads to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad create
   */
  export type AdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to create a Ad.
     */
    data: XOR<AdCreateInput, AdUncheckedCreateInput>
  }

  /**
   * Ad createMany
   */
  export type AdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
  }

  /**
   * Ad createManyAndReturn
   */
  export type AdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ad update
   */
  export type AdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to update a Ad.
     */
    data: XOR<AdUpdateInput, AdUncheckedUpdateInput>
    /**
     * Choose, which Ad to update.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad updateMany
   */
  export type AdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
  }

  /**
   * Ad upsert
   */
  export type AdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The filter to search for the Ad to update in case it exists.
     */
    where: AdWhereUniqueInput
    /**
     * In case the Ad found by the `where` argument doesn't exist, create a new Ad with this data.
     */
    create: XOR<AdCreateInput, AdUncheckedCreateInput>
    /**
     * In case the Ad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdUpdateInput, AdUncheckedUpdateInput>
  }

  /**
   * Ad delete
   */
  export type AdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter which Ad to delete.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad deleteMany
   */
  export type AdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ads to delete
     */
    where?: AdWhereInput
  }

  /**
   * Ad.creative
   */
  export type Ad$creativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
  }

  /**
   * Ad.snapshots
   */
  export type Ad$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    where?: SpendSnapshotWhereInput
    orderBy?: SpendSnapshotOrderByWithRelationInput | SpendSnapshotOrderByWithRelationInput[]
    cursor?: SpendSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendSnapshotScalarFieldEnum | SpendSnapshotScalarFieldEnum[]
  }

  /**
   * Ad without action
   */
  export type AdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
  }


  /**
   * Model SpendSnapshot
   */

  export type AggregateSpendSnapshot = {
    _count: SpendSnapshotCountAggregateOutputType | null
    _avg: SpendSnapshotAvgAggregateOutputType | null
    _sum: SpendSnapshotSumAggregateOutputType | null
    _min: SpendSnapshotMinAggregateOutputType | null
    _max: SpendSnapshotMaxAggregateOutputType | null
  }

  export type SpendSnapshotAvgAggregateOutputType = {
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
  }

  export type SpendSnapshotSumAggregateOutputType = {
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
  }

  export type SpendSnapshotMinAggregateOutputType = {
    id: string | null
    date: Date | null
    ad_id: string | null
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
    platform_data: string | null
    createdAt: Date | null
  }

  export type SpendSnapshotMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    ad_id: string | null
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
    platform_data: string | null
    createdAt: Date | null
  }

  export type SpendSnapshotCountAggregateOutputType = {
    id: number
    date: number
    ad_id: number
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
    platform_data: number
    createdAt: number
    _all: number
  }


  export type SpendSnapshotAvgAggregateInputType = {
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
  }

  export type SpendSnapshotSumAggregateInputType = {
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
  }

  export type SpendSnapshotMinAggregateInputType = {
    id?: true
    date?: true
    ad_id?: true
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
    platform_data?: true
    createdAt?: true
  }

  export type SpendSnapshotMaxAggregateInputType = {
    id?: true
    date?: true
    ad_id?: true
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
    platform_data?: true
    createdAt?: true
  }

  export type SpendSnapshotCountAggregateInputType = {
    id?: true
    date?: true
    ad_id?: true
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
    platform_data?: true
    createdAt?: true
    _all?: true
  }

  export type SpendSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendSnapshot to aggregate.
     */
    where?: SpendSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendSnapshots to fetch.
     */
    orderBy?: SpendSnapshotOrderByWithRelationInput | SpendSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpendSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpendSnapshots
    **/
    _count?: true | SpendSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpendSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpendSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpendSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpendSnapshotMaxAggregateInputType
  }

  export type GetSpendSnapshotAggregateType<T extends SpendSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateSpendSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpendSnapshot[P]>
      : GetScalarType<T[P], AggregateSpendSnapshot[P]>
  }




  export type SpendSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendSnapshotWhereInput
    orderBy?: SpendSnapshotOrderByWithAggregationInput | SpendSnapshotOrderByWithAggregationInput[]
    by: SpendSnapshotScalarFieldEnum[] | SpendSnapshotScalarFieldEnum
    having?: SpendSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpendSnapshotCountAggregateInputType | true
    _avg?: SpendSnapshotAvgAggregateInputType
    _sum?: SpendSnapshotSumAggregateInputType
    _min?: SpendSnapshotMinAggregateInputType
    _max?: SpendSnapshotMaxAggregateInputType
  }

  export type SpendSnapshotGroupByOutputType = {
    id: string
    date: Date
    ad_id: string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
    platform_data: string | null
    createdAt: Date
    _count: SpendSnapshotCountAggregateOutputType | null
    _avg: SpendSnapshotAvgAggregateOutputType | null
    _sum: SpendSnapshotSumAggregateOutputType | null
    _min: SpendSnapshotMinAggregateOutputType | null
    _max: SpendSnapshotMaxAggregateOutputType | null
  }

  type GetSpendSnapshotGroupByPayload<T extends SpendSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpendSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpendSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpendSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], SpendSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type SpendSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    ad_id?: boolean
    spend?: boolean
    impressions?: boolean
    clicks?: boolean
    conversions?: boolean
    revenue?: boolean
    platform_data?: boolean
    createdAt?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendSnapshot"]>

  export type SpendSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    ad_id?: boolean
    spend?: boolean
    impressions?: boolean
    clicks?: boolean
    conversions?: boolean
    revenue?: boolean
    platform_data?: boolean
    createdAt?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendSnapshot"]>

  export type SpendSnapshotSelectScalar = {
    id?: boolean
    date?: boolean
    ad_id?: boolean
    spend?: boolean
    impressions?: boolean
    clicks?: boolean
    conversions?: boolean
    revenue?: boolean
    platform_data?: boolean
    createdAt?: boolean
  }

  export type SpendSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }
  export type SpendSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }

  export type $SpendSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpendSnapshot"
    objects: {
      ad: Prisma.$AdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      ad_id: string
      spend: number
      impressions: number
      clicks: number
      conversions: number
      revenue: number
      platform_data: string | null
      createdAt: Date
    }, ExtArgs["result"]["spendSnapshot"]>
    composites: {}
  }

  type SpendSnapshotGetPayload<S extends boolean | null | undefined | SpendSnapshotDefaultArgs> = $Result.GetResult<Prisma.$SpendSnapshotPayload, S>

  type SpendSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpendSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpendSnapshotCountAggregateInputType | true
    }

  export interface SpendSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpendSnapshot'], meta: { name: 'SpendSnapshot' } }
    /**
     * Find zero or one SpendSnapshot that matches the filter.
     * @param {SpendSnapshotFindUniqueArgs} args - Arguments to find a SpendSnapshot
     * @example
     * // Get one SpendSnapshot
     * const spendSnapshot = await prisma.spendSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpendSnapshotFindUniqueArgs>(args: SelectSubset<T, SpendSnapshotFindUniqueArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpendSnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpendSnapshotFindUniqueOrThrowArgs} args - Arguments to find a SpendSnapshot
     * @example
     * // Get one SpendSnapshot
     * const spendSnapshot = await prisma.spendSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpendSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, SpendSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpendSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotFindFirstArgs} args - Arguments to find a SpendSnapshot
     * @example
     * // Get one SpendSnapshot
     * const spendSnapshot = await prisma.spendSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpendSnapshotFindFirstArgs>(args?: SelectSubset<T, SpendSnapshotFindFirstArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpendSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotFindFirstOrThrowArgs} args - Arguments to find a SpendSnapshot
     * @example
     * // Get one SpendSnapshot
     * const spendSnapshot = await prisma.spendSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpendSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, SpendSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpendSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpendSnapshots
     * const spendSnapshots = await prisma.spendSnapshot.findMany()
     * 
     * // Get first 10 SpendSnapshots
     * const spendSnapshots = await prisma.spendSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spendSnapshotWithIdOnly = await prisma.spendSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpendSnapshotFindManyArgs>(args?: SelectSubset<T, SpendSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpendSnapshot.
     * @param {SpendSnapshotCreateArgs} args - Arguments to create a SpendSnapshot.
     * @example
     * // Create one SpendSnapshot
     * const SpendSnapshot = await prisma.spendSnapshot.create({
     *   data: {
     *     // ... data to create a SpendSnapshot
     *   }
     * })
     * 
     */
    create<T extends SpendSnapshotCreateArgs>(args: SelectSubset<T, SpendSnapshotCreateArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpendSnapshots.
     * @param {SpendSnapshotCreateManyArgs} args - Arguments to create many SpendSnapshots.
     * @example
     * // Create many SpendSnapshots
     * const spendSnapshot = await prisma.spendSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpendSnapshotCreateManyArgs>(args?: SelectSubset<T, SpendSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpendSnapshots and returns the data saved in the database.
     * @param {SpendSnapshotCreateManyAndReturnArgs} args - Arguments to create many SpendSnapshots.
     * @example
     * // Create many SpendSnapshots
     * const spendSnapshot = await prisma.spendSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpendSnapshots and only return the `id`
     * const spendSnapshotWithIdOnly = await prisma.spendSnapshot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpendSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, SpendSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpendSnapshot.
     * @param {SpendSnapshotDeleteArgs} args - Arguments to delete one SpendSnapshot.
     * @example
     * // Delete one SpendSnapshot
     * const SpendSnapshot = await prisma.spendSnapshot.delete({
     *   where: {
     *     // ... filter to delete one SpendSnapshot
     *   }
     * })
     * 
     */
    delete<T extends SpendSnapshotDeleteArgs>(args: SelectSubset<T, SpendSnapshotDeleteArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpendSnapshot.
     * @param {SpendSnapshotUpdateArgs} args - Arguments to update one SpendSnapshot.
     * @example
     * // Update one SpendSnapshot
     * const spendSnapshot = await prisma.spendSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpendSnapshotUpdateArgs>(args: SelectSubset<T, SpendSnapshotUpdateArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpendSnapshots.
     * @param {SpendSnapshotDeleteManyArgs} args - Arguments to filter SpendSnapshots to delete.
     * @example
     * // Delete a few SpendSnapshots
     * const { count } = await prisma.spendSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpendSnapshotDeleteManyArgs>(args?: SelectSubset<T, SpendSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpendSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpendSnapshots
     * const spendSnapshot = await prisma.spendSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpendSnapshotUpdateManyArgs>(args: SelectSubset<T, SpendSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpendSnapshot.
     * @param {SpendSnapshotUpsertArgs} args - Arguments to update or create a SpendSnapshot.
     * @example
     * // Update or create a SpendSnapshot
     * const spendSnapshot = await prisma.spendSnapshot.upsert({
     *   create: {
     *     // ... data to create a SpendSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpendSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends SpendSnapshotUpsertArgs>(args: SelectSubset<T, SpendSnapshotUpsertArgs<ExtArgs>>): Prisma__SpendSnapshotClient<$Result.GetResult<Prisma.$SpendSnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpendSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotCountArgs} args - Arguments to filter SpendSnapshots to count.
     * @example
     * // Count the number of SpendSnapshots
     * const count = await prisma.spendSnapshot.count({
     *   where: {
     *     // ... the filter for the SpendSnapshots we want to count
     *   }
     * })
    **/
    count<T extends SpendSnapshotCountArgs>(
      args?: Subset<T, SpendSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpendSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpendSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpendSnapshotAggregateArgs>(args: Subset<T, SpendSnapshotAggregateArgs>): Prisma.PrismaPromise<GetSpendSnapshotAggregateType<T>>

    /**
     * Group by SpendSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpendSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpendSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: SpendSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpendSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpendSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpendSnapshot model
   */
  readonly fields: SpendSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpendSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpendSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ad<T extends AdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdDefaultArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpendSnapshot model
   */ 
  interface SpendSnapshotFieldRefs {
    readonly id: FieldRef<"SpendSnapshot", 'String'>
    readonly date: FieldRef<"SpendSnapshot", 'DateTime'>
    readonly ad_id: FieldRef<"SpendSnapshot", 'String'>
    readonly spend: FieldRef<"SpendSnapshot", 'Float'>
    readonly impressions: FieldRef<"SpendSnapshot", 'Int'>
    readonly clicks: FieldRef<"SpendSnapshot", 'Int'>
    readonly conversions: FieldRef<"SpendSnapshot", 'Int'>
    readonly revenue: FieldRef<"SpendSnapshot", 'Float'>
    readonly platform_data: FieldRef<"SpendSnapshot", 'String'>
    readonly createdAt: FieldRef<"SpendSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpendSnapshot findUnique
   */
  export type SpendSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendSnapshot to fetch.
     */
    where: SpendSnapshotWhereUniqueInput
  }

  /**
   * SpendSnapshot findUniqueOrThrow
   */
  export type SpendSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendSnapshot to fetch.
     */
    where: SpendSnapshotWhereUniqueInput
  }

  /**
   * SpendSnapshot findFirst
   */
  export type SpendSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendSnapshot to fetch.
     */
    where?: SpendSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendSnapshots to fetch.
     */
    orderBy?: SpendSnapshotOrderByWithRelationInput | SpendSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendSnapshots.
     */
    cursor?: SpendSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendSnapshots.
     */
    distinct?: SpendSnapshotScalarFieldEnum | SpendSnapshotScalarFieldEnum[]
  }

  /**
   * SpendSnapshot findFirstOrThrow
   */
  export type SpendSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendSnapshot to fetch.
     */
    where?: SpendSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendSnapshots to fetch.
     */
    orderBy?: SpendSnapshotOrderByWithRelationInput | SpendSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendSnapshots.
     */
    cursor?: SpendSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendSnapshots.
     */
    distinct?: SpendSnapshotScalarFieldEnum | SpendSnapshotScalarFieldEnum[]
  }

  /**
   * SpendSnapshot findMany
   */
  export type SpendSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendSnapshots to fetch.
     */
    where?: SpendSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendSnapshots to fetch.
     */
    orderBy?: SpendSnapshotOrderByWithRelationInput | SpendSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpendSnapshots.
     */
    cursor?: SpendSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendSnapshots.
     */
    skip?: number
    distinct?: SpendSnapshotScalarFieldEnum | SpendSnapshotScalarFieldEnum[]
  }

  /**
   * SpendSnapshot create
   */
  export type SpendSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a SpendSnapshot.
     */
    data: XOR<SpendSnapshotCreateInput, SpendSnapshotUncheckedCreateInput>
  }

  /**
   * SpendSnapshot createMany
   */
  export type SpendSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpendSnapshots.
     */
    data: SpendSnapshotCreateManyInput | SpendSnapshotCreateManyInput[]
  }

  /**
   * SpendSnapshot createManyAndReturn
   */
  export type SpendSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpendSnapshots.
     */
    data: SpendSnapshotCreateManyInput | SpendSnapshotCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpendSnapshot update
   */
  export type SpendSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a SpendSnapshot.
     */
    data: XOR<SpendSnapshotUpdateInput, SpendSnapshotUncheckedUpdateInput>
    /**
     * Choose, which SpendSnapshot to update.
     */
    where: SpendSnapshotWhereUniqueInput
  }

  /**
   * SpendSnapshot updateMany
   */
  export type SpendSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpendSnapshots.
     */
    data: XOR<SpendSnapshotUpdateManyMutationInput, SpendSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which SpendSnapshots to update
     */
    where?: SpendSnapshotWhereInput
  }

  /**
   * SpendSnapshot upsert
   */
  export type SpendSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the SpendSnapshot to update in case it exists.
     */
    where: SpendSnapshotWhereUniqueInput
    /**
     * In case the SpendSnapshot found by the `where` argument doesn't exist, create a new SpendSnapshot with this data.
     */
    create: XOR<SpendSnapshotCreateInput, SpendSnapshotUncheckedCreateInput>
    /**
     * In case the SpendSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpendSnapshotUpdateInput, SpendSnapshotUncheckedUpdateInput>
  }

  /**
   * SpendSnapshot delete
   */
  export type SpendSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
    /**
     * Filter which SpendSnapshot to delete.
     */
    where: SpendSnapshotWhereUniqueInput
  }

  /**
   * SpendSnapshot deleteMany
   */
  export type SpendSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendSnapshots to delete
     */
    where?: SpendSnapshotWhereInput
  }

  /**
   * SpendSnapshot without action
   */
  export type SpendSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendSnapshot
     */
    select?: SpendSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMetric
   */

  export type AggregateCampaignMetric = {
    _count: CampaignMetricCountAggregateOutputType | null
    _avg: CampaignMetricAvgAggregateOutputType | null
    _sum: CampaignMetricSumAggregateOutputType | null
    _min: CampaignMetricMinAggregateOutputType | null
    _max: CampaignMetricMaxAggregateOutputType | null
  }

  export type CampaignMetricAvgAggregateOutputType = {
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
  }

  export type CampaignMetricSumAggregateOutputType = {
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
  }

  export type CampaignMetricMinAggregateOutputType = {
    id: string | null
    date: Date | null
    campaign_id: string | null
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
  }

  export type CampaignMetricMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    campaign_id: string | null
    spend: number | null
    impressions: number | null
    clicks: number | null
    conversions: number | null
    revenue: number | null
  }

  export type CampaignMetricCountAggregateOutputType = {
    id: number
    date: number
    campaign_id: number
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
    _all: number
  }


  export type CampaignMetricAvgAggregateInputType = {
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
  }

  export type CampaignMetricSumAggregateInputType = {
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
  }

  export type CampaignMetricMinAggregateInputType = {
    id?: true
    date?: true
    campaign_id?: true
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
  }

  export type CampaignMetricMaxAggregateInputType = {
    id?: true
    date?: true
    campaign_id?: true
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
  }

  export type CampaignMetricCountAggregateInputType = {
    id?: true
    date?: true
    campaign_id?: true
    spend?: true
    impressions?: true
    clicks?: true
    conversions?: true
    revenue?: true
    _all?: true
  }

  export type CampaignMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMetric to aggregate.
     */
    where?: CampaignMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricOrderByWithRelationInput | CampaignMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMetrics
    **/
    _count?: true | CampaignMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMetricMaxAggregateInputType
  }

  export type GetCampaignMetricAggregateType<T extends CampaignMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMetric[P]>
      : GetScalarType<T[P], AggregateCampaignMetric[P]>
  }




  export type CampaignMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMetricWhereInput
    orderBy?: CampaignMetricOrderByWithAggregationInput | CampaignMetricOrderByWithAggregationInput[]
    by: CampaignMetricScalarFieldEnum[] | CampaignMetricScalarFieldEnum
    having?: CampaignMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMetricCountAggregateInputType | true
    _avg?: CampaignMetricAvgAggregateInputType
    _sum?: CampaignMetricSumAggregateInputType
    _min?: CampaignMetricMinAggregateInputType
    _max?: CampaignMetricMaxAggregateInputType
  }

  export type CampaignMetricGroupByOutputType = {
    id: string
    date: Date
    campaign_id: string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
    _count: CampaignMetricCountAggregateOutputType | null
    _avg: CampaignMetricAvgAggregateOutputType | null
    _sum: CampaignMetricSumAggregateOutputType | null
    _min: CampaignMetricMinAggregateOutputType | null
    _max: CampaignMetricMaxAggregateOutputType | null
  }

  type GetCampaignMetricGroupByPayload<T extends CampaignMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMetricGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMetricGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    campaign_id?: boolean
    spend?: boolean
    impressions?: boolean
    clicks?: boolean
    conversions?: boolean
    revenue?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetric"]>

  export type CampaignMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    campaign_id?: boolean
    spend?: boolean
    impressions?: boolean
    clicks?: boolean
    conversions?: boolean
    revenue?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetric"]>

  export type CampaignMetricSelectScalar = {
    id?: boolean
    date?: boolean
    campaign_id?: boolean
    spend?: boolean
    impressions?: boolean
    clicks?: boolean
    conversions?: boolean
    revenue?: boolean
  }

  export type CampaignMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMetric"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      campaign_id: string
      spend: number
      impressions: number
      clicks: number
      conversions: number
      revenue: number
    }, ExtArgs["result"]["campaignMetric"]>
    composites: {}
  }

  type CampaignMetricGetPayload<S extends boolean | null | undefined | CampaignMetricDefaultArgs> = $Result.GetResult<Prisma.$CampaignMetricPayload, S>

  type CampaignMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignMetricCountAggregateInputType | true
    }

  export interface CampaignMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMetric'], meta: { name: 'CampaignMetric' } }
    /**
     * Find zero or one CampaignMetric that matches the filter.
     * @param {CampaignMetricFindUniqueArgs} args - Arguments to find a CampaignMetric
     * @example
     * // Get one CampaignMetric
     * const campaignMetric = await prisma.campaignMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMetricFindUniqueArgs>(args: SelectSubset<T, CampaignMetricFindUniqueArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignMetricFindUniqueOrThrowArgs} args - Arguments to find a CampaignMetric
     * @example
     * // Get one CampaignMetric
     * const campaignMetric = await prisma.campaignMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricFindFirstArgs} args - Arguments to find a CampaignMetric
     * @example
     * // Get one CampaignMetric
     * const campaignMetric = await prisma.campaignMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMetricFindFirstArgs>(args?: SelectSubset<T, CampaignMetricFindFirstArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricFindFirstOrThrowArgs} args - Arguments to find a CampaignMetric
     * @example
     * // Get one CampaignMetric
     * const campaignMetric = await prisma.campaignMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetric.findMany()
     * 
     * // Get first 10 CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignMetricWithIdOnly = await prisma.campaignMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignMetricFindManyArgs>(args?: SelectSubset<T, CampaignMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignMetric.
     * @param {CampaignMetricCreateArgs} args - Arguments to create a CampaignMetric.
     * @example
     * // Create one CampaignMetric
     * const CampaignMetric = await prisma.campaignMetric.create({
     *   data: {
     *     // ... data to create a CampaignMetric
     *   }
     * })
     * 
     */
    create<T extends CampaignMetricCreateArgs>(args: SelectSubset<T, CampaignMetricCreateArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignMetrics.
     * @param {CampaignMetricCreateManyArgs} args - Arguments to create many CampaignMetrics.
     * @example
     * // Create many CampaignMetrics
     * const campaignMetric = await prisma.campaignMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMetricCreateManyArgs>(args?: SelectSubset<T, CampaignMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMetrics and returns the data saved in the database.
     * @param {CampaignMetricCreateManyAndReturnArgs} args - Arguments to create many CampaignMetrics.
     * @example
     * // Create many CampaignMetrics
     * const campaignMetric = await prisma.campaignMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMetrics and only return the `id`
     * const campaignMetricWithIdOnly = await prisma.campaignMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignMetric.
     * @param {CampaignMetricDeleteArgs} args - Arguments to delete one CampaignMetric.
     * @example
     * // Delete one CampaignMetric
     * const CampaignMetric = await prisma.campaignMetric.delete({
     *   where: {
     *     // ... filter to delete one CampaignMetric
     *   }
     * })
     * 
     */
    delete<T extends CampaignMetricDeleteArgs>(args: SelectSubset<T, CampaignMetricDeleteArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignMetric.
     * @param {CampaignMetricUpdateArgs} args - Arguments to update one CampaignMetric.
     * @example
     * // Update one CampaignMetric
     * const campaignMetric = await prisma.campaignMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMetricUpdateArgs>(args: SelectSubset<T, CampaignMetricUpdateArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignMetrics.
     * @param {CampaignMetricDeleteManyArgs} args - Arguments to filter CampaignMetrics to delete.
     * @example
     * // Delete a few CampaignMetrics
     * const { count } = await prisma.campaignMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMetricDeleteManyArgs>(args?: SelectSubset<T, CampaignMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMetrics
     * const campaignMetric = await prisma.campaignMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMetricUpdateManyArgs>(args: SelectSubset<T, CampaignMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignMetric.
     * @param {CampaignMetricUpsertArgs} args - Arguments to update or create a CampaignMetric.
     * @example
     * // Update or create a CampaignMetric
     * const campaignMetric = await prisma.campaignMetric.upsert({
     *   create: {
     *     // ... data to create a CampaignMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMetric we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMetricUpsertArgs>(args: SelectSubset<T, CampaignMetricUpsertArgs<ExtArgs>>): Prisma__CampaignMetricClient<$Result.GetResult<Prisma.$CampaignMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricCountArgs} args - Arguments to filter CampaignMetrics to count.
     * @example
     * // Count the number of CampaignMetrics
     * const count = await prisma.campaignMetric.count({
     *   where: {
     *     // ... the filter for the CampaignMetrics we want to count
     *   }
     * })
    **/
    count<T extends CampaignMetricCountArgs>(
      args?: Subset<T, CampaignMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMetricAggregateArgs>(args: Subset<T, CampaignMetricAggregateArgs>): Prisma.PrismaPromise<GetCampaignMetricAggregateType<T>>

    /**
     * Group by CampaignMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMetricGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMetric model
   */
  readonly fields: CampaignMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMetric model
   */ 
  interface CampaignMetricFieldRefs {
    readonly id: FieldRef<"CampaignMetric", 'String'>
    readonly date: FieldRef<"CampaignMetric", 'DateTime'>
    readonly campaign_id: FieldRef<"CampaignMetric", 'String'>
    readonly spend: FieldRef<"CampaignMetric", 'Float'>
    readonly impressions: FieldRef<"CampaignMetric", 'Int'>
    readonly clicks: FieldRef<"CampaignMetric", 'Int'>
    readonly conversions: FieldRef<"CampaignMetric", 'Int'>
    readonly revenue: FieldRef<"CampaignMetric", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMetric findUnique
   */
  export type CampaignMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetric to fetch.
     */
    where: CampaignMetricWhereUniqueInput
  }

  /**
   * CampaignMetric findUniqueOrThrow
   */
  export type CampaignMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetric to fetch.
     */
    where: CampaignMetricWhereUniqueInput
  }

  /**
   * CampaignMetric findFirst
   */
  export type CampaignMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetric to fetch.
     */
    where?: CampaignMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricOrderByWithRelationInput | CampaignMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMetrics.
     */
    cursor?: CampaignMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMetrics.
     */
    distinct?: CampaignMetricScalarFieldEnum | CampaignMetricScalarFieldEnum[]
  }

  /**
   * CampaignMetric findFirstOrThrow
   */
  export type CampaignMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetric to fetch.
     */
    where?: CampaignMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricOrderByWithRelationInput | CampaignMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMetrics.
     */
    cursor?: CampaignMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMetrics.
     */
    distinct?: CampaignMetricScalarFieldEnum | CampaignMetricScalarFieldEnum[]
  }

  /**
   * CampaignMetric findMany
   */
  export type CampaignMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricOrderByWithRelationInput | CampaignMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMetrics.
     */
    cursor?: CampaignMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    distinct?: CampaignMetricScalarFieldEnum | CampaignMetricScalarFieldEnum[]
  }

  /**
   * CampaignMetric create
   */
  export type CampaignMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMetric.
     */
    data: XOR<CampaignMetricCreateInput, CampaignMetricUncheckedCreateInput>
  }

  /**
   * CampaignMetric createMany
   */
  export type CampaignMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMetrics.
     */
    data: CampaignMetricCreateManyInput | CampaignMetricCreateManyInput[]
  }

  /**
   * CampaignMetric createManyAndReturn
   */
  export type CampaignMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignMetrics.
     */
    data: CampaignMetricCreateManyInput | CampaignMetricCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMetric update
   */
  export type CampaignMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMetric.
     */
    data: XOR<CampaignMetricUpdateInput, CampaignMetricUncheckedUpdateInput>
    /**
     * Choose, which CampaignMetric to update.
     */
    where: CampaignMetricWhereUniqueInput
  }

  /**
   * CampaignMetric updateMany
   */
  export type CampaignMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMetrics.
     */
    data: XOR<CampaignMetricUpdateManyMutationInput, CampaignMetricUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMetrics to update
     */
    where?: CampaignMetricWhereInput
  }

  /**
   * CampaignMetric upsert
   */
  export type CampaignMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMetric to update in case it exists.
     */
    where: CampaignMetricWhereUniqueInput
    /**
     * In case the CampaignMetric found by the `where` argument doesn't exist, create a new CampaignMetric with this data.
     */
    create: XOR<CampaignMetricCreateInput, CampaignMetricUncheckedCreateInput>
    /**
     * In case the CampaignMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMetricUpdateInput, CampaignMetricUncheckedUpdateInput>
  }

  /**
   * CampaignMetric delete
   */
  export type CampaignMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
    /**
     * Filter which CampaignMetric to delete.
     */
    where: CampaignMetricWhereUniqueInput
  }

  /**
   * CampaignMetric deleteMany
   */
  export type CampaignMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMetrics to delete
     */
    where?: CampaignMetricWhereInput
  }

  /**
   * CampaignMetric without action
   */
  export type CampaignMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetric
     */
    select?: CampaignMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entity_id: string | null
    user_id: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entity: string | null
    entity_id: string | null
    user_id: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entity: number
    entity_id: number
    user_id: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entity_id?: true
    user_id?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entity_id?: true
    user_id?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entity?: true
    entity_id?: true
    user_id?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entity: string
    entity_id: string
    user_id: string
    details: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    entity_id?: boolean
    user_id?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entity?: boolean
    entity_id?: boolean
    user_id?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entity?: boolean
    entity_id?: boolean
    user_id?: boolean
    details?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entity: string
      entity_id: string
      user_id: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entity_id: FieldRef<"AuditLog", 'String'>
    readonly user_id: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model AccountHead
   */

  export type AggregateAccountHead = {
    _count: AccountHeadCountAggregateOutputType | null
    _min: AccountHeadMinAggregateOutputType | null
    _max: AccountHeadMaxAggregateOutputType | null
  }

  export type AccountHeadMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: string | null
    is_system: boolean | null
  }

  export type AccountHeadMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: string | null
    is_system: boolean | null
  }

  export type AccountHeadCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    is_system: number
    _all: number
  }


  export type AccountHeadMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    is_system?: true
  }

  export type AccountHeadMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    is_system?: true
  }

  export type AccountHeadCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    is_system?: true
    _all?: true
  }

  export type AccountHeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountHead to aggregate.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountHeads
    **/
    _count?: true | AccountHeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountHeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountHeadMaxAggregateInputType
  }

  export type GetAccountHeadAggregateType<T extends AccountHeadAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountHead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountHead[P]>
      : GetScalarType<T[P], AggregateAccountHead[P]>
  }




  export type AccountHeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountHeadWhereInput
    orderBy?: AccountHeadOrderByWithAggregationInput | AccountHeadOrderByWithAggregationInput[]
    by: AccountHeadScalarFieldEnum[] | AccountHeadScalarFieldEnum
    having?: AccountHeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountHeadCountAggregateInputType | true
    _min?: AccountHeadMinAggregateInputType
    _max?: AccountHeadMaxAggregateInputType
  }

  export type AccountHeadGroupByOutputType = {
    id: string
    code: string
    name: string
    type: string
    is_system: boolean
    _count: AccountHeadCountAggregateOutputType | null
    _min: AccountHeadMinAggregateOutputType | null
    _max: AccountHeadMaxAggregateOutputType | null
  }

  type GetAccountHeadGroupByPayload<T extends AccountHeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountHeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountHeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountHeadGroupByOutputType[P]>
            : GetScalarType<T[P], AccountHeadGroupByOutputType[P]>
        }
      >
    >


  export type AccountHeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    is_system?: boolean
    ledgers?: boolean | AccountHead$ledgersArgs<ExtArgs>
    journalLines?: boolean | AccountHead$journalLinesArgs<ExtArgs>
    _count?: boolean | AccountHeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountHead"]>

  export type AccountHeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    is_system?: boolean
  }, ExtArgs["result"]["accountHead"]>

  export type AccountHeadSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    is_system?: boolean
  }

  export type AccountHeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgers?: boolean | AccountHead$ledgersArgs<ExtArgs>
    journalLines?: boolean | AccountHead$journalLinesArgs<ExtArgs>
    _count?: boolean | AccountHeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountHeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccountHeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountHead"
    objects: {
      ledgers: Prisma.$LedgerPayload<ExtArgs>[]
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      type: string
      is_system: boolean
    }, ExtArgs["result"]["accountHead"]>
    composites: {}
  }

  type AccountHeadGetPayload<S extends boolean | null | undefined | AccountHeadDefaultArgs> = $Result.GetResult<Prisma.$AccountHeadPayload, S>

  type AccountHeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountHeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountHeadCountAggregateInputType | true
    }

  export interface AccountHeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountHead'], meta: { name: 'AccountHead' } }
    /**
     * Find zero or one AccountHead that matches the filter.
     * @param {AccountHeadFindUniqueArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountHeadFindUniqueArgs>(args: SelectSubset<T, AccountHeadFindUniqueArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountHead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountHeadFindUniqueOrThrowArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountHeadFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountHeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountHead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadFindFirstArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountHeadFindFirstArgs>(args?: SelectSubset<T, AccountHeadFindFirstArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountHead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadFindFirstOrThrowArgs} args - Arguments to find a AccountHead
     * @example
     * // Get one AccountHead
     * const accountHead = await prisma.accountHead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountHeadFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountHeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountHeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountHeads
     * const accountHeads = await prisma.accountHead.findMany()
     * 
     * // Get first 10 AccountHeads
     * const accountHeads = await prisma.accountHead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountHeadWithIdOnly = await prisma.accountHead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountHeadFindManyArgs>(args?: SelectSubset<T, AccountHeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountHead.
     * @param {AccountHeadCreateArgs} args - Arguments to create a AccountHead.
     * @example
     * // Create one AccountHead
     * const AccountHead = await prisma.accountHead.create({
     *   data: {
     *     // ... data to create a AccountHead
     *   }
     * })
     * 
     */
    create<T extends AccountHeadCreateArgs>(args: SelectSubset<T, AccountHeadCreateArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountHeads.
     * @param {AccountHeadCreateManyArgs} args - Arguments to create many AccountHeads.
     * @example
     * // Create many AccountHeads
     * const accountHead = await prisma.accountHead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountHeadCreateManyArgs>(args?: SelectSubset<T, AccountHeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountHeads and returns the data saved in the database.
     * @param {AccountHeadCreateManyAndReturnArgs} args - Arguments to create many AccountHeads.
     * @example
     * // Create many AccountHeads
     * const accountHead = await prisma.accountHead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountHeads and only return the `id`
     * const accountHeadWithIdOnly = await prisma.accountHead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountHeadCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountHeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountHead.
     * @param {AccountHeadDeleteArgs} args - Arguments to delete one AccountHead.
     * @example
     * // Delete one AccountHead
     * const AccountHead = await prisma.accountHead.delete({
     *   where: {
     *     // ... filter to delete one AccountHead
     *   }
     * })
     * 
     */
    delete<T extends AccountHeadDeleteArgs>(args: SelectSubset<T, AccountHeadDeleteArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountHead.
     * @param {AccountHeadUpdateArgs} args - Arguments to update one AccountHead.
     * @example
     * // Update one AccountHead
     * const accountHead = await prisma.accountHead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountHeadUpdateArgs>(args: SelectSubset<T, AccountHeadUpdateArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountHeads.
     * @param {AccountHeadDeleteManyArgs} args - Arguments to filter AccountHeads to delete.
     * @example
     * // Delete a few AccountHeads
     * const { count } = await prisma.accountHead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountHeadDeleteManyArgs>(args?: SelectSubset<T, AccountHeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountHeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountHeads
     * const accountHead = await prisma.accountHead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountHeadUpdateManyArgs>(args: SelectSubset<T, AccountHeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountHead.
     * @param {AccountHeadUpsertArgs} args - Arguments to update or create a AccountHead.
     * @example
     * // Update or create a AccountHead
     * const accountHead = await prisma.accountHead.upsert({
     *   create: {
     *     // ... data to create a AccountHead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountHead we want to update
     *   }
     * })
     */
    upsert<T extends AccountHeadUpsertArgs>(args: SelectSubset<T, AccountHeadUpsertArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountHeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadCountArgs} args - Arguments to filter AccountHeads to count.
     * @example
     * // Count the number of AccountHeads
     * const count = await prisma.accountHead.count({
     *   where: {
     *     // ... the filter for the AccountHeads we want to count
     *   }
     * })
    **/
    count<T extends AccountHeadCountArgs>(
      args?: Subset<T, AccountHeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountHeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountHead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountHeadAggregateArgs>(args: Subset<T, AccountHeadAggregateArgs>): Prisma.PrismaPromise<GetAccountHeadAggregateType<T>>

    /**
     * Group by AccountHead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountHeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountHeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountHeadGroupByArgs['orderBy'] }
        : { orderBy?: AccountHeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountHeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountHeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountHead model
   */
  readonly fields: AccountHeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountHead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountHeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ledgers<T extends AccountHead$ledgersArgs<ExtArgs> = {}>(args?: Subset<T, AccountHead$ledgersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findMany"> | Null>
    journalLines<T extends AccountHead$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, AccountHead$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountHead model
   */ 
  interface AccountHeadFieldRefs {
    readonly id: FieldRef<"AccountHead", 'String'>
    readonly code: FieldRef<"AccountHead", 'String'>
    readonly name: FieldRef<"AccountHead", 'String'>
    readonly type: FieldRef<"AccountHead", 'String'>
    readonly is_system: FieldRef<"AccountHead", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AccountHead findUnique
   */
  export type AccountHeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead findUniqueOrThrow
   */
  export type AccountHeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead findFirst
   */
  export type AccountHeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountHeads.
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountHeads.
     */
    distinct?: AccountHeadScalarFieldEnum | AccountHeadScalarFieldEnum[]
  }

  /**
   * AccountHead findFirstOrThrow
   */
  export type AccountHeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHead to fetch.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountHeads.
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountHeads.
     */
    distinct?: AccountHeadScalarFieldEnum | AccountHeadScalarFieldEnum[]
  }

  /**
   * AccountHead findMany
   */
  export type AccountHeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter, which AccountHeads to fetch.
     */
    where?: AccountHeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountHeads to fetch.
     */
    orderBy?: AccountHeadOrderByWithRelationInput | AccountHeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountHeads.
     */
    cursor?: AccountHeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountHeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountHeads.
     */
    skip?: number
    distinct?: AccountHeadScalarFieldEnum | AccountHeadScalarFieldEnum[]
  }

  /**
   * AccountHead create
   */
  export type AccountHeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountHead.
     */
    data: XOR<AccountHeadCreateInput, AccountHeadUncheckedCreateInput>
  }

  /**
   * AccountHead createMany
   */
  export type AccountHeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountHeads.
     */
    data: AccountHeadCreateManyInput | AccountHeadCreateManyInput[]
  }

  /**
   * AccountHead createManyAndReturn
   */
  export type AccountHeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountHeads.
     */
    data: AccountHeadCreateManyInput | AccountHeadCreateManyInput[]
  }

  /**
   * AccountHead update
   */
  export type AccountHeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountHead.
     */
    data: XOR<AccountHeadUpdateInput, AccountHeadUncheckedUpdateInput>
    /**
     * Choose, which AccountHead to update.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead updateMany
   */
  export type AccountHeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountHeads.
     */
    data: XOR<AccountHeadUpdateManyMutationInput, AccountHeadUncheckedUpdateManyInput>
    /**
     * Filter which AccountHeads to update
     */
    where?: AccountHeadWhereInput
  }

  /**
   * AccountHead upsert
   */
  export type AccountHeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountHead to update in case it exists.
     */
    where: AccountHeadWhereUniqueInput
    /**
     * In case the AccountHead found by the `where` argument doesn't exist, create a new AccountHead with this data.
     */
    create: XOR<AccountHeadCreateInput, AccountHeadUncheckedCreateInput>
    /**
     * In case the AccountHead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountHeadUpdateInput, AccountHeadUncheckedUpdateInput>
  }

  /**
   * AccountHead delete
   */
  export type AccountHeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
    /**
     * Filter which AccountHead to delete.
     */
    where: AccountHeadWhereUniqueInput
  }

  /**
   * AccountHead deleteMany
   */
  export type AccountHeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountHeads to delete
     */
    where?: AccountHeadWhereInput
  }

  /**
   * AccountHead.ledgers
   */
  export type AccountHead$ledgersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    where?: LedgerWhereInput
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    cursor?: LedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * AccountHead.journalLines
   */
  export type AccountHead$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * AccountHead without action
   */
  export type AccountHeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountHead
     */
    select?: AccountHeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountHeadInclude<ExtArgs> | null
  }


  /**
   * Model Ledger
   */

  export type AggregateLedger = {
    _count: LedgerCountAggregateOutputType | null
    _avg: LedgerAvgAggregateOutputType | null
    _sum: LedgerSumAggregateOutputType | null
    _min: LedgerMinAggregateOutputType | null
    _max: LedgerMaxAggregateOutputType | null
  }

  export type LedgerAvgAggregateOutputType = {
    balance: number | null
  }

  export type LedgerSumAggregateOutputType = {
    balance: number | null
  }

  export type LedgerMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    account_head_id: string | null
    client_id: string | null
    balance: number | null
    updatedAt: Date | null
  }

  export type LedgerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    account_head_id: string | null
    client_id: string | null
    balance: number | null
    updatedAt: Date | null
  }

  export type LedgerCountAggregateOutputType = {
    id: number
    name: number
    type: number
    account_head_id: number
    client_id: number
    balance: number
    updatedAt: number
    _all: number
  }


  export type LedgerAvgAggregateInputType = {
    balance?: true
  }

  export type LedgerSumAggregateInputType = {
    balance?: true
  }

  export type LedgerMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    account_head_id?: true
    client_id?: true
    balance?: true
    updatedAt?: true
  }

  export type LedgerMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    account_head_id?: true
    client_id?: true
    balance?: true
    updatedAt?: true
  }

  export type LedgerCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    account_head_id?: true
    client_id?: true
    balance?: true
    updatedAt?: true
    _all?: true
  }

  export type LedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ledger to aggregate.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ledgers
    **/
    _count?: true | LedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerMaxAggregateInputType
  }

  export type GetLedgerAggregateType<T extends LedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedger[P]>
      : GetScalarType<T[P], AggregateLedger[P]>
  }




  export type LedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
    orderBy?: LedgerOrderByWithAggregationInput | LedgerOrderByWithAggregationInput[]
    by: LedgerScalarFieldEnum[] | LedgerScalarFieldEnum
    having?: LedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerCountAggregateInputType | true
    _avg?: LedgerAvgAggregateInputType
    _sum?: LedgerSumAggregateInputType
    _min?: LedgerMinAggregateInputType
    _max?: LedgerMaxAggregateInputType
  }

  export type LedgerGroupByOutputType = {
    id: string
    name: string
    type: string
    account_head_id: string
    client_id: string | null
    balance: number
    updatedAt: Date
    _count: LedgerCountAggregateOutputType | null
    _avg: LedgerAvgAggregateOutputType | null
    _sum: LedgerSumAggregateOutputType | null
    _min: LedgerMinAggregateOutputType | null
    _max: LedgerMaxAggregateOutputType | null
  }

  type GetLedgerGroupByPayload<T extends LedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerGroupByOutputType[P]>
        }
      >
    >


  export type LedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    account_head_id?: boolean
    client_id?: boolean
    balance?: boolean
    updatedAt?: boolean
    account_head?: boolean | AccountHeadDefaultArgs<ExtArgs>
    client?: boolean | Ledger$clientArgs<ExtArgs>
  }, ExtArgs["result"]["ledger"]>

  export type LedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    account_head_id?: boolean
    client_id?: boolean
    balance?: boolean
    updatedAt?: boolean
    account_head?: boolean | AccountHeadDefaultArgs<ExtArgs>
    client?: boolean | Ledger$clientArgs<ExtArgs>
  }, ExtArgs["result"]["ledger"]>

  export type LedgerSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    account_head_id?: boolean
    client_id?: boolean
    balance?: boolean
    updatedAt?: boolean
  }

  export type LedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_head?: boolean | AccountHeadDefaultArgs<ExtArgs>
    client?: boolean | Ledger$clientArgs<ExtArgs>
  }
  export type LedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account_head?: boolean | AccountHeadDefaultArgs<ExtArgs>
    client?: boolean | Ledger$clientArgs<ExtArgs>
  }

  export type $LedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ledger"
    objects: {
      account_head: Prisma.$AccountHeadPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      account_head_id: string
      client_id: string | null
      balance: number
      updatedAt: Date
    }, ExtArgs["result"]["ledger"]>
    composites: {}
  }

  type LedgerGetPayload<S extends boolean | null | undefined | LedgerDefaultArgs> = $Result.GetResult<Prisma.$LedgerPayload, S>

  type LedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerCountAggregateInputType | true
    }

  export interface LedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ledger'], meta: { name: 'Ledger' } }
    /**
     * Find zero or one Ledger that matches the filter.
     * @param {LedgerFindUniqueArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerFindUniqueArgs>(args: SelectSubset<T, LedgerFindUniqueArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ledger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerFindUniqueOrThrowArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindFirstArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerFindFirstArgs>(args?: SelectSubset<T, LedgerFindFirstArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ledger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindFirstOrThrowArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ledgers
     * const ledgers = await prisma.ledger.findMany()
     * 
     * // Get first 10 Ledgers
     * const ledgers = await prisma.ledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerWithIdOnly = await prisma.ledger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerFindManyArgs>(args?: SelectSubset<T, LedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ledger.
     * @param {LedgerCreateArgs} args - Arguments to create a Ledger.
     * @example
     * // Create one Ledger
     * const Ledger = await prisma.ledger.create({
     *   data: {
     *     // ... data to create a Ledger
     *   }
     * })
     * 
     */
    create<T extends LedgerCreateArgs>(args: SelectSubset<T, LedgerCreateArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ledgers.
     * @param {LedgerCreateManyArgs} args - Arguments to create many Ledgers.
     * @example
     * // Create many Ledgers
     * const ledger = await prisma.ledger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerCreateManyArgs>(args?: SelectSubset<T, LedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ledgers and returns the data saved in the database.
     * @param {LedgerCreateManyAndReturnArgs} args - Arguments to create many Ledgers.
     * @example
     * // Create many Ledgers
     * const ledger = await prisma.ledger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ledgers and only return the `id`
     * const ledgerWithIdOnly = await prisma.ledger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ledger.
     * @param {LedgerDeleteArgs} args - Arguments to delete one Ledger.
     * @example
     * // Delete one Ledger
     * const Ledger = await prisma.ledger.delete({
     *   where: {
     *     // ... filter to delete one Ledger
     *   }
     * })
     * 
     */
    delete<T extends LedgerDeleteArgs>(args: SelectSubset<T, LedgerDeleteArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ledger.
     * @param {LedgerUpdateArgs} args - Arguments to update one Ledger.
     * @example
     * // Update one Ledger
     * const ledger = await prisma.ledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerUpdateArgs>(args: SelectSubset<T, LedgerUpdateArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ledgers.
     * @param {LedgerDeleteManyArgs} args - Arguments to filter Ledgers to delete.
     * @example
     * // Delete a few Ledgers
     * const { count } = await prisma.ledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerDeleteManyArgs>(args?: SelectSubset<T, LedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ledgers
     * const ledger = await prisma.ledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerUpdateManyArgs>(args: SelectSubset<T, LedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ledger.
     * @param {LedgerUpsertArgs} args - Arguments to update or create a Ledger.
     * @example
     * // Update or create a Ledger
     * const ledger = await prisma.ledger.upsert({
     *   create: {
     *     // ... data to create a Ledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ledger we want to update
     *   }
     * })
     */
    upsert<T extends LedgerUpsertArgs>(args: SelectSubset<T, LedgerUpsertArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerCountArgs} args - Arguments to filter Ledgers to count.
     * @example
     * // Count the number of Ledgers
     * const count = await prisma.ledger.count({
     *   where: {
     *     // ... the filter for the Ledgers we want to count
     *   }
     * })
    **/
    count<T extends LedgerCountArgs>(
      args?: Subset<T, LedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerAggregateArgs>(args: Subset<T, LedgerAggregateArgs>): Prisma.PrismaPromise<GetLedgerAggregateType<T>>

    /**
     * Group by Ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerGroupByArgs['orderBy'] }
        : { orderBy?: LedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ledger model
   */
  readonly fields: LedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account_head<T extends AccountHeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountHeadDefaultArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends Ledger$clientArgs<ExtArgs> = {}>(args?: Subset<T, Ledger$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ledger model
   */ 
  interface LedgerFieldRefs {
    readonly id: FieldRef<"Ledger", 'String'>
    readonly name: FieldRef<"Ledger", 'String'>
    readonly type: FieldRef<"Ledger", 'String'>
    readonly account_head_id: FieldRef<"Ledger", 'String'>
    readonly client_id: FieldRef<"Ledger", 'String'>
    readonly balance: FieldRef<"Ledger", 'Float'>
    readonly updatedAt: FieldRef<"Ledger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ledger findUnique
   */
  export type LedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger findUniqueOrThrow
   */
  export type LedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger findFirst
   */
  export type LedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ledgers.
     */
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Ledger findFirstOrThrow
   */
  export type LedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ledgers.
     */
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Ledger findMany
   */
  export type LedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledgers to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Ledger create
   */
  export type LedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a Ledger.
     */
    data: XOR<LedgerCreateInput, LedgerUncheckedCreateInput>
  }

  /**
   * Ledger createMany
   */
  export type LedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ledgers.
     */
    data: LedgerCreateManyInput | LedgerCreateManyInput[]
  }

  /**
   * Ledger createManyAndReturn
   */
  export type LedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ledgers.
     */
    data: LedgerCreateManyInput | LedgerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ledger update
   */
  export type LedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a Ledger.
     */
    data: XOR<LedgerUpdateInput, LedgerUncheckedUpdateInput>
    /**
     * Choose, which Ledger to update.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger updateMany
   */
  export type LedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ledgers.
     */
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyInput>
    /**
     * Filter which Ledgers to update
     */
    where?: LedgerWhereInput
  }

  /**
   * Ledger upsert
   */
  export type LedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the Ledger to update in case it exists.
     */
    where: LedgerWhereUniqueInput
    /**
     * In case the Ledger found by the `where` argument doesn't exist, create a new Ledger with this data.
     */
    create: XOR<LedgerCreateInput, LedgerUncheckedCreateInput>
    /**
     * In case the Ledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerUpdateInput, LedgerUncheckedUpdateInput>
  }

  /**
   * Ledger delete
   */
  export type LedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter which Ledger to delete.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger deleteMany
   */
  export type LedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ledgers to delete
     */
    where?: LedgerWhereInput
  }

  /**
   * Ledger.client
   */
  export type Ledger$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Ledger without action
   */
  export type LedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    reference: string | null
    type: string | null
    createdAt: Date | null
    created_by: string | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    reference: string | null
    type: string | null
    createdAt: Date | null
    created_by: string | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    date: number
    description: number
    reference: number
    type: number
    createdAt: number
    created_by: number
    _all: number
  }


  export type JournalEntryMinAggregateInputType = {
    id?: true
    date?: true
    description?: true
    reference?: true
    type?: true
    createdAt?: true
    created_by?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    date?: true
    description?: true
    reference?: true
    type?: true
    createdAt?: true
    created_by?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    date?: true
    description?: true
    reference?: true
    type?: true
    createdAt?: true
    created_by?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    date: Date
    description: string
    reference: string | null
    type: string
    createdAt: Date
    created_by: string
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    reference?: boolean
    type?: boolean
    createdAt?: boolean
    created_by?: boolean
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    invoice?: boolean | JournalEntry$invoiceArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    reference?: boolean
    type?: boolean
    createdAt?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    date?: boolean
    description?: boolean
    reference?: boolean
    type?: boolean
    createdAt?: boolean
    created_by?: boolean
  }

  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    invoice?: boolean | JournalEntry$invoiceArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      lines: Prisma.$JournalLinePayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      description: string
      reference: string | null
      type: string
      createdAt: Date
      created_by: string
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lines<T extends JournalEntry$linesArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany"> | Null>
    invoice<T extends JournalEntry$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */ 
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly date: FieldRef<"JournalEntry", 'DateTime'>
    readonly description: FieldRef<"JournalEntry", 'String'>
    readonly reference: FieldRef<"JournalEntry", 'String'>
    readonly type: FieldRef<"JournalEntry", 'String'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly created_by: FieldRef<"JournalEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
  }

  /**
   * JournalEntry.lines
   */
  export type JournalEntry$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalEntry.invoice
   */
  export type JournalEntry$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model JournalLine
   */

  export type AggregateJournalLine = {
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  export type JournalLineAvgAggregateOutputType = {
    debit: number | null
    credit: number | null
  }

  export type JournalLineSumAggregateOutputType = {
    debit: number | null
    credit: number | null
  }

  export type JournalLineMinAggregateOutputType = {
    id: string | null
    entry_id: string | null
    account_id: string | null
    debit: number | null
    credit: number | null
    description: string | null
    invoice_id: string | null
  }

  export type JournalLineMaxAggregateOutputType = {
    id: string | null
    entry_id: string | null
    account_id: string | null
    debit: number | null
    credit: number | null
    description: string | null
    invoice_id: string | null
  }

  export type JournalLineCountAggregateOutputType = {
    id: number
    entry_id: number
    account_id: number
    debit: number
    credit: number
    description: number
    invoice_id: number
    _all: number
  }


  export type JournalLineAvgAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type JournalLineSumAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type JournalLineMinAggregateInputType = {
    id?: true
    entry_id?: true
    account_id?: true
    debit?: true
    credit?: true
    description?: true
    invoice_id?: true
  }

  export type JournalLineMaxAggregateInputType = {
    id?: true
    entry_id?: true
    account_id?: true
    debit?: true
    credit?: true
    description?: true
    invoice_id?: true
  }

  export type JournalLineCountAggregateInputType = {
    id?: true
    entry_id?: true
    account_id?: true
    debit?: true
    credit?: true
    description?: true
    invoice_id?: true
    _all?: true
  }

  export type JournalLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLine to aggregate.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLines
    **/
    _count?: true | JournalLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLineMaxAggregateInputType
  }

  export type GetJournalLineAggregateType<T extends JournalLineAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLine[P]>
      : GetScalarType<T[P], AggregateJournalLine[P]>
  }




  export type JournalLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithAggregationInput | JournalLineOrderByWithAggregationInput[]
    by: JournalLineScalarFieldEnum[] | JournalLineScalarFieldEnum
    having?: JournalLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLineCountAggregateInputType | true
    _avg?: JournalLineAvgAggregateInputType
    _sum?: JournalLineSumAggregateInputType
    _min?: JournalLineMinAggregateInputType
    _max?: JournalLineMaxAggregateInputType
  }

  export type JournalLineGroupByOutputType = {
    id: string
    entry_id: string
    account_id: string
    debit: number
    credit: number
    description: string | null
    invoice_id: string | null
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  type GetJournalLineGroupByPayload<T extends JournalLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
        }
      >
    >


  export type JournalLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entry_id?: boolean
    account_id?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    invoice_id?: boolean
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountHeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entry_id?: boolean
    account_id?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    invoice_id?: boolean
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountHeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectScalar = {
    id?: boolean
    entry_id?: boolean
    account_id?: boolean
    debit?: boolean
    credit?: boolean
    description?: boolean
    invoice_id?: boolean
  }

  export type JournalLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountHeadDefaultArgs<ExtArgs>
  }
  export type JournalLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
    account?: boolean | AccountHeadDefaultArgs<ExtArgs>
  }

  export type $JournalLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLine"
    objects: {
      entry: Prisma.$JournalEntryPayload<ExtArgs>
      account: Prisma.$AccountHeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entry_id: string
      account_id: string
      debit: number
      credit: number
      description: string | null
      invoice_id: string | null
    }, ExtArgs["result"]["journalLine"]>
    composites: {}
  }

  type JournalLineGetPayload<S extends boolean | null | undefined | JournalLineDefaultArgs> = $Result.GetResult<Prisma.$JournalLinePayload, S>

  type JournalLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalLineCountAggregateInputType | true
    }

  export interface JournalLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLine'], meta: { name: 'JournalLine' } }
    /**
     * Find zero or one JournalLine that matches the filter.
     * @param {JournalLineFindUniqueArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLineFindUniqueArgs>(args: SelectSubset<T, JournalLineFindUniqueArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalLineFindUniqueOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLineFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLineFindFirstArgs>(args?: SelectSubset<T, JournalLineFindFirstArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLineFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLines
     * const journalLines = await prisma.journalLine.findMany()
     * 
     * // Get first 10 JournalLines
     * const journalLines = await prisma.journalLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLineFindManyArgs>(args?: SelectSubset<T, JournalLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalLine.
     * @param {JournalLineCreateArgs} args - Arguments to create a JournalLine.
     * @example
     * // Create one JournalLine
     * const JournalLine = await prisma.journalLine.create({
     *   data: {
     *     // ... data to create a JournalLine
     *   }
     * })
     * 
     */
    create<T extends JournalLineCreateArgs>(args: SelectSubset<T, JournalLineCreateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalLines.
     * @param {JournalLineCreateManyArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLineCreateManyArgs>(args?: SelectSubset<T, JournalLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLines and returns the data saved in the database.
     * @param {JournalLineCreateManyAndReturnArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLineCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalLine.
     * @param {JournalLineDeleteArgs} args - Arguments to delete one JournalLine.
     * @example
     * // Delete one JournalLine
     * const JournalLine = await prisma.journalLine.delete({
     *   where: {
     *     // ... filter to delete one JournalLine
     *   }
     * })
     * 
     */
    delete<T extends JournalLineDeleteArgs>(args: SelectSubset<T, JournalLineDeleteArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalLine.
     * @param {JournalLineUpdateArgs} args - Arguments to update one JournalLine.
     * @example
     * // Update one JournalLine
     * const journalLine = await prisma.journalLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLineUpdateArgs>(args: SelectSubset<T, JournalLineUpdateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalLines.
     * @param {JournalLineDeleteManyArgs} args - Arguments to filter JournalLines to delete.
     * @example
     * // Delete a few JournalLines
     * const { count } = await prisma.journalLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLineDeleteManyArgs>(args?: SelectSubset<T, JournalLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLineUpdateManyArgs>(args: SelectSubset<T, JournalLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalLine.
     * @param {JournalLineUpsertArgs} args - Arguments to update or create a JournalLine.
     * @example
     * // Update or create a JournalLine
     * const journalLine = await prisma.journalLine.upsert({
     *   create: {
     *     // ... data to create a JournalLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLine we want to update
     *   }
     * })
     */
    upsert<T extends JournalLineUpsertArgs>(args: SelectSubset<T, JournalLineUpsertArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineCountArgs} args - Arguments to filter JournalLines to count.
     * @example
     * // Count the number of JournalLines
     * const count = await prisma.journalLine.count({
     *   where: {
     *     // ... the filter for the JournalLines we want to count
     *   }
     * })
    **/
    count<T extends JournalLineCountArgs>(
      args?: Subset<T, JournalLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLineAggregateArgs>(args: Subset<T, JournalLineAggregateArgs>): Prisma.PrismaPromise<GetJournalLineAggregateType<T>>

    /**
     * Group by JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLineGroupByArgs['orderBy'] }
        : { orderBy?: JournalLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLine model
   */
  readonly fields: JournalLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entry<T extends JournalEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntryDefaultArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountHeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountHeadDefaultArgs<ExtArgs>>): Prisma__AccountHeadClient<$Result.GetResult<Prisma.$AccountHeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLine model
   */ 
  interface JournalLineFieldRefs {
    readonly id: FieldRef<"JournalLine", 'String'>
    readonly entry_id: FieldRef<"JournalLine", 'String'>
    readonly account_id: FieldRef<"JournalLine", 'String'>
    readonly debit: FieldRef<"JournalLine", 'Float'>
    readonly credit: FieldRef<"JournalLine", 'Float'>
    readonly description: FieldRef<"JournalLine", 'String'>
    readonly invoice_id: FieldRef<"JournalLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalLine findUnique
   */
  export type JournalLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findUniqueOrThrow
   */
  export type JournalLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findFirst
   */
  export type JournalLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findFirstOrThrow
   */
  export type JournalLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findMany
   */
  export type JournalLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLines to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine create
   */
  export type JournalLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLine.
     */
    data: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
  }

  /**
   * JournalLine createMany
   */
  export type JournalLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
  }

  /**
   * JournalLine createManyAndReturn
   */
  export type JournalLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine update
   */
  export type JournalLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLine.
     */
    data: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
    /**
     * Choose, which JournalLine to update.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine updateMany
   */
  export type JournalLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
  }

  /**
   * JournalLine upsert
   */
  export type JournalLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLine to update in case it exists.
     */
    where: JournalLineWhereUniqueInput
    /**
     * In case the JournalLine found by the `where` argument doesn't exist, create a new JournalLine with this data.
     */
    create: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
    /**
     * In case the JournalLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
  }

  /**
   * JournalLine delete
   */
  export type JournalLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter which JournalLine to delete.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine deleteMany
   */
  export type JournalLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLines to delete
     */
    where?: JournalLineWhereInput
  }

  /**
   * JournalLine without action
   */
  export type JournalLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    tax_rate: number | null
    tax_amount: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    tax_rate: number | null
    tax_amount: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    due_date: Date | null
    status: string | null
    client_id: string | null
    subtotal: number | null
    tax_rate: number | null
    tax_amount: number | null
    total: number | null
    journal_entry_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    number: string | null
    date: Date | null
    due_date: Date | null
    status: string | null
    client_id: string | null
    subtotal: number | null
    tax_rate: number | null
    tax_amount: number | null
    total: number | null
    journal_entry_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    number: number
    date: number
    due_date: number
    status: number
    client_id: number
    subtotal: number
    tax_rate: number
    tax_amount: number
    total: number
    journal_entry_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax_rate?: true
    tax_amount?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax_rate?: true
    tax_amount?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    due_date?: true
    status?: true
    client_id?: true
    subtotal?: true
    tax_rate?: true
    tax_amount?: true
    total?: true
    journal_entry_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    due_date?: true
    status?: true
    client_id?: true
    subtotal?: true
    tax_rate?: true
    tax_amount?: true
    total?: true
    journal_entry_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    due_date?: true
    status?: true
    client_id?: true
    subtotal?: true
    tax_rate?: true
    tax_amount?: true
    total?: true
    journal_entry_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    number: string
    date: Date
    due_date: Date
    status: string
    client_id: string
    subtotal: number
    tax_rate: number
    tax_amount: number
    total: number
    journal_entry_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    due_date?: boolean
    status?: boolean
    client_id?: boolean
    subtotal?: boolean
    tax_rate?: boolean
    tax_amount?: boolean
    total?: boolean
    journal_entry_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    journal_entry?: boolean | Invoice$journal_entryArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    due_date?: boolean
    status?: boolean
    client_id?: boolean
    subtotal?: boolean
    tax_rate?: boolean
    tax_amount?: boolean
    total?: boolean
    journal_entry_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    journal_entry?: boolean | Invoice$journal_entryArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    due_date?: boolean
    status?: boolean
    client_id?: boolean
    subtotal?: boolean
    tax_rate?: boolean
    tax_amount?: boolean
    total?: boolean
    journal_entry_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    journal_entry?: boolean | Invoice$journal_entryArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    journal_entry?: boolean | Invoice$journal_entryArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      journal_entry: Prisma.$JournalEntryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      date: Date
      due_date: Date
      status: string
      client_id: string
      subtotal: number
      tax_rate: number
      tax_amount: number
      total: number
      journal_entry_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    journal_entry<T extends Invoice$journal_entryArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$journal_entryArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly due_date: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly client_id: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly tax_rate: FieldRef<"Invoice", 'Float'>
    readonly tax_amount: FieldRef<"Invoice", 'Float'>
    readonly total: FieldRef<"Invoice", 'Float'>
    readonly journal_entry_id: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.journal_entry
   */
  export type Invoice$journal_entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    amount: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    amount: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unit_price: number | null
    amount: number | null
    invoice_id: string | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unit_price: number | null
    amount: number | null
    invoice_id: string | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    description: number
    quantity: number
    unit_price: number
    amount: number
    invoice_id: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    amount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    amount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unit_price?: true
    amount?: true
    invoice_id?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unit_price?: true
    amount?: true
    invoice_id?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unit_price?: true
    amount?: true
    invoice_id?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    description: string
    quantity: number
    unit_price: number
    amount: number
    invoice_id: string
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    amount?: boolean
    invoice_id?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    amount?: boolean
    invoice_id?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    description?: boolean
    quantity?: boolean
    unit_price?: boolean
    amount?: boolean
    invoice_id?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      quantity: number
      unit_price: number
      amount: number
      invoice_id: string
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unit_price: FieldRef<"InvoiceItem", 'Float'>
    readonly amount: FieldRef<"InvoiceItem", 'Float'>
    readonly invoice_id: FieldRef<"InvoiceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    estimated_hours: number | null
    time_estimate: number | null
  }

  export type TaskSumAggregateOutputType = {
    estimated_hours: number | null
    time_estimate: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    type: string | null
    category: string | null
    platform: string | null
    due_date: Date | null
    start_date: Date | null
    actual_start_date: Date | null
    completed_date: Date | null
    estimated_hours: number | null
    time_estimate: number | null
    createdAt: Date | null
    updatedAt: Date | null
    campaign_id: string | null
    client_id: string | null
    parent_task_id: string | null
    assignee_id: string | null
    reporter_id: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    type: string | null
    category: string | null
    platform: string | null
    due_date: Date | null
    start_date: Date | null
    actual_start_date: Date | null
    completed_date: Date | null
    estimated_hours: number | null
    time_estimate: number | null
    createdAt: Date | null
    updatedAt: Date | null
    campaign_id: string | null
    client_id: string | null
    parent_task_id: string | null
    assignee_id: string | null
    reporter_id: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    type: number
    category: number
    platform: number
    due_date: number
    start_date: number
    actual_start_date: number
    completed_date: number
    estimated_hours: number
    time_estimate: number
    createdAt: number
    updatedAt: number
    campaign_id: number
    client_id: number
    parent_task_id: number
    assignee_id: number
    reporter_id: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    estimated_hours?: true
    time_estimate?: true
  }

  export type TaskSumAggregateInputType = {
    estimated_hours?: true
    time_estimate?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    type?: true
    category?: true
    platform?: true
    due_date?: true
    start_date?: true
    actual_start_date?: true
    completed_date?: true
    estimated_hours?: true
    time_estimate?: true
    createdAt?: true
    updatedAt?: true
    campaign_id?: true
    client_id?: true
    parent_task_id?: true
    assignee_id?: true
    reporter_id?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    type?: true
    category?: true
    platform?: true
    due_date?: true
    start_date?: true
    actual_start_date?: true
    completed_date?: true
    estimated_hours?: true
    time_estimate?: true
    createdAt?: true
    updatedAt?: true
    campaign_id?: true
    client_id?: true
    parent_task_id?: true
    assignee_id?: true
    reporter_id?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    type?: true
    category?: true
    platform?: true
    due_date?: true
    start_date?: true
    actual_start_date?: true
    completed_date?: true
    estimated_hours?: true
    time_estimate?: true
    createdAt?: true
    updatedAt?: true
    campaign_id?: true
    client_id?: true
    parent_task_id?: true
    assignee_id?: true
    reporter_id?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: string
    priority: string
    type: string
    category: string
    platform: string | null
    due_date: Date | null
    start_date: Date | null
    actual_start_date: Date | null
    completed_date: Date | null
    estimated_hours: number | null
    time_estimate: number | null
    createdAt: Date
    updatedAt: Date
    campaign_id: string | null
    client_id: string | null
    parent_task_id: string | null
    assignee_id: string | null
    reporter_id: string
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    type?: boolean
    category?: boolean
    platform?: boolean
    due_date?: boolean
    start_date?: boolean
    actual_start_date?: boolean
    completed_date?: boolean
    estimated_hours?: boolean
    time_estimate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign_id?: boolean
    client_id?: boolean
    parent_task_id?: boolean
    assignee_id?: boolean
    reporter_id?: boolean
    campaign?: boolean | Task$campaignArgs<ExtArgs>
    client?: boolean | Task$clientArgs<ExtArgs>
    parent_task?: boolean | Task$parent_taskArgs<ExtArgs>
    sub_tasks?: boolean | Task$sub_tasksArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | Task$assetsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    type?: boolean
    category?: boolean
    platform?: boolean
    due_date?: boolean
    start_date?: boolean
    actual_start_date?: boolean
    completed_date?: boolean
    estimated_hours?: boolean
    time_estimate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign_id?: boolean
    client_id?: boolean
    parent_task_id?: boolean
    assignee_id?: boolean
    reporter_id?: boolean
    campaign?: boolean | Task$campaignArgs<ExtArgs>
    client?: boolean | Task$clientArgs<ExtArgs>
    parent_task?: boolean | Task$parent_taskArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    type?: boolean
    category?: boolean
    platform?: boolean
    due_date?: boolean
    start_date?: boolean
    actual_start_date?: boolean
    completed_date?: boolean
    estimated_hours?: boolean
    time_estimate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign_id?: boolean
    client_id?: boolean
    parent_task_id?: boolean
    assignee_id?: boolean
    reporter_id?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | Task$campaignArgs<ExtArgs>
    client?: boolean | Task$clientArgs<ExtArgs>
    parent_task?: boolean | Task$parent_taskArgs<ExtArgs>
    sub_tasks?: boolean | Task$sub_tasksArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | Task$assetsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | Task$campaignArgs<ExtArgs>
    client?: boolean | Task$clientArgs<ExtArgs>
    parent_task?: boolean | Task$parent_taskArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      parent_task: Prisma.$TaskPayload<ExtArgs> | null
      sub_tasks: Prisma.$TaskPayload<ExtArgs>[]
      dependencies: Prisma.$TaskDependencyPayload<ExtArgs>[]
      dependents: Prisma.$TaskDependencyPayload<ExtArgs>[]
      assignee: Prisma.$UserPayload<ExtArgs> | null
      reporter: Prisma.$UserPayload<ExtArgs>
      assets: Prisma.$AssetPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: string
      priority: string
      type: string
      category: string
      platform: string | null
      due_date: Date | null
      start_date: Date | null
      actual_start_date: Date | null
      completed_date: Date | null
      estimated_hours: number | null
      time_estimate: number | null
      createdAt: Date
      updatedAt: Date
      campaign_id: string | null
      client_id: string | null
      parent_task_id: string | null
      assignee_id: string | null
      reporter_id: string
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends Task$campaignArgs<ExtArgs> = {}>(args?: Subset<T, Task$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    client<T extends Task$clientArgs<ExtArgs> = {}>(args?: Subset<T, Task$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parent_task<T extends Task$parent_taskArgs<ExtArgs> = {}>(args?: Subset<T, Task$parent_taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sub_tasks<T extends Task$sub_tasksArgs<ExtArgs> = {}>(args?: Subset<T, Task$sub_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    dependencies<T extends Task$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    dependents<T extends Task$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    assignee<T extends Task$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assets<T extends Task$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Task$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    timeLogs<T extends Task$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Task$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly type: FieldRef<"Task", 'String'>
    readonly category: FieldRef<"Task", 'String'>
    readonly platform: FieldRef<"Task", 'String'>
    readonly due_date: FieldRef<"Task", 'DateTime'>
    readonly start_date: FieldRef<"Task", 'DateTime'>
    readonly actual_start_date: FieldRef<"Task", 'DateTime'>
    readonly completed_date: FieldRef<"Task", 'DateTime'>
    readonly estimated_hours: FieldRef<"Task", 'Float'>
    readonly time_estimate: FieldRef<"Task", 'Float'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly campaign_id: FieldRef<"Task", 'String'>
    readonly client_id: FieldRef<"Task", 'String'>
    readonly parent_task_id: FieldRef<"Task", 'String'>
    readonly assignee_id: FieldRef<"Task", 'String'>
    readonly reporter_id: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.campaign
   */
  export type Task$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Task.client
   */
  export type Task$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Task.parent_task
   */
  export type Task$parent_taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Task.sub_tasks
   */
  export type Task$sub_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task.dependencies
   */
  export type Task$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    cursor?: TaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * Task.dependents
   */
  export type Task$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    cursor?: TaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * Task.assignee
   */
  export type Task$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task.assets
   */
  export type Task$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Task.timeLogs
   */
  export type Task$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskDependency
   */

  export type AggregateTaskDependency = {
    _count: TaskDependencyCountAggregateOutputType | null
    _min: TaskDependencyMinAggregateOutputType | null
    _max: TaskDependencyMaxAggregateOutputType | null
  }

  export type TaskDependencyMinAggregateOutputType = {
    id: string | null
    blocking_task_id: string | null
    blocked_task_id: string | null
    createdAt: Date | null
  }

  export type TaskDependencyMaxAggregateOutputType = {
    id: string | null
    blocking_task_id: string | null
    blocked_task_id: string | null
    createdAt: Date | null
  }

  export type TaskDependencyCountAggregateOutputType = {
    id: number
    blocking_task_id: number
    blocked_task_id: number
    createdAt: number
    _all: number
  }


  export type TaskDependencyMinAggregateInputType = {
    id?: true
    blocking_task_id?: true
    blocked_task_id?: true
    createdAt?: true
  }

  export type TaskDependencyMaxAggregateInputType = {
    id?: true
    blocking_task_id?: true
    blocked_task_id?: true
    createdAt?: true
  }

  export type TaskDependencyCountAggregateInputType = {
    id?: true
    blocking_task_id?: true
    blocked_task_id?: true
    createdAt?: true
    _all?: true
  }

  export type TaskDependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDependency to aggregate.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDependencies
    **/
    _count?: true | TaskDependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDependencyMaxAggregateInputType
  }

  export type GetTaskDependencyAggregateType<T extends TaskDependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDependency[P]>
      : GetScalarType<T[P], AggregateTaskDependency[P]>
  }




  export type TaskDependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithAggregationInput | TaskDependencyOrderByWithAggregationInput[]
    by: TaskDependencyScalarFieldEnum[] | TaskDependencyScalarFieldEnum
    having?: TaskDependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDependencyCountAggregateInputType | true
    _min?: TaskDependencyMinAggregateInputType
    _max?: TaskDependencyMaxAggregateInputType
  }

  export type TaskDependencyGroupByOutputType = {
    id: string
    blocking_task_id: string
    blocked_task_id: string
    createdAt: Date
    _count: TaskDependencyCountAggregateOutputType | null
    _min: TaskDependencyMinAggregateOutputType | null
    _max: TaskDependencyMaxAggregateOutputType | null
  }

  type GetTaskDependencyGroupByPayload<T extends TaskDependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
        }
      >
    >


  export type TaskDependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blocking_task_id?: boolean
    blocked_task_id?: boolean
    createdAt?: boolean
    blocking_task?: boolean | TaskDefaultArgs<ExtArgs>
    blocked_task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDependency"]>

  export type TaskDependencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blocking_task_id?: boolean
    blocked_task_id?: boolean
    createdAt?: boolean
    blocking_task?: boolean | TaskDefaultArgs<ExtArgs>
    blocked_task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDependency"]>

  export type TaskDependencySelectScalar = {
    id?: boolean
    blocking_task_id?: boolean
    blocked_task_id?: boolean
    createdAt?: boolean
  }

  export type TaskDependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocking_task?: boolean | TaskDefaultArgs<ExtArgs>
    blocked_task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskDependencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocking_task?: boolean | TaskDefaultArgs<ExtArgs>
    blocked_task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskDependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDependency"
    objects: {
      blocking_task: Prisma.$TaskPayload<ExtArgs>
      blocked_task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blocking_task_id: string
      blocked_task_id: string
      createdAt: Date
    }, ExtArgs["result"]["taskDependency"]>
    composites: {}
  }

  type TaskDependencyGetPayload<S extends boolean | null | undefined | TaskDependencyDefaultArgs> = $Result.GetResult<Prisma.$TaskDependencyPayload, S>

  type TaskDependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDependencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDependencyCountAggregateInputType | true
    }

  export interface TaskDependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDependency'], meta: { name: 'TaskDependency' } }
    /**
     * Find zero or one TaskDependency that matches the filter.
     * @param {TaskDependencyFindUniqueArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDependencyFindUniqueArgs>(args: SelectSubset<T, TaskDependencyFindUniqueArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDependency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDependencyFindUniqueOrThrowArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindFirstArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDependencyFindFirstArgs>(args?: SelectSubset<T, TaskDependencyFindFirstArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindFirstOrThrowArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDependencies
     * const taskDependencies = await prisma.taskDependency.findMany()
     * 
     * // Get first 10 TaskDependencies
     * const taskDependencies = await prisma.taskDependency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskDependencyWithIdOnly = await prisma.taskDependency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskDependencyFindManyArgs>(args?: SelectSubset<T, TaskDependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDependency.
     * @param {TaskDependencyCreateArgs} args - Arguments to create a TaskDependency.
     * @example
     * // Create one TaskDependency
     * const TaskDependency = await prisma.taskDependency.create({
     *   data: {
     *     // ... data to create a TaskDependency
     *   }
     * })
     * 
     */
    create<T extends TaskDependencyCreateArgs>(args: SelectSubset<T, TaskDependencyCreateArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDependencies.
     * @param {TaskDependencyCreateManyArgs} args - Arguments to create many TaskDependencies.
     * @example
     * // Create many TaskDependencies
     * const taskDependency = await prisma.taskDependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDependencyCreateManyArgs>(args?: SelectSubset<T, TaskDependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskDependencies and returns the data saved in the database.
     * @param {TaskDependencyCreateManyAndReturnArgs} args - Arguments to create many TaskDependencies.
     * @example
     * // Create many TaskDependencies
     * const taskDependency = await prisma.taskDependency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskDependencies and only return the `id`
     * const taskDependencyWithIdOnly = await prisma.taskDependency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskDependencyCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskDependencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskDependency.
     * @param {TaskDependencyDeleteArgs} args - Arguments to delete one TaskDependency.
     * @example
     * // Delete one TaskDependency
     * const TaskDependency = await prisma.taskDependency.delete({
     *   where: {
     *     // ... filter to delete one TaskDependency
     *   }
     * })
     * 
     */
    delete<T extends TaskDependencyDeleteArgs>(args: SelectSubset<T, TaskDependencyDeleteArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDependency.
     * @param {TaskDependencyUpdateArgs} args - Arguments to update one TaskDependency.
     * @example
     * // Update one TaskDependency
     * const taskDependency = await prisma.taskDependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDependencyUpdateArgs>(args: SelectSubset<T, TaskDependencyUpdateArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDependencies.
     * @param {TaskDependencyDeleteManyArgs} args - Arguments to filter TaskDependencies to delete.
     * @example
     * // Delete a few TaskDependencies
     * const { count } = await prisma.taskDependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDependencyDeleteManyArgs>(args?: SelectSubset<T, TaskDependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDependencies
     * const taskDependency = await prisma.taskDependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDependencyUpdateManyArgs>(args: SelectSubset<T, TaskDependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDependency.
     * @param {TaskDependencyUpsertArgs} args - Arguments to update or create a TaskDependency.
     * @example
     * // Update or create a TaskDependency
     * const taskDependency = await prisma.taskDependency.upsert({
     *   create: {
     *     // ... data to create a TaskDependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDependency we want to update
     *   }
     * })
     */
    upsert<T extends TaskDependencyUpsertArgs>(args: SelectSubset<T, TaskDependencyUpsertArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyCountArgs} args - Arguments to filter TaskDependencies to count.
     * @example
     * // Count the number of TaskDependencies
     * const count = await prisma.taskDependency.count({
     *   where: {
     *     // ... the filter for the TaskDependencies we want to count
     *   }
     * })
    **/
    count<T extends TaskDependencyCountArgs>(
      args?: Subset<T, TaskDependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDependencyAggregateArgs>(args: Subset<T, TaskDependencyAggregateArgs>): Prisma.PrismaPromise<GetTaskDependencyAggregateType<T>>

    /**
     * Group by TaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDependencyGroupByArgs['orderBy'] }
        : { orderBy?: TaskDependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDependency model
   */
  readonly fields: TaskDependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocking_task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blocked_task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDependency model
   */ 
  interface TaskDependencyFieldRefs {
    readonly id: FieldRef<"TaskDependency", 'String'>
    readonly blocking_task_id: FieldRef<"TaskDependency", 'String'>
    readonly blocked_task_id: FieldRef<"TaskDependency", 'String'>
    readonly createdAt: FieldRef<"TaskDependency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskDependency findUnique
   */
  export type TaskDependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency findUniqueOrThrow
   */
  export type TaskDependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency findFirst
   */
  export type TaskDependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDependencies.
     */
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * TaskDependency findFirstOrThrow
   */
  export type TaskDependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDependencies.
     */
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * TaskDependency findMany
   */
  export type TaskDependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependencies to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * TaskDependency create
   */
  export type TaskDependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDependency.
     */
    data: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>
  }

  /**
   * TaskDependency createMany
   */
  export type TaskDependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDependencies.
     */
    data: TaskDependencyCreateManyInput | TaskDependencyCreateManyInput[]
  }

  /**
   * TaskDependency createManyAndReturn
   */
  export type TaskDependencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskDependencies.
     */
    data: TaskDependencyCreateManyInput | TaskDependencyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskDependency update
   */
  export type TaskDependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDependency.
     */
    data: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>
    /**
     * Choose, which TaskDependency to update.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency updateMany
   */
  export type TaskDependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDependencies.
     */
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyInput>
    /**
     * Filter which TaskDependencies to update
     */
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskDependency upsert
   */
  export type TaskDependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDependency to update in case it exists.
     */
    where: TaskDependencyWhereUniqueInput
    /**
     * In case the TaskDependency found by the `where` argument doesn't exist, create a new TaskDependency with this data.
     */
    create: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>
    /**
     * In case the TaskDependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>
  }

  /**
   * TaskDependency delete
   */
  export type TaskDependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter which TaskDependency to delete.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency deleteMany
   */
  export type TaskDependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDependencies to delete
     */
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskDependency without action
   */
  export type TaskDependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    size_bytes: number | null
    version: number | null
  }

  export type AssetSumAggregateOutputType = {
    size_bytes: number | null
    version: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    original_name: string | null
    file_url: string | null
    file_type: string | null
    size_bytes: number | null
    version: number | null
    is_approved: boolean | null
    createdAt: Date | null
    task_id: string | null
    uploader_id: string | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    original_name: string | null
    file_url: string | null
    file_type: string | null
    size_bytes: number | null
    version: number | null
    is_approved: boolean | null
    createdAt: Date | null
    task_id: string | null
    uploader_id: string | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    original_name: number
    file_url: number
    file_type: number
    size_bytes: number
    version: number
    is_approved: number
    createdAt: number
    task_id: number
    uploader_id: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    size_bytes?: true
    version?: true
  }

  export type AssetSumAggregateInputType = {
    size_bytes?: true
    version?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    original_name?: true
    file_url?: true
    file_type?: true
    size_bytes?: true
    version?: true
    is_approved?: true
    createdAt?: true
    task_id?: true
    uploader_id?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    original_name?: true
    file_url?: true
    file_type?: true
    size_bytes?: true
    version?: true
    is_approved?: true
    createdAt?: true
    task_id?: true
    uploader_id?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    original_name?: true
    file_url?: true
    file_type?: true
    size_bytes?: true
    version?: true
    is_approved?: true
    createdAt?: true
    task_id?: true
    uploader_id?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes: number | null
    version: number
    is_approved: boolean
    createdAt: Date
    task_id: string
    uploader_id: string
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_name?: boolean
    file_url?: boolean
    file_type?: boolean
    size_bytes?: boolean
    version?: boolean
    is_approved?: boolean
    createdAt?: boolean
    task_id?: boolean
    uploader_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Asset$commentsArgs<ExtArgs>
    ads?: boolean | Asset$adsArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_name?: boolean
    file_url?: boolean
    file_type?: boolean
    size_bytes?: boolean
    version?: boolean
    is_approved?: boolean
    createdAt?: boolean
    task_id?: boolean
    uploader_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    original_name?: boolean
    file_url?: boolean
    file_type?: boolean
    size_bytes?: boolean
    version?: boolean
    is_approved?: boolean
    createdAt?: boolean
    task_id?: boolean
    uploader_id?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Asset$commentsArgs<ExtArgs>
    ads?: boolean | Asset$adsArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$AssetCommentPayload<ExtArgs>[]
      ads: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      original_name: string
      file_url: string
      file_type: string
      size_bytes: number | null
      version: number
      is_approved: boolean
      createdAt: Date
      task_id: string
      uploader_id: string
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends Asset$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findMany"> | Null>
    ads<T extends Asset$adsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly original_name: FieldRef<"Asset", 'String'>
    readonly file_url: FieldRef<"Asset", 'String'>
    readonly file_type: FieldRef<"Asset", 'String'>
    readonly size_bytes: FieldRef<"Asset", 'Int'>
    readonly version: FieldRef<"Asset", 'Int'>
    readonly is_approved: FieldRef<"Asset", 'Boolean'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly task_id: FieldRef<"Asset", 'String'>
    readonly uploader_id: FieldRef<"Asset", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset.comments
   */
  export type Asset$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    where?: AssetCommentWhereInput
    orderBy?: AssetCommentOrderByWithRelationInput | AssetCommentOrderByWithRelationInput[]
    cursor?: AssetCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetCommentScalarFieldEnum | AssetCommentScalarFieldEnum[]
  }

  /**
   * Asset.ads
   */
  export type Asset$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    is_revision_request: boolean | null
    createdAt: Date | null
    task_id: string | null
    author_id: string | null
    parent_comment_id: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    is_revision_request: boolean | null
    createdAt: Date | null
    task_id: string | null
    author_id: string | null
    parent_comment_id: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    is_revision_request: number
    createdAt: number
    task_id: number
    author_id: number
    parent_comment_id: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    is_revision_request?: true
    createdAt?: true
    task_id?: true
    author_id?: true
    parent_comment_id?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    is_revision_request?: true
    createdAt?: true
    task_id?: true
    author_id?: true
    parent_comment_id?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    is_revision_request?: true
    createdAt?: true
    task_id?: true
    author_id?: true
    parent_comment_id?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    is_revision_request: boolean
    createdAt: Date
    task_id: string
    author_id: string
    parent_comment_id: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    is_revision_request?: boolean
    createdAt?: boolean
    task_id?: boolean
    author_id?: boolean
    parent_comment_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent_comment?: boolean | Comment$parent_commentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    is_revision_request?: boolean
    createdAt?: boolean
    task_id?: boolean
    author_id?: boolean
    parent_comment_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent_comment?: boolean | Comment$parent_commentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    is_revision_request?: boolean
    createdAt?: boolean
    task_id?: boolean
    author_id?: boolean
    parent_comment_id?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent_comment?: boolean | Comment$parent_commentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent_comment?: boolean | Comment$parent_commentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      parent_comment: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      is_revision_request: boolean
      createdAt: Date
      task_id: string
      author_id: string
      parent_comment_id: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent_comment<T extends Comment$parent_commentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parent_commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly is_revision_request: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly task_id: FieldRef<"Comment", 'String'>
    readonly author_id: FieldRef<"Comment", 'String'>
    readonly parent_comment_id: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.parent_comment
   */
  export type Comment$parent_commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model AssetComment
   */

  export type AggregateAssetComment = {
    _count: AssetCommentCountAggregateOutputType | null
    _avg: AssetCommentAvgAggregateOutputType | null
    _sum: AssetCommentSumAggregateOutputType | null
    _min: AssetCommentMinAggregateOutputType | null
    _max: AssetCommentMaxAggregateOutputType | null
  }

  export type AssetCommentAvgAggregateOutputType = {
    x_coord: number | null
    y_coord: number | null
  }

  export type AssetCommentSumAggregateOutputType = {
    x_coord: number | null
    y_coord: number | null
  }

  export type AssetCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    x_coord: number | null
    y_coord: number | null
    createdAt: Date | null
    asset_id: string | null
    author_id: string | null
  }

  export type AssetCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    x_coord: number | null
    y_coord: number | null
    createdAt: Date | null
    asset_id: string | null
    author_id: string | null
  }

  export type AssetCommentCountAggregateOutputType = {
    id: number
    content: number
    x_coord: number
    y_coord: number
    createdAt: number
    asset_id: number
    author_id: number
    _all: number
  }


  export type AssetCommentAvgAggregateInputType = {
    x_coord?: true
    y_coord?: true
  }

  export type AssetCommentSumAggregateInputType = {
    x_coord?: true
    y_coord?: true
  }

  export type AssetCommentMinAggregateInputType = {
    id?: true
    content?: true
    x_coord?: true
    y_coord?: true
    createdAt?: true
    asset_id?: true
    author_id?: true
  }

  export type AssetCommentMaxAggregateInputType = {
    id?: true
    content?: true
    x_coord?: true
    y_coord?: true
    createdAt?: true
    asset_id?: true
    author_id?: true
  }

  export type AssetCommentCountAggregateInputType = {
    id?: true
    content?: true
    x_coord?: true
    y_coord?: true
    createdAt?: true
    asset_id?: true
    author_id?: true
    _all?: true
  }

  export type AssetCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetComment to aggregate.
     */
    where?: AssetCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetComments to fetch.
     */
    orderBy?: AssetCommentOrderByWithRelationInput | AssetCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetComments
    **/
    _count?: true | AssetCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetCommentMaxAggregateInputType
  }

  export type GetAssetCommentAggregateType<T extends AssetCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetComment[P]>
      : GetScalarType<T[P], AggregateAssetComment[P]>
  }




  export type AssetCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCommentWhereInput
    orderBy?: AssetCommentOrderByWithAggregationInput | AssetCommentOrderByWithAggregationInput[]
    by: AssetCommentScalarFieldEnum[] | AssetCommentScalarFieldEnum
    having?: AssetCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCommentCountAggregateInputType | true
    _avg?: AssetCommentAvgAggregateInputType
    _sum?: AssetCommentSumAggregateInputType
    _min?: AssetCommentMinAggregateInputType
    _max?: AssetCommentMaxAggregateInputType
  }

  export type AssetCommentGroupByOutputType = {
    id: string
    content: string
    x_coord: number | null
    y_coord: number | null
    createdAt: Date
    asset_id: string
    author_id: string
    _count: AssetCommentCountAggregateOutputType | null
    _avg: AssetCommentAvgAggregateOutputType | null
    _sum: AssetCommentSumAggregateOutputType | null
    _min: AssetCommentMinAggregateOutputType | null
    _max: AssetCommentMaxAggregateOutputType | null
  }

  type GetAssetCommentGroupByPayload<T extends AssetCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetCommentGroupByOutputType[P]>
            : GetScalarType<T[P], AssetCommentGroupByOutputType[P]>
        }
      >
    >


  export type AssetCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    x_coord?: boolean
    y_coord?: boolean
    createdAt?: boolean
    asset_id?: boolean
    author_id?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetComment"]>

  export type AssetCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    x_coord?: boolean
    y_coord?: boolean
    createdAt?: boolean
    asset_id?: boolean
    author_id?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetComment"]>

  export type AssetCommentSelectScalar = {
    id?: boolean
    content?: boolean
    x_coord?: boolean
    y_coord?: boolean
    createdAt?: boolean
    asset_id?: boolean
    author_id?: boolean
  }

  export type AssetCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssetCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssetCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetComment"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      x_coord: number | null
      y_coord: number | null
      createdAt: Date
      asset_id: string
      author_id: string
    }, ExtArgs["result"]["assetComment"]>
    composites: {}
  }

  type AssetCommentGetPayload<S extends boolean | null | undefined | AssetCommentDefaultArgs> = $Result.GetResult<Prisma.$AssetCommentPayload, S>

  type AssetCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCommentCountAggregateInputType | true
    }

  export interface AssetCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetComment'], meta: { name: 'AssetComment' } }
    /**
     * Find zero or one AssetComment that matches the filter.
     * @param {AssetCommentFindUniqueArgs} args - Arguments to find a AssetComment
     * @example
     * // Get one AssetComment
     * const assetComment = await prisma.assetComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetCommentFindUniqueArgs>(args: SelectSubset<T, AssetCommentFindUniqueArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssetComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetCommentFindUniqueOrThrowArgs} args - Arguments to find a AssetComment
     * @example
     * // Get one AssetComment
     * const assetComment = await prisma.assetComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssetComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentFindFirstArgs} args - Arguments to find a AssetComment
     * @example
     * // Get one AssetComment
     * const assetComment = await prisma.assetComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetCommentFindFirstArgs>(args?: SelectSubset<T, AssetCommentFindFirstArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssetComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentFindFirstOrThrowArgs} args - Arguments to find a AssetComment
     * @example
     * // Get one AssetComment
     * const assetComment = await prisma.assetComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssetComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetComments
     * const assetComments = await prisma.assetComment.findMany()
     * 
     * // Get first 10 AssetComments
     * const assetComments = await prisma.assetComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetCommentWithIdOnly = await prisma.assetComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetCommentFindManyArgs>(args?: SelectSubset<T, AssetCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssetComment.
     * @param {AssetCommentCreateArgs} args - Arguments to create a AssetComment.
     * @example
     * // Create one AssetComment
     * const AssetComment = await prisma.assetComment.create({
     *   data: {
     *     // ... data to create a AssetComment
     *   }
     * })
     * 
     */
    create<T extends AssetCommentCreateArgs>(args: SelectSubset<T, AssetCommentCreateArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssetComments.
     * @param {AssetCommentCreateManyArgs} args - Arguments to create many AssetComments.
     * @example
     * // Create many AssetComments
     * const assetComment = await prisma.assetComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCommentCreateManyArgs>(args?: SelectSubset<T, AssetCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetComments and returns the data saved in the database.
     * @param {AssetCommentCreateManyAndReturnArgs} args - Arguments to create many AssetComments.
     * @example
     * // Create many AssetComments
     * const assetComment = await prisma.assetComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetComments and only return the `id`
     * const assetCommentWithIdOnly = await prisma.assetComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssetComment.
     * @param {AssetCommentDeleteArgs} args - Arguments to delete one AssetComment.
     * @example
     * // Delete one AssetComment
     * const AssetComment = await prisma.assetComment.delete({
     *   where: {
     *     // ... filter to delete one AssetComment
     *   }
     * })
     * 
     */
    delete<T extends AssetCommentDeleteArgs>(args: SelectSubset<T, AssetCommentDeleteArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssetComment.
     * @param {AssetCommentUpdateArgs} args - Arguments to update one AssetComment.
     * @example
     * // Update one AssetComment
     * const assetComment = await prisma.assetComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetCommentUpdateArgs>(args: SelectSubset<T, AssetCommentUpdateArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssetComments.
     * @param {AssetCommentDeleteManyArgs} args - Arguments to filter AssetComments to delete.
     * @example
     * // Delete a few AssetComments
     * const { count } = await prisma.assetComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetCommentDeleteManyArgs>(args?: SelectSubset<T, AssetCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetComments
     * const assetComment = await prisma.assetComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetCommentUpdateManyArgs>(args: SelectSubset<T, AssetCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetComment.
     * @param {AssetCommentUpsertArgs} args - Arguments to update or create a AssetComment.
     * @example
     * // Update or create a AssetComment
     * const assetComment = await prisma.assetComment.upsert({
     *   create: {
     *     // ... data to create a AssetComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetComment we want to update
     *   }
     * })
     */
    upsert<T extends AssetCommentUpsertArgs>(args: SelectSubset<T, AssetCommentUpsertArgs<ExtArgs>>): Prisma__AssetCommentClient<$Result.GetResult<Prisma.$AssetCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssetComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentCountArgs} args - Arguments to filter AssetComments to count.
     * @example
     * // Count the number of AssetComments
     * const count = await prisma.assetComment.count({
     *   where: {
     *     // ... the filter for the AssetComments we want to count
     *   }
     * })
    **/
    count<T extends AssetCommentCountArgs>(
      args?: Subset<T, AssetCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetCommentAggregateArgs>(args: Subset<T, AssetCommentAggregateArgs>): Prisma.PrismaPromise<GetAssetCommentAggregateType<T>>

    /**
     * Group by AssetComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetCommentGroupByArgs['orderBy'] }
        : { orderBy?: AssetCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetComment model
   */
  readonly fields: AssetCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetComment model
   */ 
  interface AssetCommentFieldRefs {
    readonly id: FieldRef<"AssetComment", 'String'>
    readonly content: FieldRef<"AssetComment", 'String'>
    readonly x_coord: FieldRef<"AssetComment", 'Float'>
    readonly y_coord: FieldRef<"AssetComment", 'Float'>
    readonly createdAt: FieldRef<"AssetComment", 'DateTime'>
    readonly asset_id: FieldRef<"AssetComment", 'String'>
    readonly author_id: FieldRef<"AssetComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssetComment findUnique
   */
  export type AssetCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * Filter, which AssetComment to fetch.
     */
    where: AssetCommentWhereUniqueInput
  }

  /**
   * AssetComment findUniqueOrThrow
   */
  export type AssetCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * Filter, which AssetComment to fetch.
     */
    where: AssetCommentWhereUniqueInput
  }

  /**
   * AssetComment findFirst
   */
  export type AssetCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * Filter, which AssetComment to fetch.
     */
    where?: AssetCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetComments to fetch.
     */
    orderBy?: AssetCommentOrderByWithRelationInput | AssetCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetComments.
     */
    cursor?: AssetCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetComments.
     */
    distinct?: AssetCommentScalarFieldEnum | AssetCommentScalarFieldEnum[]
  }

  /**
   * AssetComment findFirstOrThrow
   */
  export type AssetCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * Filter, which AssetComment to fetch.
     */
    where?: AssetCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetComments to fetch.
     */
    orderBy?: AssetCommentOrderByWithRelationInput | AssetCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetComments.
     */
    cursor?: AssetCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetComments.
     */
    distinct?: AssetCommentScalarFieldEnum | AssetCommentScalarFieldEnum[]
  }

  /**
   * AssetComment findMany
   */
  export type AssetCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * Filter, which AssetComments to fetch.
     */
    where?: AssetCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetComments to fetch.
     */
    orderBy?: AssetCommentOrderByWithRelationInput | AssetCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetComments.
     */
    cursor?: AssetCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetComments.
     */
    skip?: number
    distinct?: AssetCommentScalarFieldEnum | AssetCommentScalarFieldEnum[]
  }

  /**
   * AssetComment create
   */
  export type AssetCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetComment.
     */
    data: XOR<AssetCommentCreateInput, AssetCommentUncheckedCreateInput>
  }

  /**
   * AssetComment createMany
   */
  export type AssetCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetComments.
     */
    data: AssetCommentCreateManyInput | AssetCommentCreateManyInput[]
  }

  /**
   * AssetComment createManyAndReturn
   */
  export type AssetCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssetComments.
     */
    data: AssetCommentCreateManyInput | AssetCommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetComment update
   */
  export type AssetCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetComment.
     */
    data: XOR<AssetCommentUpdateInput, AssetCommentUncheckedUpdateInput>
    /**
     * Choose, which AssetComment to update.
     */
    where: AssetCommentWhereUniqueInput
  }

  /**
   * AssetComment updateMany
   */
  export type AssetCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetComments.
     */
    data: XOR<AssetCommentUpdateManyMutationInput, AssetCommentUncheckedUpdateManyInput>
    /**
     * Filter which AssetComments to update
     */
    where?: AssetCommentWhereInput
  }

  /**
   * AssetComment upsert
   */
  export type AssetCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetComment to update in case it exists.
     */
    where: AssetCommentWhereUniqueInput
    /**
     * In case the AssetComment found by the `where` argument doesn't exist, create a new AssetComment with this data.
     */
    create: XOR<AssetCommentCreateInput, AssetCommentUncheckedCreateInput>
    /**
     * In case the AssetComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetCommentUpdateInput, AssetCommentUncheckedUpdateInput>
  }

  /**
   * AssetComment delete
   */
  export type AssetCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
    /**
     * Filter which AssetComment to delete.
     */
    where: AssetCommentWhereUniqueInput
  }

  /**
   * AssetComment deleteMany
   */
  export type AssetCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetComments to delete
     */
    where?: AssetCommentWhereInput
  }

  /**
   * AssetComment without action
   */
  export type AssetCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetComment
     */
    select?: AssetCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCommentInclude<ExtArgs> | null
  }


  /**
   * Model TimeLog
   */

  export type AggregateTimeLog = {
    _count: TimeLogCountAggregateOutputType | null
    _avg: TimeLogAvgAggregateOutputType | null
    _sum: TimeLogSumAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  export type TimeLogAvgAggregateOutputType = {
    duration_minutes: number | null
  }

  export type TimeLogSumAggregateOutputType = {
    duration_minutes: number | null
  }

  export type TimeLogMinAggregateOutputType = {
    id: string | null
    start_time: Date | null
    end_time: Date | null
    duration_minutes: number | null
    createdAt: Date | null
    task_id: string | null
    user_id: string | null
  }

  export type TimeLogMaxAggregateOutputType = {
    id: string | null
    start_time: Date | null
    end_time: Date | null
    duration_minutes: number | null
    createdAt: Date | null
    task_id: string | null
    user_id: string | null
  }

  export type TimeLogCountAggregateOutputType = {
    id: number
    start_time: number
    end_time: number
    duration_minutes: number
    createdAt: number
    task_id: number
    user_id: number
    _all: number
  }


  export type TimeLogAvgAggregateInputType = {
    duration_minutes?: true
  }

  export type TimeLogSumAggregateInputType = {
    duration_minutes?: true
  }

  export type TimeLogMinAggregateInputType = {
    id?: true
    start_time?: true
    end_time?: true
    duration_minutes?: true
    createdAt?: true
    task_id?: true
    user_id?: true
  }

  export type TimeLogMaxAggregateInputType = {
    id?: true
    start_time?: true
    end_time?: true
    duration_minutes?: true
    createdAt?: true
    task_id?: true
    user_id?: true
  }

  export type TimeLogCountAggregateInputType = {
    id?: true
    start_time?: true
    end_time?: true
    duration_minutes?: true
    createdAt?: true
    task_id?: true
    user_id?: true
    _all?: true
  }

  export type TimeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLog to aggregate.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeLogs
    **/
    _count?: true | TimeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeLogMaxAggregateInputType
  }

  export type GetTimeLogAggregateType<T extends TimeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeLog[P]>
      : GetScalarType<T[P], AggregateTimeLog[P]>
  }




  export type TimeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithAggregationInput | TimeLogOrderByWithAggregationInput[]
    by: TimeLogScalarFieldEnum[] | TimeLogScalarFieldEnum
    having?: TimeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeLogCountAggregateInputType | true
    _avg?: TimeLogAvgAggregateInputType
    _sum?: TimeLogSumAggregateInputType
    _min?: TimeLogMinAggregateInputType
    _max?: TimeLogMaxAggregateInputType
  }

  export type TimeLogGroupByOutputType = {
    id: string
    start_time: Date
    end_time: Date | null
    duration_minutes: number | null
    createdAt: Date
    task_id: string
    user_id: string
    _count: TimeLogCountAggregateOutputType | null
    _avg: TimeLogAvgAggregateOutputType | null
    _sum: TimeLogSumAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  type GetTimeLogGroupByPayload<T extends TimeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
        }
      >
    >


  export type TimeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_time?: boolean
    end_time?: boolean
    duration_minutes?: boolean
    createdAt?: boolean
    task_id?: boolean
    user_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_time?: boolean
    end_time?: boolean
    duration_minutes?: boolean
    createdAt?: boolean
    task_id?: boolean
    user_id?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectScalar = {
    id?: boolean
    start_time?: boolean
    end_time?: boolean
    duration_minutes?: boolean
    createdAt?: boolean
    task_id?: boolean
    user_id?: boolean
  }

  export type TimeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeLog"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      start_time: Date
      end_time: Date | null
      duration_minutes: number | null
      createdAt: Date
      task_id: string
      user_id: string
    }, ExtArgs["result"]["timeLog"]>
    composites: {}
  }

  type TimeLogGetPayload<S extends boolean | null | undefined | TimeLogDefaultArgs> = $Result.GetResult<Prisma.$TimeLogPayload, S>

  type TimeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeLogCountAggregateInputType | true
    }

  export interface TimeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeLog'], meta: { name: 'TimeLog' } }
    /**
     * Find zero or one TimeLog that matches the filter.
     * @param {TimeLogFindUniqueArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeLogFindUniqueArgs>(args: SelectSubset<T, TimeLogFindUniqueArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeLogFindUniqueOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeLogFindFirstArgs>(args?: SelectSubset<T, TimeLogFindFirstArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeLogs
     * const timeLogs = await prisma.timeLog.findMany()
     * 
     * // Get first 10 TimeLogs
     * const timeLogs = await prisma.timeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeLogFindManyArgs>(args?: SelectSubset<T, TimeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeLog.
     * @param {TimeLogCreateArgs} args - Arguments to create a TimeLog.
     * @example
     * // Create one TimeLog
     * const TimeLog = await prisma.timeLog.create({
     *   data: {
     *     // ... data to create a TimeLog
     *   }
     * })
     * 
     */
    create<T extends TimeLogCreateArgs>(args: SelectSubset<T, TimeLogCreateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeLogs.
     * @param {TimeLogCreateManyArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeLogCreateManyArgs>(args?: SelectSubset<T, TimeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeLogs and returns the data saved in the database.
     * @param {TimeLogCreateManyAndReturnArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeLogs and only return the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeLog.
     * @param {TimeLogDeleteArgs} args - Arguments to delete one TimeLog.
     * @example
     * // Delete one TimeLog
     * const TimeLog = await prisma.timeLog.delete({
     *   where: {
     *     // ... filter to delete one TimeLog
     *   }
     * })
     * 
     */
    delete<T extends TimeLogDeleteArgs>(args: SelectSubset<T, TimeLogDeleteArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeLog.
     * @param {TimeLogUpdateArgs} args - Arguments to update one TimeLog.
     * @example
     * // Update one TimeLog
     * const timeLog = await prisma.timeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeLogUpdateArgs>(args: SelectSubset<T, TimeLogUpdateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeLogs.
     * @param {TimeLogDeleteManyArgs} args - Arguments to filter TimeLogs to delete.
     * @example
     * // Delete a few TimeLogs
     * const { count } = await prisma.timeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeLogDeleteManyArgs>(args?: SelectSubset<T, TimeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeLogs
     * const timeLog = await prisma.timeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeLogUpdateManyArgs>(args: SelectSubset<T, TimeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeLog.
     * @param {TimeLogUpsertArgs} args - Arguments to update or create a TimeLog.
     * @example
     * // Update or create a TimeLog
     * const timeLog = await prisma.timeLog.upsert({
     *   create: {
     *     // ... data to create a TimeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeLog we want to update
     *   }
     * })
     */
    upsert<T extends TimeLogUpsertArgs>(args: SelectSubset<T, TimeLogUpsertArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogCountArgs} args - Arguments to filter TimeLogs to count.
     * @example
     * // Count the number of TimeLogs
     * const count = await prisma.timeLog.count({
     *   where: {
     *     // ... the filter for the TimeLogs we want to count
     *   }
     * })
    **/
    count<T extends TimeLogCountArgs>(
      args?: Subset<T, TimeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeLogAggregateArgs>(args: Subset<T, TimeLogAggregateArgs>): Prisma.PrismaPromise<GetTimeLogAggregateType<T>>

    /**
     * Group by TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeLogGroupByArgs['orderBy'] }
        : { orderBy?: TimeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeLog model
   */
  readonly fields: TimeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeLog model
   */ 
  interface TimeLogFieldRefs {
    readonly id: FieldRef<"TimeLog", 'String'>
    readonly start_time: FieldRef<"TimeLog", 'DateTime'>
    readonly end_time: FieldRef<"TimeLog", 'DateTime'>
    readonly duration_minutes: FieldRef<"TimeLog", 'Int'>
    readonly createdAt: FieldRef<"TimeLog", 'DateTime'>
    readonly task_id: FieldRef<"TimeLog", 'String'>
    readonly user_id: FieldRef<"TimeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeLog findUnique
   */
  export type TimeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findUniqueOrThrow
   */
  export type TimeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findFirst
   */
  export type TimeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findFirstOrThrow
   */
  export type TimeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findMany
   */
  export type TimeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLogs to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog create
   */
  export type TimeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeLog.
     */
    data: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
  }

  /**
   * TimeLog createMany
   */
  export type TimeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
  }

  /**
   * TimeLog createManyAndReturn
   */
  export type TimeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeLog update
   */
  export type TimeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeLog.
     */
    data: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
    /**
     * Choose, which TimeLog to update.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog updateMany
   */
  export type TimeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeLogs.
     */
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeLogs to update
     */
    where?: TimeLogWhereInput
  }

  /**
   * TimeLog upsert
   */
  export type TimeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeLog to update in case it exists.
     */
    where: TimeLogWhereUniqueInput
    /**
     * In case the TimeLog found by the `where` argument doesn't exist, create a new TimeLog with this data.
     */
    create: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
    /**
     * In case the TimeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
  }

  /**
   * TimeLog delete
   */
  export type TimeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter which TimeLog to delete.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog deleteMany
   */
  export type TimeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLogs to delete
     */
    where?: TimeLogWhereInput
  }

  /**
   * TimeLog without action
   */
  export type TimeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    message: string | null
    read: boolean | null
    link: string | null
    createdAt: Date | null
    user_id: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    message: string | null
    read: boolean | null
    link: string | null
    createdAt: Date | null
    user_id: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    message: number
    read: number
    link: number
    createdAt: number
    user_id: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    message?: true
    read?: true
    link?: true
    createdAt?: true
    user_id?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    message?: true
    read?: true
    link?: true
    createdAt?: true
    user_id?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    message?: true
    read?: true
    link?: true
    createdAt?: true
    user_id?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string
    message: string
    read: boolean
    link: string | null
    createdAt: Date
    user_id: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    link?: boolean
    createdAt?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    link?: boolean
    createdAt?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    link?: boolean
    createdAt?: boolean
    user_id?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      message: string
      read: boolean
      link: string | null
      createdAt: Date
      user_id: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly user_id: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    full_name: 'full_name',
    designation: 'designation',
    role: 'role',
    department: 'department',
    avatar_url: 'avatar_url',
    staff_id_number: 'staff_id_number',
    joining_date: 'joining_date',
    dob: 'dob',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand_colors: 'brand_colors',
    logo_url: 'logo_url',
    industry: 'industry',
    contract_type: 'contract_type',
    client_number: 'client_number',
    onboarding_date: 'onboarding_date',
    address: 'address',
    contact_person: 'contact_person',
    contact_number: 'contact_number',
    website: 'website',
    email: 'email',
    whatsapp: 'whatsapp',
    facebook: 'facebook',
    instagram: 'instagram',
    linkedin: 'linkedin',
    youtube: 'youtube',
    competitorDetails: 'competitorDetails',
    customerAvatar: 'customerAvatar',
    contentSuggestions: 'contentSuggestions',
    referenceLinks: 'referenceLinks',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    account_manager_id: 'account_manager_id'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ContentCalendarScalarFieldEnum: {
    id: 'id',
    date: 'date',
    creativeType: 'creativeType',
    quantity: 'quantity',
    completed: 'completed',
    inProgress: 'inProgress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    client_id: 'client_id'
  };

  export type ContentCalendarScalarFieldEnum = (typeof ContentCalendarScalarFieldEnum)[keyof typeof ContentCalendarScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    title: 'title',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    budget: 'budget',
    goals: 'goals',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    client_id: 'client_id'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const AdAccountScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    external_id: 'external_id',
    status: 'status',
    currency: 'currency',
    client_id: 'client_id'
  };

  export type AdAccountScalarFieldEnum = (typeof AdAccountScalarFieldEnum)[keyof typeof AdAccountScalarFieldEnum]


  export const AdGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    external_id: 'external_id',
    status: 'status',
    campaign_id: 'campaign_id',
    ad_account_id: 'ad_account_id'
  };

  export type AdGroupScalarFieldEnum = (typeof AdGroupScalarFieldEnum)[keyof typeof AdGroupScalarFieldEnum]


  export const AdScalarFieldEnum: {
    id: 'id',
    name: 'name',
    external_id: 'external_id',
    status: 'status',
    type: 'type',
    ad_group_id: 'ad_group_id',
    creative_id: 'creative_id'
  };

  export type AdScalarFieldEnum = (typeof AdScalarFieldEnum)[keyof typeof AdScalarFieldEnum]


  export const SpendSnapshotScalarFieldEnum: {
    id: 'id',
    date: 'date',
    ad_id: 'ad_id',
    spend: 'spend',
    impressions: 'impressions',
    clicks: 'clicks',
    conversions: 'conversions',
    revenue: 'revenue',
    platform_data: 'platform_data',
    createdAt: 'createdAt'
  };

  export type SpendSnapshotScalarFieldEnum = (typeof SpendSnapshotScalarFieldEnum)[keyof typeof SpendSnapshotScalarFieldEnum]


  export const CampaignMetricScalarFieldEnum: {
    id: 'id',
    date: 'date',
    campaign_id: 'campaign_id',
    spend: 'spend',
    impressions: 'impressions',
    clicks: 'clicks',
    conversions: 'conversions',
    revenue: 'revenue'
  };

  export type CampaignMetricScalarFieldEnum = (typeof CampaignMetricScalarFieldEnum)[keyof typeof CampaignMetricScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entity: 'entity',
    entity_id: 'entity_id',
    user_id: 'user_id',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AccountHeadScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    is_system: 'is_system'
  };

  export type AccountHeadScalarFieldEnum = (typeof AccountHeadScalarFieldEnum)[keyof typeof AccountHeadScalarFieldEnum]


  export const LedgerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    account_head_id: 'account_head_id',
    client_id: 'client_id',
    balance: 'balance',
    updatedAt: 'updatedAt'
  };

  export type LedgerScalarFieldEnum = (typeof LedgerScalarFieldEnum)[keyof typeof LedgerScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    description: 'description',
    reference: 'reference',
    type: 'type',
    createdAt: 'createdAt',
    created_by: 'created_by'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const JournalLineScalarFieldEnum: {
    id: 'id',
    entry_id: 'entry_id',
    account_id: 'account_id',
    debit: 'debit',
    credit: 'credit',
    description: 'description',
    invoice_id: 'invoice_id'
  };

  export type JournalLineScalarFieldEnum = (typeof JournalLineScalarFieldEnum)[keyof typeof JournalLineScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    due_date: 'due_date',
    status: 'status',
    client_id: 'client_id',
    subtotal: 'subtotal',
    tax_rate: 'tax_rate',
    tax_amount: 'tax_amount',
    total: 'total',
    journal_entry_id: 'journal_entry_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    quantity: 'quantity',
    unit_price: 'unit_price',
    amount: 'amount',
    invoice_id: 'invoice_id'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    type: 'type',
    category: 'category',
    platform: 'platform',
    due_date: 'due_date',
    start_date: 'start_date',
    actual_start_date: 'actual_start_date',
    completed_date: 'completed_date',
    estimated_hours: 'estimated_hours',
    time_estimate: 'time_estimate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    campaign_id: 'campaign_id',
    client_id: 'client_id',
    parent_task_id: 'parent_task_id',
    assignee_id: 'assignee_id',
    reporter_id: 'reporter_id'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskDependencyScalarFieldEnum: {
    id: 'id',
    blocking_task_id: 'blocking_task_id',
    blocked_task_id: 'blocked_task_id',
    createdAt: 'createdAt'
  };

  export type TaskDependencyScalarFieldEnum = (typeof TaskDependencyScalarFieldEnum)[keyof typeof TaskDependencyScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    original_name: 'original_name',
    file_url: 'file_url',
    file_type: 'file_type',
    size_bytes: 'size_bytes',
    version: 'version',
    is_approved: 'is_approved',
    createdAt: 'createdAt',
    task_id: 'task_id',
    uploader_id: 'uploader_id'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    is_revision_request: 'is_revision_request',
    createdAt: 'createdAt',
    task_id: 'task_id',
    author_id: 'author_id',
    parent_comment_id: 'parent_comment_id'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const AssetCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    x_coord: 'x_coord',
    y_coord: 'y_coord',
    createdAt: 'createdAt',
    asset_id: 'asset_id',
    author_id: 'author_id'
  };

  export type AssetCommentScalarFieldEnum = (typeof AssetCommentScalarFieldEnum)[keyof typeof AssetCommentScalarFieldEnum]


  export const TimeLogScalarFieldEnum: {
    id: 'id',
    start_time: 'start_time',
    end_time: 'end_time',
    duration_minutes: 'duration_minutes',
    createdAt: 'createdAt',
    task_id: 'task_id',
    user_id: 'user_id'
  };

  export type TimeLogScalarFieldEnum = (typeof TimeLogScalarFieldEnum)[keyof typeof TimeLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    message: 'message',
    read: 'read',
    link: 'link',
    createdAt: 'createdAt',
    user_id: 'user_id'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    full_name?: StringFilter<"User"> | string
    designation?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    department?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    staff_id_number?: StringNullableFilter<"User"> | string | null
    joining_date?: DateTimeNullableFilter<"User"> | Date | string | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientsManaged?: ClientListRelationFilter
    tasksAssigned?: TaskListRelationFilter
    tasksReported?: TaskListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    comments?: CommentListRelationFilter
    notifications?: NotificationListRelationFilter
    assetsUploaded?: AssetListRelationFilter
    assetComments?: AssetCommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    designation?: SortOrderInput | SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    staff_id_number?: SortOrderInput | SortOrder
    joining_date?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientsManaged?: ClientOrderByRelationAggregateInput
    tasksAssigned?: TaskOrderByRelationAggregateInput
    tasksReported?: TaskOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    assetsUploaded?: AssetOrderByRelationAggregateInput
    assetComments?: AssetCommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    staff_id_number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    full_name?: StringFilter<"User"> | string
    designation?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    department?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    joining_date?: DateTimeNullableFilter<"User"> | Date | string | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    address?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clientsManaged?: ClientListRelationFilter
    tasksAssigned?: TaskListRelationFilter
    tasksReported?: TaskListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    comments?: CommentListRelationFilter
    notifications?: NotificationListRelationFilter
    assetsUploaded?: AssetListRelationFilter
    assetComments?: AssetCommentListRelationFilter
  }, "id" | "email" | "staff_id_number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    designation?: SortOrderInput | SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    staff_id_number?: SortOrderInput | SortOrder
    joining_date?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    full_name?: StringWithAggregatesFilter<"User"> | string
    designation?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    department?: StringWithAggregatesFilter<"User"> | string
    avatar_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    staff_id_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    joining_date?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    brand_colors?: StringNullableFilter<"Client"> | string | null
    logo_url?: StringNullableFilter<"Client"> | string | null
    industry?: StringNullableFilter<"Client"> | string | null
    contract_type?: StringNullableFilter<"Client"> | string | null
    client_number?: StringNullableFilter<"Client"> | string | null
    onboarding_date?: DateTimeNullableFilter<"Client"> | Date | string | null
    address?: StringNullableFilter<"Client"> | string | null
    contact_person?: StringNullableFilter<"Client"> | string | null
    contact_number?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    whatsapp?: StringNullableFilter<"Client"> | string | null
    facebook?: StringNullableFilter<"Client"> | string | null
    instagram?: StringNullableFilter<"Client"> | string | null
    linkedin?: StringNullableFilter<"Client"> | string | null
    youtube?: StringNullableFilter<"Client"> | string | null
    competitorDetails?: StringNullableFilter<"Client"> | string | null
    customerAvatar?: StringNullableFilter<"Client"> | string | null
    contentSuggestions?: StringNullableFilter<"Client"> | string | null
    referenceLinks?: StringNullableFilter<"Client"> | string | null
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    account_manager_id?: StringNullableFilter<"Client"> | string | null
    account_manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    campaigns?: CampaignListRelationFilter
    tasks?: TaskListRelationFilter
    ad_accounts?: AdAccountListRelationFilter
    contentCalendars?: ContentCalendarListRelationFilter
    ledgers?: LedgerListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand_colors?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    contract_type?: SortOrderInput | SortOrder
    client_number?: SortOrderInput | SortOrder
    onboarding_date?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contact_person?: SortOrderInput | SortOrder
    contact_number?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    competitorDetails?: SortOrderInput | SortOrder
    customerAvatar?: SortOrderInput | SortOrder
    contentSuggestions?: SortOrderInput | SortOrder
    referenceLinks?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account_manager_id?: SortOrderInput | SortOrder
    account_manager?: UserOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    ad_accounts?: AdAccountOrderByRelationAggregateInput
    contentCalendars?: ContentCalendarOrderByRelationAggregateInput
    ledgers?: LedgerOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    client_number?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    brand_colors?: StringNullableFilter<"Client"> | string | null
    logo_url?: StringNullableFilter<"Client"> | string | null
    industry?: StringNullableFilter<"Client"> | string | null
    contract_type?: StringNullableFilter<"Client"> | string | null
    onboarding_date?: DateTimeNullableFilter<"Client"> | Date | string | null
    address?: StringNullableFilter<"Client"> | string | null
    contact_person?: StringNullableFilter<"Client"> | string | null
    contact_number?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    whatsapp?: StringNullableFilter<"Client"> | string | null
    facebook?: StringNullableFilter<"Client"> | string | null
    instagram?: StringNullableFilter<"Client"> | string | null
    linkedin?: StringNullableFilter<"Client"> | string | null
    youtube?: StringNullableFilter<"Client"> | string | null
    competitorDetails?: StringNullableFilter<"Client"> | string | null
    customerAvatar?: StringNullableFilter<"Client"> | string | null
    contentSuggestions?: StringNullableFilter<"Client"> | string | null
    referenceLinks?: StringNullableFilter<"Client"> | string | null
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    account_manager_id?: StringNullableFilter<"Client"> | string | null
    account_manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    campaigns?: CampaignListRelationFilter
    tasks?: TaskListRelationFilter
    ad_accounts?: AdAccountListRelationFilter
    contentCalendars?: ContentCalendarListRelationFilter
    ledgers?: LedgerListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "client_number">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand_colors?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    contract_type?: SortOrderInput | SortOrder
    client_number?: SortOrderInput | SortOrder
    onboarding_date?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contact_person?: SortOrderInput | SortOrder
    contact_number?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    competitorDetails?: SortOrderInput | SortOrder
    customerAvatar?: SortOrderInput | SortOrder
    contentSuggestions?: SortOrderInput | SortOrder
    referenceLinks?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account_manager_id?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    brand_colors?: StringNullableWithAggregatesFilter<"Client"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"Client"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contract_type?: StringNullableWithAggregatesFilter<"Client"> | string | null
    client_number?: StringNullableWithAggregatesFilter<"Client"> | string | null
    onboarding_date?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contact_person?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contact_number?: StringNullableWithAggregatesFilter<"Client"> | string | null
    website?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"Client"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"Client"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Client"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Client"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"Client"> | string | null
    competitorDetails?: StringNullableWithAggregatesFilter<"Client"> | string | null
    customerAvatar?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contentSuggestions?: StringNullableWithAggregatesFilter<"Client"> | string | null
    referenceLinks?: StringNullableWithAggregatesFilter<"Client"> | string | null
    status?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    account_manager_id?: StringNullableWithAggregatesFilter<"Client"> | string | null
  }

  export type ContentCalendarWhereInput = {
    AND?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    OR?: ContentCalendarWhereInput[]
    NOT?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    id?: StringFilter<"ContentCalendar"> | string
    date?: DateTimeFilter<"ContentCalendar"> | Date | string
    creativeType?: StringFilter<"ContentCalendar"> | string
    quantity?: IntFilter<"ContentCalendar"> | number
    completed?: IntFilter<"ContentCalendar"> | number
    inProgress?: IntFilter<"ContentCalendar"> | number
    createdAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    client_id?: StringFilter<"ContentCalendar"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }

  export type ContentCalendarOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    creativeType?: SortOrder
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ContentCalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    OR?: ContentCalendarWhereInput[]
    NOT?: ContentCalendarWhereInput | ContentCalendarWhereInput[]
    date?: DateTimeFilter<"ContentCalendar"> | Date | string
    creativeType?: StringFilter<"ContentCalendar"> | string
    quantity?: IntFilter<"ContentCalendar"> | number
    completed?: IntFilter<"ContentCalendar"> | number
    inProgress?: IntFilter<"ContentCalendar"> | number
    createdAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    client_id?: StringFilter<"ContentCalendar"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }, "id">

  export type ContentCalendarOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    creativeType?: SortOrder
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    _count?: ContentCalendarCountOrderByAggregateInput
    _avg?: ContentCalendarAvgOrderByAggregateInput
    _max?: ContentCalendarMaxOrderByAggregateInput
    _min?: ContentCalendarMinOrderByAggregateInput
    _sum?: ContentCalendarSumOrderByAggregateInput
  }

  export type ContentCalendarScalarWhereWithAggregatesInput = {
    AND?: ContentCalendarScalarWhereWithAggregatesInput | ContentCalendarScalarWhereWithAggregatesInput[]
    OR?: ContentCalendarScalarWhereWithAggregatesInput[]
    NOT?: ContentCalendarScalarWhereWithAggregatesInput | ContentCalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentCalendar"> | string
    date?: DateTimeWithAggregatesFilter<"ContentCalendar"> | Date | string
    creativeType?: StringWithAggregatesFilter<"ContentCalendar"> | string
    quantity?: IntWithAggregatesFilter<"ContentCalendar"> | number
    completed?: IntWithAggregatesFilter<"ContentCalendar"> | number
    inProgress?: IntWithAggregatesFilter<"ContentCalendar"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContentCalendar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentCalendar"> | Date | string
    client_id?: StringWithAggregatesFilter<"ContentCalendar"> | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    title?: StringFilter<"Campaign"> | string
    start_date?: DateTimeFilter<"Campaign"> | Date | string
    end_date?: DateTimeFilter<"Campaign"> | Date | string
    status?: StringFilter<"Campaign"> | string
    budget?: FloatNullableFilter<"Campaign"> | number | null
    goals?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    client_id?: StringFilter<"Campaign"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    tasks?: TaskListRelationFilter
    ad_groups?: AdGroupListRelationFilter
    metrics?: CampaignMetricListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    client?: ClientOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    ad_groups?: AdGroupOrderByRelationAggregateInput
    metrics?: CampaignMetricOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    title?: StringFilter<"Campaign"> | string
    start_date?: DateTimeFilter<"Campaign"> | Date | string
    end_date?: DateTimeFilter<"Campaign"> | Date | string
    status?: StringFilter<"Campaign"> | string
    budget?: FloatNullableFilter<"Campaign"> | number | null
    goals?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    client_id?: StringFilter<"Campaign"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    tasks?: TaskListRelationFilter
    ad_groups?: AdGroupListRelationFilter
    metrics?: CampaignMetricListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    title?: StringWithAggregatesFilter<"Campaign"> | string
    start_date?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    status?: StringWithAggregatesFilter<"Campaign"> | string
    budget?: FloatNullableWithAggregatesFilter<"Campaign"> | number | null
    goals?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    client_id?: StringWithAggregatesFilter<"Campaign"> | string
  }

  export type AdAccountWhereInput = {
    AND?: AdAccountWhereInput | AdAccountWhereInput[]
    OR?: AdAccountWhereInput[]
    NOT?: AdAccountWhereInput | AdAccountWhereInput[]
    id?: StringFilter<"AdAccount"> | string
    platform?: StringFilter<"AdAccount"> | string
    external_id?: StringFilter<"AdAccount"> | string
    status?: StringFilter<"AdAccount"> | string
    currency?: StringFilter<"AdAccount"> | string
    client_id?: StringFilter<"AdAccount"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    ad_groups?: AdGroupListRelationFilter
  }

  export type AdAccountOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    client_id?: SortOrder
    client?: ClientOrderByWithRelationInput
    ad_groups?: AdGroupOrderByRelationAggregateInput
  }

  export type AdAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdAccountWhereInput | AdAccountWhereInput[]
    OR?: AdAccountWhereInput[]
    NOT?: AdAccountWhereInput | AdAccountWhereInput[]
    platform?: StringFilter<"AdAccount"> | string
    external_id?: StringFilter<"AdAccount"> | string
    status?: StringFilter<"AdAccount"> | string
    currency?: StringFilter<"AdAccount"> | string
    client_id?: StringFilter<"AdAccount"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    ad_groups?: AdGroupListRelationFilter
  }, "id">

  export type AdAccountOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    client_id?: SortOrder
    _count?: AdAccountCountOrderByAggregateInput
    _max?: AdAccountMaxOrderByAggregateInput
    _min?: AdAccountMinOrderByAggregateInput
  }

  export type AdAccountScalarWhereWithAggregatesInput = {
    AND?: AdAccountScalarWhereWithAggregatesInput | AdAccountScalarWhereWithAggregatesInput[]
    OR?: AdAccountScalarWhereWithAggregatesInput[]
    NOT?: AdAccountScalarWhereWithAggregatesInput | AdAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdAccount"> | string
    platform?: StringWithAggregatesFilter<"AdAccount"> | string
    external_id?: StringWithAggregatesFilter<"AdAccount"> | string
    status?: StringWithAggregatesFilter<"AdAccount"> | string
    currency?: StringWithAggregatesFilter<"AdAccount"> | string
    client_id?: StringWithAggregatesFilter<"AdAccount"> | string
  }

  export type AdGroupWhereInput = {
    AND?: AdGroupWhereInput | AdGroupWhereInput[]
    OR?: AdGroupWhereInput[]
    NOT?: AdGroupWhereInput | AdGroupWhereInput[]
    id?: StringFilter<"AdGroup"> | string
    name?: StringFilter<"AdGroup"> | string
    external_id?: StringNullableFilter<"AdGroup"> | string | null
    status?: StringFilter<"AdGroup"> | string
    campaign_id?: StringFilter<"AdGroup"> | string
    ad_account_id?: StringNullableFilter<"AdGroup"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    ad_account?: XOR<AdAccountNullableRelationFilter, AdAccountWhereInput> | null
    ads?: AdListRelationFilter
  }

  export type AdGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrderInput | SortOrder
    status?: SortOrder
    campaign_id?: SortOrder
    ad_account_id?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    ad_account?: AdAccountOrderByWithRelationInput
    ads?: AdOrderByRelationAggregateInput
  }

  export type AdGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdGroupWhereInput | AdGroupWhereInput[]
    OR?: AdGroupWhereInput[]
    NOT?: AdGroupWhereInput | AdGroupWhereInput[]
    name?: StringFilter<"AdGroup"> | string
    external_id?: StringNullableFilter<"AdGroup"> | string | null
    status?: StringFilter<"AdGroup"> | string
    campaign_id?: StringFilter<"AdGroup"> | string
    ad_account_id?: StringNullableFilter<"AdGroup"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    ad_account?: XOR<AdAccountNullableRelationFilter, AdAccountWhereInput> | null
    ads?: AdListRelationFilter
  }, "id">

  export type AdGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrderInput | SortOrder
    status?: SortOrder
    campaign_id?: SortOrder
    ad_account_id?: SortOrderInput | SortOrder
    _count?: AdGroupCountOrderByAggregateInput
    _max?: AdGroupMaxOrderByAggregateInput
    _min?: AdGroupMinOrderByAggregateInput
  }

  export type AdGroupScalarWhereWithAggregatesInput = {
    AND?: AdGroupScalarWhereWithAggregatesInput | AdGroupScalarWhereWithAggregatesInput[]
    OR?: AdGroupScalarWhereWithAggregatesInput[]
    NOT?: AdGroupScalarWhereWithAggregatesInput | AdGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdGroup"> | string
    name?: StringWithAggregatesFilter<"AdGroup"> | string
    external_id?: StringNullableWithAggregatesFilter<"AdGroup"> | string | null
    status?: StringWithAggregatesFilter<"AdGroup"> | string
    campaign_id?: StringWithAggregatesFilter<"AdGroup"> | string
    ad_account_id?: StringNullableWithAggregatesFilter<"AdGroup"> | string | null
  }

  export type AdWhereInput = {
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    id?: StringFilter<"Ad"> | string
    name?: StringFilter<"Ad"> | string
    external_id?: StringNullableFilter<"Ad"> | string | null
    status?: StringFilter<"Ad"> | string
    type?: StringNullableFilter<"Ad"> | string | null
    ad_group_id?: StringFilter<"Ad"> | string
    creative_id?: StringNullableFilter<"Ad"> | string | null
    ad_group?: XOR<AdGroupRelationFilter, AdGroupWhereInput>
    creative?: XOR<AssetNullableRelationFilter, AssetWhereInput> | null
    snapshots?: SpendSnapshotListRelationFilter
  }

  export type AdOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrderInput | SortOrder
    ad_group_id?: SortOrder
    creative_id?: SortOrderInput | SortOrder
    ad_group?: AdGroupOrderByWithRelationInput
    creative?: AssetOrderByWithRelationInput
    snapshots?: SpendSnapshotOrderByRelationAggregateInput
  }

  export type AdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    name?: StringFilter<"Ad"> | string
    external_id?: StringNullableFilter<"Ad"> | string | null
    status?: StringFilter<"Ad"> | string
    type?: StringNullableFilter<"Ad"> | string | null
    ad_group_id?: StringFilter<"Ad"> | string
    creative_id?: StringNullableFilter<"Ad"> | string | null
    ad_group?: XOR<AdGroupRelationFilter, AdGroupWhereInput>
    creative?: XOR<AssetNullableRelationFilter, AssetWhereInput> | null
    snapshots?: SpendSnapshotListRelationFilter
  }, "id">

  export type AdOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrderInput | SortOrder
    ad_group_id?: SortOrder
    creative_id?: SortOrderInput | SortOrder
    _count?: AdCountOrderByAggregateInput
    _max?: AdMaxOrderByAggregateInput
    _min?: AdMinOrderByAggregateInput
  }

  export type AdScalarWhereWithAggregatesInput = {
    AND?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    OR?: AdScalarWhereWithAggregatesInput[]
    NOT?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ad"> | string
    name?: StringWithAggregatesFilter<"Ad"> | string
    external_id?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    status?: StringWithAggregatesFilter<"Ad"> | string
    type?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    ad_group_id?: StringWithAggregatesFilter<"Ad"> | string
    creative_id?: StringNullableWithAggregatesFilter<"Ad"> | string | null
  }

  export type SpendSnapshotWhereInput = {
    AND?: SpendSnapshotWhereInput | SpendSnapshotWhereInput[]
    OR?: SpendSnapshotWhereInput[]
    NOT?: SpendSnapshotWhereInput | SpendSnapshotWhereInput[]
    id?: StringFilter<"SpendSnapshot"> | string
    date?: DateTimeFilter<"SpendSnapshot"> | Date | string
    ad_id?: StringFilter<"SpendSnapshot"> | string
    spend?: FloatFilter<"SpendSnapshot"> | number
    impressions?: IntFilter<"SpendSnapshot"> | number
    clicks?: IntFilter<"SpendSnapshot"> | number
    conversions?: IntFilter<"SpendSnapshot"> | number
    revenue?: FloatFilter<"SpendSnapshot"> | number
    platform_data?: StringNullableFilter<"SpendSnapshot"> | string | null
    createdAt?: DateTimeFilter<"SpendSnapshot"> | Date | string
    ad?: XOR<AdRelationFilter, AdWhereInput>
  }

  export type SpendSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    ad_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    platform_data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ad?: AdOrderByWithRelationInput
  }

  export type SpendSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ad_id_date?: SpendSnapshotAd_idDateCompoundUniqueInput
    AND?: SpendSnapshotWhereInput | SpendSnapshotWhereInput[]
    OR?: SpendSnapshotWhereInput[]
    NOT?: SpendSnapshotWhereInput | SpendSnapshotWhereInput[]
    date?: DateTimeFilter<"SpendSnapshot"> | Date | string
    ad_id?: StringFilter<"SpendSnapshot"> | string
    spend?: FloatFilter<"SpendSnapshot"> | number
    impressions?: IntFilter<"SpendSnapshot"> | number
    clicks?: IntFilter<"SpendSnapshot"> | number
    conversions?: IntFilter<"SpendSnapshot"> | number
    revenue?: FloatFilter<"SpendSnapshot"> | number
    platform_data?: StringNullableFilter<"SpendSnapshot"> | string | null
    createdAt?: DateTimeFilter<"SpendSnapshot"> | Date | string
    ad?: XOR<AdRelationFilter, AdWhereInput>
  }, "id" | "ad_id_date">

  export type SpendSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    ad_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    platform_data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SpendSnapshotCountOrderByAggregateInput
    _avg?: SpendSnapshotAvgOrderByAggregateInput
    _max?: SpendSnapshotMaxOrderByAggregateInput
    _min?: SpendSnapshotMinOrderByAggregateInput
    _sum?: SpendSnapshotSumOrderByAggregateInput
  }

  export type SpendSnapshotScalarWhereWithAggregatesInput = {
    AND?: SpendSnapshotScalarWhereWithAggregatesInput | SpendSnapshotScalarWhereWithAggregatesInput[]
    OR?: SpendSnapshotScalarWhereWithAggregatesInput[]
    NOT?: SpendSnapshotScalarWhereWithAggregatesInput | SpendSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpendSnapshot"> | string
    date?: DateTimeWithAggregatesFilter<"SpendSnapshot"> | Date | string
    ad_id?: StringWithAggregatesFilter<"SpendSnapshot"> | string
    spend?: FloatWithAggregatesFilter<"SpendSnapshot"> | number
    impressions?: IntWithAggregatesFilter<"SpendSnapshot"> | number
    clicks?: IntWithAggregatesFilter<"SpendSnapshot"> | number
    conversions?: IntWithAggregatesFilter<"SpendSnapshot"> | number
    revenue?: FloatWithAggregatesFilter<"SpendSnapshot"> | number
    platform_data?: StringNullableWithAggregatesFilter<"SpendSnapshot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SpendSnapshot"> | Date | string
  }

  export type CampaignMetricWhereInput = {
    AND?: CampaignMetricWhereInput | CampaignMetricWhereInput[]
    OR?: CampaignMetricWhereInput[]
    NOT?: CampaignMetricWhereInput | CampaignMetricWhereInput[]
    id?: StringFilter<"CampaignMetric"> | string
    date?: DateTimeFilter<"CampaignMetric"> | Date | string
    campaign_id?: StringFilter<"CampaignMetric"> | string
    spend?: FloatFilter<"CampaignMetric"> | number
    impressions?: IntFilter<"CampaignMetric"> | number
    clicks?: IntFilter<"CampaignMetric"> | number
    conversions?: IntFilter<"CampaignMetric"> | number
    revenue?: FloatFilter<"CampaignMetric"> | number
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignMetricOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    campaign_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaign_id_date?: CampaignMetricCampaign_idDateCompoundUniqueInput
    AND?: CampaignMetricWhereInput | CampaignMetricWhereInput[]
    OR?: CampaignMetricWhereInput[]
    NOT?: CampaignMetricWhereInput | CampaignMetricWhereInput[]
    date?: DateTimeFilter<"CampaignMetric"> | Date | string
    campaign_id?: StringFilter<"CampaignMetric"> | string
    spend?: FloatFilter<"CampaignMetric"> | number
    impressions?: IntFilter<"CampaignMetric"> | number
    clicks?: IntFilter<"CampaignMetric"> | number
    conversions?: IntFilter<"CampaignMetric"> | number
    revenue?: FloatFilter<"CampaignMetric"> | number
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id" | "campaign_id_date">

  export type CampaignMetricOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    campaign_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    _count?: CampaignMetricCountOrderByAggregateInput
    _avg?: CampaignMetricAvgOrderByAggregateInput
    _max?: CampaignMetricMaxOrderByAggregateInput
    _min?: CampaignMetricMinOrderByAggregateInput
    _sum?: CampaignMetricSumOrderByAggregateInput
  }

  export type CampaignMetricScalarWhereWithAggregatesInput = {
    AND?: CampaignMetricScalarWhereWithAggregatesInput | CampaignMetricScalarWhereWithAggregatesInput[]
    OR?: CampaignMetricScalarWhereWithAggregatesInput[]
    NOT?: CampaignMetricScalarWhereWithAggregatesInput | CampaignMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignMetric"> | string
    date?: DateTimeWithAggregatesFilter<"CampaignMetric"> | Date | string
    campaign_id?: StringWithAggregatesFilter<"CampaignMetric"> | string
    spend?: FloatWithAggregatesFilter<"CampaignMetric"> | number
    impressions?: IntWithAggregatesFilter<"CampaignMetric"> | number
    clicks?: IntWithAggregatesFilter<"CampaignMetric"> | number
    conversions?: IntWithAggregatesFilter<"CampaignMetric"> | number
    revenue?: FloatWithAggregatesFilter<"CampaignMetric"> | number
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entity_id?: StringFilter<"AuditLog"> | string
    user_id?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    user_id?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entity_id?: StringFilter<"AuditLog"> | string
    user_id?: StringFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    user_id?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entity_id?: StringWithAggregatesFilter<"AuditLog"> | string
    user_id?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AccountHeadWhereInput = {
    AND?: AccountHeadWhereInput | AccountHeadWhereInput[]
    OR?: AccountHeadWhereInput[]
    NOT?: AccountHeadWhereInput | AccountHeadWhereInput[]
    id?: StringFilter<"AccountHead"> | string
    code?: StringFilter<"AccountHead"> | string
    name?: StringFilter<"AccountHead"> | string
    type?: StringFilter<"AccountHead"> | string
    is_system?: BoolFilter<"AccountHead"> | boolean
    ledgers?: LedgerListRelationFilter
    journalLines?: JournalLineListRelationFilter
  }

  export type AccountHeadOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    is_system?: SortOrder
    ledgers?: LedgerOrderByRelationAggregateInput
    journalLines?: JournalLineOrderByRelationAggregateInput
  }

  export type AccountHeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AccountHeadWhereInput | AccountHeadWhereInput[]
    OR?: AccountHeadWhereInput[]
    NOT?: AccountHeadWhereInput | AccountHeadWhereInput[]
    name?: StringFilter<"AccountHead"> | string
    type?: StringFilter<"AccountHead"> | string
    is_system?: BoolFilter<"AccountHead"> | boolean
    ledgers?: LedgerListRelationFilter
    journalLines?: JournalLineListRelationFilter
  }, "id" | "code">

  export type AccountHeadOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    is_system?: SortOrder
    _count?: AccountHeadCountOrderByAggregateInput
    _max?: AccountHeadMaxOrderByAggregateInput
    _min?: AccountHeadMinOrderByAggregateInput
  }

  export type AccountHeadScalarWhereWithAggregatesInput = {
    AND?: AccountHeadScalarWhereWithAggregatesInput | AccountHeadScalarWhereWithAggregatesInput[]
    OR?: AccountHeadScalarWhereWithAggregatesInput[]
    NOT?: AccountHeadScalarWhereWithAggregatesInput | AccountHeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountHead"> | string
    code?: StringWithAggregatesFilter<"AccountHead"> | string
    name?: StringWithAggregatesFilter<"AccountHead"> | string
    type?: StringWithAggregatesFilter<"AccountHead"> | string
    is_system?: BoolWithAggregatesFilter<"AccountHead"> | boolean
  }

  export type LedgerWhereInput = {
    AND?: LedgerWhereInput | LedgerWhereInput[]
    OR?: LedgerWhereInput[]
    NOT?: LedgerWhereInput | LedgerWhereInput[]
    id?: StringFilter<"Ledger"> | string
    name?: StringFilter<"Ledger"> | string
    type?: StringFilter<"Ledger"> | string
    account_head_id?: StringFilter<"Ledger"> | string
    client_id?: StringNullableFilter<"Ledger"> | string | null
    balance?: FloatFilter<"Ledger"> | number
    updatedAt?: DateTimeFilter<"Ledger"> | Date | string
    account_head?: XOR<AccountHeadRelationFilter, AccountHeadWhereInput>
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }

  export type LedgerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    account_head_id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    account_head?: AccountHeadOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type LedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LedgerWhereInput | LedgerWhereInput[]
    OR?: LedgerWhereInput[]
    NOT?: LedgerWhereInput | LedgerWhereInput[]
    name?: StringFilter<"Ledger"> | string
    type?: StringFilter<"Ledger"> | string
    account_head_id?: StringFilter<"Ledger"> | string
    client_id?: StringNullableFilter<"Ledger"> | string | null
    balance?: FloatFilter<"Ledger"> | number
    updatedAt?: DateTimeFilter<"Ledger"> | Date | string
    account_head?: XOR<AccountHeadRelationFilter, AccountHeadWhereInput>
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
  }, "id">

  export type LedgerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    account_head_id?: SortOrder
    client_id?: SortOrderInput | SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    _count?: LedgerCountOrderByAggregateInput
    _avg?: LedgerAvgOrderByAggregateInput
    _max?: LedgerMaxOrderByAggregateInput
    _min?: LedgerMinOrderByAggregateInput
    _sum?: LedgerSumOrderByAggregateInput
  }

  export type LedgerScalarWhereWithAggregatesInput = {
    AND?: LedgerScalarWhereWithAggregatesInput | LedgerScalarWhereWithAggregatesInput[]
    OR?: LedgerScalarWhereWithAggregatesInput[]
    NOT?: LedgerScalarWhereWithAggregatesInput | LedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ledger"> | string
    name?: StringWithAggregatesFilter<"Ledger"> | string
    type?: StringWithAggregatesFilter<"Ledger"> | string
    account_head_id?: StringWithAggregatesFilter<"Ledger"> | string
    client_id?: StringNullableWithAggregatesFilter<"Ledger"> | string | null
    balance?: FloatWithAggregatesFilter<"Ledger"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Ledger"> | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringFilter<"JournalEntry"> | string
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    type?: StringFilter<"JournalEntry"> | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    created_by?: StringFilter<"JournalEntry"> | string
    lines?: JournalLineListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    created_by?: SortOrder
    lines?: JournalLineOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    description?: StringFilter<"JournalEntry"> | string
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    type?: StringFilter<"JournalEntry"> | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    created_by?: StringFilter<"JournalEntry"> | string
    lines?: JournalLineListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    created_by?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalEntry"> | string
    date?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    description?: StringWithAggregatesFilter<"JournalEntry"> | string
    reference?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    type?: StringWithAggregatesFilter<"JournalEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    created_by?: StringWithAggregatesFilter<"JournalEntry"> | string
  }

  export type JournalLineWhereInput = {
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    id?: StringFilter<"JournalLine"> | string
    entry_id?: StringFilter<"JournalLine"> | string
    account_id?: StringFilter<"JournalLine"> | string
    debit?: FloatFilter<"JournalLine"> | number
    credit?: FloatFilter<"JournalLine"> | number
    description?: StringNullableFilter<"JournalLine"> | string | null
    invoice_id?: StringNullableFilter<"JournalLine"> | string | null
    entry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    account?: XOR<AccountHeadRelationFilter, AccountHeadWhereInput>
  }

  export type JournalLineOrderByWithRelationInput = {
    id?: SortOrder
    entry_id?: SortOrder
    account_id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrderInput | SortOrder
    invoice_id?: SortOrderInput | SortOrder
    entry?: JournalEntryOrderByWithRelationInput
    account?: AccountHeadOrderByWithRelationInput
  }

  export type JournalLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    entry_id?: StringFilter<"JournalLine"> | string
    account_id?: StringFilter<"JournalLine"> | string
    debit?: FloatFilter<"JournalLine"> | number
    credit?: FloatFilter<"JournalLine"> | number
    description?: StringNullableFilter<"JournalLine"> | string | null
    invoice_id?: StringNullableFilter<"JournalLine"> | string | null
    entry?: XOR<JournalEntryRelationFilter, JournalEntryWhereInput>
    account?: XOR<AccountHeadRelationFilter, AccountHeadWhereInput>
  }, "id">

  export type JournalLineOrderByWithAggregationInput = {
    id?: SortOrder
    entry_id?: SortOrder
    account_id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrderInput | SortOrder
    invoice_id?: SortOrderInput | SortOrder
    _count?: JournalLineCountOrderByAggregateInput
    _avg?: JournalLineAvgOrderByAggregateInput
    _max?: JournalLineMaxOrderByAggregateInput
    _min?: JournalLineMinOrderByAggregateInput
    _sum?: JournalLineSumOrderByAggregateInput
  }

  export type JournalLineScalarWhereWithAggregatesInput = {
    AND?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    OR?: JournalLineScalarWhereWithAggregatesInput[]
    NOT?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalLine"> | string
    entry_id?: StringWithAggregatesFilter<"JournalLine"> | string
    account_id?: StringWithAggregatesFilter<"JournalLine"> | string
    debit?: FloatWithAggregatesFilter<"JournalLine"> | number
    credit?: FloatWithAggregatesFilter<"JournalLine"> | number
    description?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    invoice_id?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    client_id?: StringFilter<"Invoice"> | string
    subtotal?: FloatFilter<"Invoice"> | number
    tax_rate?: FloatFilter<"Invoice"> | number
    tax_amount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    journal_entry_id?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    items?: InvoiceItemListRelationFilter
    journal_entry?: XOR<JournalEntryNullableRelationFilter, JournalEntryWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
    journal_entry_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    journal_entry?: JournalEntryOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    journal_entry_id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    date?: DateTimeFilter<"Invoice"> | Date | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    client_id?: StringFilter<"Invoice"> | string
    subtotal?: FloatFilter<"Invoice"> | number
    tax_rate?: FloatFilter<"Invoice"> | number
    tax_amount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    items?: InvoiceItemListRelationFilter
    journal_entry?: XOR<JournalEntryNullableRelationFilter, JournalEntryWhereInput> | null
  }, "id" | "number" | "journal_entry_id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
    journal_entry_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    number?: StringWithAggregatesFilter<"Invoice"> | string
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    due_date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    client_id?: StringWithAggregatesFilter<"Invoice"> | string
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    tax_rate?: FloatWithAggregatesFilter<"Invoice"> | number
    tax_amount?: FloatWithAggregatesFilter<"Invoice"> | number
    total?: FloatWithAggregatesFilter<"Invoice"> | number
    journal_entry_id?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unit_price?: FloatFilter<"InvoiceItem"> | number
    amount?: FloatFilter<"InvoiceItem"> | number
    invoice_id?: StringFilter<"InvoiceItem"> | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
    invoice_id?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unit_price?: FloatFilter<"InvoiceItem"> | number
    amount?: FloatFilter<"InvoiceItem"> | number
    invoice_id?: StringFilter<"InvoiceItem"> | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
    invoice_id?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unit_price?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    amount?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    invoice_id?: StringWithAggregatesFilter<"InvoiceItem"> | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    platform?: StringNullableFilter<"Task"> | string | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    actual_start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    completed_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimated_hours?: FloatNullableFilter<"Task"> | number | null
    time_estimate?: FloatNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    campaign_id?: StringNullableFilter<"Task"> | string | null
    client_id?: StringNullableFilter<"Task"> | string | null
    parent_task_id?: StringNullableFilter<"Task"> | string | null
    assignee_id?: StringNullableFilter<"Task"> | string | null
    reporter_id?: StringFilter<"Task"> | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    parent_task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
    sub_tasks?: TaskListRelationFilter
    dependencies?: TaskDependencyListRelationFilter
    dependents?: TaskDependencyListRelationFilter
    assignee?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    assets?: AssetListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    category?: SortOrder
    platform?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    actual_start_date?: SortOrderInput | SortOrder
    completed_date?: SortOrderInput | SortOrder
    estimated_hours?: SortOrderInput | SortOrder
    time_estimate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign_id?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    parent_task_id?: SortOrderInput | SortOrder
    assignee_id?: SortOrderInput | SortOrder
    reporter_id?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    parent_task?: TaskOrderByWithRelationInput
    sub_tasks?: TaskOrderByRelationAggregateInput
    dependencies?: TaskDependencyOrderByRelationAggregateInput
    dependents?: TaskDependencyOrderByRelationAggregateInput
    assignee?: UserOrderByWithRelationInput
    reporter?: UserOrderByWithRelationInput
    assets?: AssetOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    platform?: StringNullableFilter<"Task"> | string | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    actual_start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    completed_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimated_hours?: FloatNullableFilter<"Task"> | number | null
    time_estimate?: FloatNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    campaign_id?: StringNullableFilter<"Task"> | string | null
    client_id?: StringNullableFilter<"Task"> | string | null
    parent_task_id?: StringNullableFilter<"Task"> | string | null
    assignee_id?: StringNullableFilter<"Task"> | string | null
    reporter_id?: StringFilter<"Task"> | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    parent_task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
    sub_tasks?: TaskListRelationFilter
    dependencies?: TaskDependencyListRelationFilter
    dependents?: TaskDependencyListRelationFilter
    assignee?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    assets?: AssetListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    category?: SortOrder
    platform?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    actual_start_date?: SortOrderInput | SortOrder
    completed_date?: SortOrderInput | SortOrder
    estimated_hours?: SortOrderInput | SortOrder
    time_estimate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign_id?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    parent_task_id?: SortOrderInput | SortOrder
    assignee_id?: SortOrderInput | SortOrder
    reporter_id?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    priority?: StringWithAggregatesFilter<"Task"> | string
    type?: StringWithAggregatesFilter<"Task"> | string
    category?: StringWithAggregatesFilter<"Task"> | string
    platform?: StringNullableWithAggregatesFilter<"Task"> | string | null
    due_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    actual_start_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completed_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    estimated_hours?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    time_estimate?: FloatNullableWithAggregatesFilter<"Task"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    campaign_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    client_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    parent_task_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    assignee_id?: StringNullableWithAggregatesFilter<"Task"> | string | null
    reporter_id?: StringWithAggregatesFilter<"Task"> | string
  }

  export type TaskDependencyWhereInput = {
    AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    OR?: TaskDependencyWhereInput[]
    NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    id?: StringFilter<"TaskDependency"> | string
    blocking_task_id?: StringFilter<"TaskDependency"> | string
    blocked_task_id?: StringFilter<"TaskDependency"> | string
    createdAt?: DateTimeFilter<"TaskDependency"> | Date | string
    blocking_task?: XOR<TaskRelationFilter, TaskWhereInput>
    blocked_task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskDependencyOrderByWithRelationInput = {
    id?: SortOrder
    blocking_task_id?: SortOrder
    blocked_task_id?: SortOrder
    createdAt?: SortOrder
    blocking_task?: TaskOrderByWithRelationInput
    blocked_task?: TaskOrderByWithRelationInput
  }

  export type TaskDependencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blocking_task_id_blocked_task_id?: TaskDependencyBlocking_task_idBlocked_task_idCompoundUniqueInput
    AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    OR?: TaskDependencyWhereInput[]
    NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    blocking_task_id?: StringFilter<"TaskDependency"> | string
    blocked_task_id?: StringFilter<"TaskDependency"> | string
    createdAt?: DateTimeFilter<"TaskDependency"> | Date | string
    blocking_task?: XOR<TaskRelationFilter, TaskWhereInput>
    blocked_task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "id" | "blocking_task_id_blocked_task_id">

  export type TaskDependencyOrderByWithAggregationInput = {
    id?: SortOrder
    blocking_task_id?: SortOrder
    blocked_task_id?: SortOrder
    createdAt?: SortOrder
    _count?: TaskDependencyCountOrderByAggregateInput
    _max?: TaskDependencyMaxOrderByAggregateInput
    _min?: TaskDependencyMinOrderByAggregateInput
  }

  export type TaskDependencyScalarWhereWithAggregatesInput = {
    AND?: TaskDependencyScalarWhereWithAggregatesInput | TaskDependencyScalarWhereWithAggregatesInput[]
    OR?: TaskDependencyScalarWhereWithAggregatesInput[]
    NOT?: TaskDependencyScalarWhereWithAggregatesInput | TaskDependencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskDependency"> | string
    blocking_task_id?: StringWithAggregatesFilter<"TaskDependency"> | string
    blocked_task_id?: StringWithAggregatesFilter<"TaskDependency"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskDependency"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    original_name?: StringFilter<"Asset"> | string
    file_url?: StringFilter<"Asset"> | string
    file_type?: StringFilter<"Asset"> | string
    size_bytes?: IntNullableFilter<"Asset"> | number | null
    version?: IntFilter<"Asset"> | number
    is_approved?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    task_id?: StringFilter<"Asset"> | string
    uploader_id?: StringFilter<"Asset"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    comments?: AssetCommentListRelationFilter
    ads?: AdListRelationFilter
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    original_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    size_bytes?: SortOrderInput | SortOrder
    version?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    uploader_id?: SortOrder
    task?: TaskOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
    comments?: AssetCommentOrderByRelationAggregateInput
    ads?: AdOrderByRelationAggregateInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    original_name?: StringFilter<"Asset"> | string
    file_url?: StringFilter<"Asset"> | string
    file_type?: StringFilter<"Asset"> | string
    size_bytes?: IntNullableFilter<"Asset"> | number | null
    version?: IntFilter<"Asset"> | number
    is_approved?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    task_id?: StringFilter<"Asset"> | string
    uploader_id?: StringFilter<"Asset"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    comments?: AssetCommentListRelationFilter
    ads?: AdListRelationFilter
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    original_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    size_bytes?: SortOrderInput | SortOrder
    version?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    uploader_id?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    original_name?: StringWithAggregatesFilter<"Asset"> | string
    file_url?: StringWithAggregatesFilter<"Asset"> | string
    file_type?: StringWithAggregatesFilter<"Asset"> | string
    size_bytes?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    version?: IntWithAggregatesFilter<"Asset"> | number
    is_approved?: BoolWithAggregatesFilter<"Asset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    task_id?: StringWithAggregatesFilter<"Asset"> | string
    uploader_id?: StringWithAggregatesFilter<"Asset"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    is_revision_request?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    task_id?: StringFilter<"Comment"> | string
    author_id?: StringFilter<"Comment"> | string
    parent_comment_id?: StringNullableFilter<"Comment"> | string | null
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    parent_comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    is_revision_request?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    author_id?: SortOrder
    parent_comment_id?: SortOrderInput | SortOrder
    task?: TaskOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    parent_comment?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    is_revision_request?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    task_id?: StringFilter<"Comment"> | string
    author_id?: StringFilter<"Comment"> | string
    parent_comment_id?: StringNullableFilter<"Comment"> | string | null
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    parent_comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    is_revision_request?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    author_id?: SortOrder
    parent_comment_id?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    is_revision_request?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    task_id?: StringWithAggregatesFilter<"Comment"> | string
    author_id?: StringWithAggregatesFilter<"Comment"> | string
    parent_comment_id?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type AssetCommentWhereInput = {
    AND?: AssetCommentWhereInput | AssetCommentWhereInput[]
    OR?: AssetCommentWhereInput[]
    NOT?: AssetCommentWhereInput | AssetCommentWhereInput[]
    id?: StringFilter<"AssetComment"> | string
    content?: StringFilter<"AssetComment"> | string
    x_coord?: FloatNullableFilter<"AssetComment"> | number | null
    y_coord?: FloatNullableFilter<"AssetComment"> | number | null
    createdAt?: DateTimeFilter<"AssetComment"> | Date | string
    asset_id?: StringFilter<"AssetComment"> | string
    author_id?: StringFilter<"AssetComment"> | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AssetCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    x_coord?: SortOrderInput | SortOrder
    y_coord?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    asset_id?: SortOrder
    author_id?: SortOrder
    asset?: AssetOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type AssetCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetCommentWhereInput | AssetCommentWhereInput[]
    OR?: AssetCommentWhereInput[]
    NOT?: AssetCommentWhereInput | AssetCommentWhereInput[]
    content?: StringFilter<"AssetComment"> | string
    x_coord?: FloatNullableFilter<"AssetComment"> | number | null
    y_coord?: FloatNullableFilter<"AssetComment"> | number | null
    createdAt?: DateTimeFilter<"AssetComment"> | Date | string
    asset_id?: StringFilter<"AssetComment"> | string
    author_id?: StringFilter<"AssetComment"> | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AssetCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    x_coord?: SortOrderInput | SortOrder
    y_coord?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    asset_id?: SortOrder
    author_id?: SortOrder
    _count?: AssetCommentCountOrderByAggregateInput
    _avg?: AssetCommentAvgOrderByAggregateInput
    _max?: AssetCommentMaxOrderByAggregateInput
    _min?: AssetCommentMinOrderByAggregateInput
    _sum?: AssetCommentSumOrderByAggregateInput
  }

  export type AssetCommentScalarWhereWithAggregatesInput = {
    AND?: AssetCommentScalarWhereWithAggregatesInput | AssetCommentScalarWhereWithAggregatesInput[]
    OR?: AssetCommentScalarWhereWithAggregatesInput[]
    NOT?: AssetCommentScalarWhereWithAggregatesInput | AssetCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetComment"> | string
    content?: StringWithAggregatesFilter<"AssetComment"> | string
    x_coord?: FloatNullableWithAggregatesFilter<"AssetComment"> | number | null
    y_coord?: FloatNullableWithAggregatesFilter<"AssetComment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AssetComment"> | Date | string
    asset_id?: StringWithAggregatesFilter<"AssetComment"> | string
    author_id?: StringWithAggregatesFilter<"AssetComment"> | string
  }

  export type TimeLogWhereInput = {
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    id?: StringFilter<"TimeLog"> | string
    start_time?: DateTimeFilter<"TimeLog"> | Date | string
    end_time?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    duration_minutes?: IntNullableFilter<"TimeLog"> | number | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    task_id?: StringFilter<"TimeLog"> | string
    user_id?: StringFilter<"TimeLog"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TimeLogOrderByWithRelationInput = {
    id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrderInput | SortOrder
    duration_minutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    user_id?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TimeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    start_time?: DateTimeFilter<"TimeLog"> | Date | string
    end_time?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    duration_minutes?: IntNullableFilter<"TimeLog"> | number | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    task_id?: StringFilter<"TimeLog"> | string
    user_id?: StringFilter<"TimeLog"> | string
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TimeLogOrderByWithAggregationInput = {
    id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrderInput | SortOrder
    duration_minutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    user_id?: SortOrder
    _count?: TimeLogCountOrderByAggregateInput
    _avg?: TimeLogAvgOrderByAggregateInput
    _max?: TimeLogMaxOrderByAggregateInput
    _min?: TimeLogMinOrderByAggregateInput
    _sum?: TimeLogSumOrderByAggregateInput
  }

  export type TimeLogScalarWhereWithAggregatesInput = {
    AND?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    OR?: TimeLogScalarWhereWithAggregatesInput[]
    NOT?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeLog"> | string
    start_time?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    end_time?: DateTimeNullableWithAggregatesFilter<"TimeLog"> | Date | string | null
    duration_minutes?: IntNullableWithAggregatesFilter<"TimeLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    task_id?: StringWithAggregatesFilter<"TimeLog"> | string
    user_id?: StringWithAggregatesFilter<"TimeLog"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user_id?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user_id?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user_id?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    user_id?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentCalendarCreateInput = {
    id?: string
    date: Date | string
    creativeType: string
    quantity?: number
    completed?: number
    inProgress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutContentCalendarsInput
  }

  export type ContentCalendarUncheckedCreateInput = {
    id?: string
    date: Date | string
    creativeType: string
    quantity?: number
    completed?: number
    inProgress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
  }

  export type ContentCalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutContentCalendarsNestedInput
  }

  export type ContentCalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
  }

  export type ContentCalendarCreateManyInput = {
    id?: string
    date: Date | string
    creativeType: string
    quantity?: number
    completed?: number
    inProgress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
  }

  export type ContentCalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutCampaignsInput
    tasks?: TaskCreateNestedManyWithoutCampaignInput
    ad_groups?: AdGroupCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
    tasks?: TaskUncheckedCreateNestedManyWithoutCampaignInput
    ad_groups?: AdGroupUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutCampaignsNestedInput
    tasks?: TaskUpdateManyWithoutCampaignNestedInput
    ad_groups?: AdGroupUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutCampaignNestedInput
    ad_groups?: AdGroupUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdAccountCreateInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    client: ClientCreateNestedOneWithoutAd_accountsInput
    ad_groups?: AdGroupCreateNestedManyWithoutAd_accountInput
  }

  export type AdAccountUncheckedCreateInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    client_id: string
    ad_groups?: AdGroupUncheckedCreateNestedManyWithoutAd_accountInput
  }

  export type AdAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneRequiredWithoutAd_accountsNestedInput
    ad_groups?: AdGroupUpdateManyWithoutAd_accountNestedInput
  }

  export type AdAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    ad_groups?: AdGroupUncheckedUpdateManyWithoutAd_accountNestedInput
  }

  export type AdAccountCreateManyInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    client_id: string
  }

  export type AdAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type AdAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdGroupCreateInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign: CampaignCreateNestedOneWithoutAd_groupsInput
    ad_account?: AdAccountCreateNestedOneWithoutAd_groupsInput
    ads?: AdCreateNestedManyWithoutAd_groupInput
  }

  export type AdGroupUncheckedCreateInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign_id: string
    ad_account_id?: string | null
    ads?: AdUncheckedCreateNestedManyWithoutAd_groupInput
  }

  export type AdGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutAd_groupsNestedInput
    ad_account?: AdAccountUpdateOneWithoutAd_groupsNestedInput
    ads?: AdUpdateManyWithoutAd_groupNestedInput
  }

  export type AdGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    ad_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    ads?: AdUncheckedUpdateManyWithoutAd_groupNestedInput
  }

  export type AdGroupCreateManyInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign_id: string
    ad_account_id?: string | null
  }

  export type AdGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AdGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    ad_account_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdCreateInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group: AdGroupCreateNestedOneWithoutAdsInput
    creative?: AssetCreateNestedOneWithoutAdsInput
    snapshots?: SpendSnapshotCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group_id: string
    creative_id?: string | null
    snapshots?: SpendSnapshotUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group?: AdGroupUpdateOneRequiredWithoutAdsNestedInput
    creative?: AssetUpdateOneWithoutAdsNestedInput
    snapshots?: SpendSnapshotUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group_id?: StringFieldUpdateOperationsInput | string
    creative_id?: NullableStringFieldUpdateOperationsInput | string | null
    snapshots?: SpendSnapshotUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdCreateManyInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group_id: string
    creative_id?: string | null
  }

  export type AdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group_id?: StringFieldUpdateOperationsInput | string
    creative_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendSnapshotCreateInput = {
    id?: string
    date: Date | string
    spend: number
    impressions?: number
    clicks?: number
    conversions?: number
    revenue?: number
    platform_data?: string | null
    createdAt?: Date | string
    ad: AdCreateNestedOneWithoutSnapshotsInput
  }

  export type SpendSnapshotUncheckedCreateInput = {
    id?: string
    date: Date | string
    ad_id: string
    spend: number
    impressions?: number
    clicks?: number
    conversions?: number
    revenue?: number
    platform_data?: string | null
    createdAt?: Date | string
  }

  export type SpendSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ad?: AdUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type SpendSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ad_id?: StringFieldUpdateOperationsInput | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendSnapshotCreateManyInput = {
    id?: string
    date: Date | string
    ad_id: string
    spend: number
    impressions?: number
    clicks?: number
    conversions?: number
    revenue?: number
    platform_data?: string | null
    createdAt?: Date | string
  }

  export type SpendSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    ad_id?: StringFieldUpdateOperationsInput | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMetricCreateInput = {
    id?: string
    date: Date | string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
    campaign: CampaignCreateNestedOneWithoutMetricsInput
  }

  export type CampaignMetricUncheckedCreateInput = {
    id?: string
    date: Date | string
    campaign_id: string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
  }

  export type CampaignMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    campaign?: CampaignUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type CampaignMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
  }

  export type CampaignMetricCreateManyInput = {
    id?: string
    date: Date | string
    campaign_id: string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
  }

  export type CampaignMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
  }

  export type CampaignMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entity_id: string
    user_id: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entity: string
    entity_id: string
    user_id: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entity: string
    entity_id: string
    user_id: string
    details?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountHeadCreateInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
    ledgers?: LedgerCreateNestedManyWithoutAccount_headInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
  }

  export type AccountHeadUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
    ledgers?: LedgerUncheckedCreateNestedManyWithoutAccount_headInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountHeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
    ledgers?: LedgerUpdateManyWithoutAccount_headNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
  }

  export type AccountHeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
    ledgers?: LedgerUncheckedUpdateManyWithoutAccount_headNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountHeadCreateManyInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
  }

  export type AccountHeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountHeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LedgerCreateInput = {
    id?: string
    name: string
    type: string
    balance?: number
    updatedAt?: Date | string
    account_head: AccountHeadCreateNestedOneWithoutLedgersInput
    client?: ClientCreateNestedOneWithoutLedgersInput
  }

  export type LedgerUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    account_head_id: string
    client_id?: string | null
    balance?: number
    updatedAt?: Date | string
  }

  export type LedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_head?: AccountHeadUpdateOneRequiredWithoutLedgersNestedInput
    client?: ClientUpdateOneWithoutLedgersNestedInput
  }

  export type LedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    account_head_id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerCreateManyInput = {
    id?: string
    name: string
    type: string
    account_head_id: string
    client_id?: string | null
    balance?: number
    updatedAt?: Date | string
  }

  export type LedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    account_head_id?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
    lines?: JournalLineCreateNestedManyWithoutEntryInput
    invoice?: InvoiceCreateNestedOneWithoutJournal_entryInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
    lines?: JournalLineUncheckedCreateNestedManyWithoutEntryInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutJournal_entryInput
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    lines?: JournalLineUpdateManyWithoutEntryNestedInput
    invoice?: InvoiceUpdateOneWithoutJournal_entryNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    lines?: JournalLineUncheckedUpdateManyWithoutEntryNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutJournal_entryNestedInput
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type JournalLineCreateInput = {
    id?: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
    entry: JournalEntryCreateNestedOneWithoutLinesInput
    account: AccountHeadCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateInput = {
    id?: string
    entry_id: string
    account_id: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
  }

  export type JournalLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
    account?: AccountHeadUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineCreateManyInput = {
    id?: string
    entry_id: string
    account_id: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
  }

  export type JournalLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    journal_entry?: JournalEntryCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    client_id: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    journal_entry_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    journal_entry?: JournalEntryUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    journal_entry_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    client_id: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    journal_entry_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    journal_entry_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    quantity: number
    unit_price: number
    amount: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    description: string
    quantity: number
    unit_price: number
    amount: number
    invoice_id: string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    invoice_id?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    description: string
    quantity: number
    unit_price: number
    amount: number
    invoice_id: string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    invoice_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDependencyCreateInput = {
    id?: string
    createdAt?: Date | string
    blocking_task: TaskCreateNestedOneWithoutDependenciesInput
    blocked_task: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskDependencyUncheckedCreateInput = {
    id?: string
    blocking_task_id: string
    blocked_task_id: string
    createdAt?: Date | string
  }

  export type TaskDependencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocking_task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput
    blocked_task?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskDependencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blocking_task_id?: StringFieldUpdateOperationsInput | string
    blocked_task_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyCreateManyInput = {
    id?: string
    blocking_task_id: string
    blocked_task_id: string
    createdAt?: Date | string
  }

  export type TaskDependencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blocking_task_id?: StringFieldUpdateOperationsInput | string
    blocked_task_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAssetsInput
    uploader: UserCreateNestedOneWithoutAssetsUploadedInput
    comments?: AssetCommentCreateNestedManyWithoutAssetInput
    ads?: AdCreateNestedManyWithoutCreativeInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task_id: string
    uploader_id: string
    comments?: AssetCommentUncheckedCreateNestedManyWithoutAssetInput
    ads?: AdUncheckedCreateNestedManyWithoutCreativeInput
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssetsNestedInput
    uploader?: UserUpdateOneRequiredWithoutAssetsUploadedNestedInput
    comments?: AssetCommentUpdateManyWithoutAssetNestedInput
    ads?: AdUpdateManyWithoutCreativeNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    uploader_id?: StringFieldUpdateOperationsInput | string
    comments?: AssetCommentUncheckedUpdateManyWithoutAssetNestedInput
    ads?: AdUncheckedUpdateManyWithoutCreativeNestedInput
  }

  export type AssetCreateManyInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task_id: string
    uploader_id: string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    uploader_id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent_comment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParent_commentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    author_id: string
    parent_comment_id?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParent_commentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent_comment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    author_id: string
    parent_comment_id?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetCommentCreateInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAssetCommentsInput
  }

  export type AssetCommentUncheckedCreateInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    asset_id: string
    author_id: string
  }

  export type AssetCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAssetCommentsNestedInput
  }

  export type AssetCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCommentCreateManyInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    asset_id: string
    author_id: string
  }

  export type AssetCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogCreateInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    task_id: string
    user_id: string
  }

  export type TimeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogCreateManyInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    task_id: string
    user_id: string
  }

  export type TimeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
    user_id: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
    user_id: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TimeLogListRelationFilter = {
    every?: TimeLogWhereInput
    some?: TimeLogWhereInput
    none?: TimeLogWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AssetCommentListRelationFilter = {
    every?: AssetCommentWhereInput
    some?: AssetCommentWhereInput
    none?: AssetCommentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    designation?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar_url?: SortOrder
    staff_id_number?: SortOrder
    joining_date?: SortOrder
    dob?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    designation?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar_url?: SortOrder
    staff_id_number?: SortOrder
    joining_date?: SortOrder
    dob?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    designation?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar_url?: SortOrder
    staff_id_number?: SortOrder
    joining_date?: SortOrder
    dob?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type AdAccountListRelationFilter = {
    every?: AdAccountWhereInput
    some?: AdAccountWhereInput
    none?: AdAccountWhereInput
  }

  export type ContentCalendarListRelationFilter = {
    every?: ContentCalendarWhereInput
    some?: ContentCalendarWhereInput
    none?: ContentCalendarWhereInput
  }

  export type LedgerListRelationFilter = {
    every?: LedgerWhereInput
    some?: LedgerWhereInput
    none?: LedgerWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentCalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_colors?: SortOrder
    logo_url?: SortOrder
    industry?: SortOrder
    contract_type?: SortOrder
    client_number?: SortOrder
    onboarding_date?: SortOrder
    address?: SortOrder
    contact_person?: SortOrder
    contact_number?: SortOrder
    website?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    linkedin?: SortOrder
    youtube?: SortOrder
    competitorDetails?: SortOrder
    customerAvatar?: SortOrder
    contentSuggestions?: SortOrder
    referenceLinks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account_manager_id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_colors?: SortOrder
    logo_url?: SortOrder
    industry?: SortOrder
    contract_type?: SortOrder
    client_number?: SortOrder
    onboarding_date?: SortOrder
    address?: SortOrder
    contact_person?: SortOrder
    contact_number?: SortOrder
    website?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    linkedin?: SortOrder
    youtube?: SortOrder
    competitorDetails?: SortOrder
    customerAvatar?: SortOrder
    contentSuggestions?: SortOrder
    referenceLinks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account_manager_id?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_colors?: SortOrder
    logo_url?: SortOrder
    industry?: SortOrder
    contract_type?: SortOrder
    client_number?: SortOrder
    onboarding_date?: SortOrder
    address?: SortOrder
    contact_person?: SortOrder
    contact_number?: SortOrder
    website?: SortOrder
    email?: SortOrder
    whatsapp?: SortOrder
    facebook?: SortOrder
    instagram?: SortOrder
    linkedin?: SortOrder
    youtube?: SortOrder
    competitorDetails?: SortOrder
    customerAvatar?: SortOrder
    contentSuggestions?: SortOrder
    referenceLinks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account_manager_id?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ContentCalendarCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    creativeType?: SortOrder
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
  }

  export type ContentCalendarAvgOrderByAggregateInput = {
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
  }

  export type ContentCalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    creativeType?: SortOrder
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
  }

  export type ContentCalendarMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    creativeType?: SortOrder
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
  }

  export type ContentCalendarSumOrderByAggregateInput = {
    quantity?: SortOrder
    completed?: SortOrder
    inProgress?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AdGroupListRelationFilter = {
    every?: AdGroupWhereInput
    some?: AdGroupWhereInput
    none?: AdGroupWhereInput
  }

  export type CampaignMetricListRelationFilter = {
    every?: CampaignMetricWhereInput
    some?: CampaignMetricWhereInput
    none?: CampaignMetricWhereInput
  }

  export type AdGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    goals?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client_id?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AdAccountCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    client_id?: SortOrder
  }

  export type AdAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    client_id?: SortOrder
  }

  export type AdAccountMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    client_id?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type AdAccountNullableRelationFilter = {
    is?: AdAccountWhereInput | null
    isNot?: AdAccountWhereInput | null
  }

  export type AdListRelationFilter = {
    every?: AdWhereInput
    some?: AdWhereInput
    none?: AdWhereInput
  }

  export type AdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    campaign_id?: SortOrder
    ad_account_id?: SortOrder
  }

  export type AdGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    campaign_id?: SortOrder
    ad_account_id?: SortOrder
  }

  export type AdGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    campaign_id?: SortOrder
    ad_account_id?: SortOrder
  }

  export type AdGroupRelationFilter = {
    is?: AdGroupWhereInput
    isNot?: AdGroupWhereInput
  }

  export type AssetNullableRelationFilter = {
    is?: AssetWhereInput | null
    isNot?: AssetWhereInput | null
  }

  export type SpendSnapshotListRelationFilter = {
    every?: SpendSnapshotWhereInput
    some?: SpendSnapshotWhereInput
    none?: SpendSnapshotWhereInput
  }

  export type SpendSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    ad_group_id?: SortOrder
    creative_id?: SortOrder
  }

  export type AdMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    ad_group_id?: SortOrder
    creative_id?: SortOrder
  }

  export type AdMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    ad_group_id?: SortOrder
    creative_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AdRelationFilter = {
    is?: AdWhereInput
    isNot?: AdWhereInput
  }

  export type SpendSnapshotAd_idDateCompoundUniqueInput = {
    ad_id: string
    date: Date | string
  }

  export type SpendSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    ad_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    platform_data?: SortOrder
    createdAt?: SortOrder
  }

  export type SpendSnapshotAvgOrderByAggregateInput = {
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type SpendSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    ad_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    platform_data?: SortOrder
    createdAt?: SortOrder
  }

  export type SpendSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    ad_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
    platform_data?: SortOrder
    createdAt?: SortOrder
  }

  export type SpendSnapshotSumOrderByAggregateInput = {
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CampaignMetricCampaign_idDateCompoundUniqueInput = {
    campaign_id: string
    date: Date | string
  }

  export type CampaignMetricCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    campaign_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type CampaignMetricAvgOrderByAggregateInput = {
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type CampaignMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    campaign_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type CampaignMetricMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    campaign_id?: SortOrder
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type CampaignMetricSumOrderByAggregateInput = {
    spend?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    revenue?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    user_id?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    user_id?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entity_id?: SortOrder
    user_id?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type JournalLineListRelationFilter = {
    every?: JournalLineWhereInput
    some?: JournalLineWhereInput
    none?: JournalLineWhereInput
  }

  export type JournalLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountHeadCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    is_system?: SortOrder
  }

  export type AccountHeadMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    is_system?: SortOrder
  }

  export type AccountHeadMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    is_system?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AccountHeadRelationFilter = {
    is?: AccountHeadWhereInput
    isNot?: AccountHeadWhereInput
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type LedgerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    account_head_id?: SortOrder
    client_id?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type LedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    account_head_id?: SortOrder
    client_id?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    account_head_id?: SortOrder
    client_id?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type LedgerSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    created_by?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    created_by?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    created_by?: SortOrder
  }

  export type JournalEntryRelationFilter = {
    is?: JournalEntryWhereInput
    isNot?: JournalEntryWhereInput
  }

  export type JournalLineCountOrderByAggregateInput = {
    id?: SortOrder
    entry_id?: SortOrder
    account_id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    invoice_id?: SortOrder
  }

  export type JournalLineAvgOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineMaxOrderByAggregateInput = {
    id?: SortOrder
    entry_id?: SortOrder
    account_id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    invoice_id?: SortOrder
  }

  export type JournalLineMinOrderByAggregateInput = {
    id?: SortOrder
    entry_id?: SortOrder
    account_id?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    description?: SortOrder
    invoice_id?: SortOrder
  }

  export type JournalLineSumOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type JournalEntryNullableRelationFilter = {
    is?: JournalEntryWhereInput | null
    isNot?: JournalEntryWhereInput | null
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
    journal_entry_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
    journal_entry_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
    journal_entry_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax_rate?: SortOrder
    tax_amount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
    invoice_id?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
    invoice_id?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
    invoice_id?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    amount?: SortOrder
  }

  export type CampaignNullableRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type TaskNullableRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type TaskDependencyListRelationFilter = {
    every?: TaskDependencyWhereInput
    some?: TaskDependencyWhereInput
    none?: TaskDependencyWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TaskDependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    due_date?: SortOrder
    start_date?: SortOrder
    actual_start_date?: SortOrder
    completed_date?: SortOrder
    estimated_hours?: SortOrder
    time_estimate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign_id?: SortOrder
    client_id?: SortOrder
    parent_task_id?: SortOrder
    assignee_id?: SortOrder
    reporter_id?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    estimated_hours?: SortOrder
    time_estimate?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    due_date?: SortOrder
    start_date?: SortOrder
    actual_start_date?: SortOrder
    completed_date?: SortOrder
    estimated_hours?: SortOrder
    time_estimate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign_id?: SortOrder
    client_id?: SortOrder
    parent_task_id?: SortOrder
    assignee_id?: SortOrder
    reporter_id?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    type?: SortOrder
    category?: SortOrder
    platform?: SortOrder
    due_date?: SortOrder
    start_date?: SortOrder
    actual_start_date?: SortOrder
    completed_date?: SortOrder
    estimated_hours?: SortOrder
    time_estimate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign_id?: SortOrder
    client_id?: SortOrder
    parent_task_id?: SortOrder
    assignee_id?: SortOrder
    reporter_id?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    estimated_hours?: SortOrder
    time_estimate?: SortOrder
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskDependencyBlocking_task_idBlocked_task_idCompoundUniqueInput = {
    blocking_task_id: string
    blocked_task_id: string
  }

  export type TaskDependencyCountOrderByAggregateInput = {
    id?: SortOrder
    blocking_task_id?: SortOrder
    blocked_task_id?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskDependencyMaxOrderByAggregateInput = {
    id?: SortOrder
    blocking_task_id?: SortOrder
    blocked_task_id?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskDependencyMinOrderByAggregateInput = {
    id?: SortOrder
    blocking_task_id?: SortOrder
    blocked_task_id?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    original_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    size_bytes?: SortOrder
    version?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    uploader_id?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    size_bytes?: SortOrder
    version?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    original_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    size_bytes?: SortOrder
    version?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    uploader_id?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    original_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    size_bytes?: SortOrder
    version?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    uploader_id?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    size_bytes?: SortOrder
    version?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    is_revision_request?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    author_id?: SortOrder
    parent_comment_id?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    is_revision_request?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    author_id?: SortOrder
    parent_comment_id?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    is_revision_request?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    author_id?: SortOrder
    parent_comment_id?: SortOrder
  }

  export type AssetRelationFilter = {
    is?: AssetWhereInput
    isNot?: AssetWhereInput
  }

  export type AssetCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    x_coord?: SortOrder
    y_coord?: SortOrder
    createdAt?: SortOrder
    asset_id?: SortOrder
    author_id?: SortOrder
  }

  export type AssetCommentAvgOrderByAggregateInput = {
    x_coord?: SortOrder
    y_coord?: SortOrder
  }

  export type AssetCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    x_coord?: SortOrder
    y_coord?: SortOrder
    createdAt?: SortOrder
    asset_id?: SortOrder
    author_id?: SortOrder
  }

  export type AssetCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    x_coord?: SortOrder
    y_coord?: SortOrder
    createdAt?: SortOrder
    asset_id?: SortOrder
    author_id?: SortOrder
  }

  export type AssetCommentSumOrderByAggregateInput = {
    x_coord?: SortOrder
    y_coord?: SortOrder
  }

  export type TimeLogCountOrderByAggregateInput = {
    id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    user_id?: SortOrder
  }

  export type TimeLogAvgOrderByAggregateInput = {
    duration_minutes?: SortOrder
  }

  export type TimeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    user_id?: SortOrder
  }

  export type TimeLogMinOrderByAggregateInput = {
    id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    duration_minutes?: SortOrder
    createdAt?: SortOrder
    task_id?: SortOrder
    user_id?: SortOrder
  }

  export type TimeLogSumOrderByAggregateInput = {
    duration_minutes?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    user_id?: SortOrder
  }

  export type ClientCreateNestedManyWithoutAccount_managerInput = {
    create?: XOR<ClientCreateWithoutAccount_managerInput, ClientUncheckedCreateWithoutAccount_managerInput> | ClientCreateWithoutAccount_managerInput[] | ClientUncheckedCreateWithoutAccount_managerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccount_managerInput | ClientCreateOrConnectWithoutAccount_managerInput[]
    createMany?: ClientCreateManyAccount_managerInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutReporterInput = {
    create?: XOR<TaskCreateWithoutReporterInput, TaskUncheckedCreateWithoutReporterInput> | TaskCreateWithoutReporterInput[] | TaskUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutReporterInput | TaskCreateOrConnectWithoutReporterInput[]
    createMany?: TaskCreateManyReporterInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutUploaderInput = {
    create?: XOR<AssetCreateWithoutUploaderInput, AssetUncheckedCreateWithoutUploaderInput> | AssetCreateWithoutUploaderInput[] | AssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUploaderInput | AssetCreateOrConnectWithoutUploaderInput[]
    createMany?: AssetCreateManyUploaderInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AssetCommentCreateWithoutAuthorInput, AssetCommentUncheckedCreateWithoutAuthorInput> | AssetCommentCreateWithoutAuthorInput[] | AssetCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAuthorInput | AssetCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: AssetCommentCreateManyAuthorInputEnvelope
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutAccount_managerInput = {
    create?: XOR<ClientCreateWithoutAccount_managerInput, ClientUncheckedCreateWithoutAccount_managerInput> | ClientCreateWithoutAccount_managerInput[] | ClientUncheckedCreateWithoutAccount_managerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccount_managerInput | ClientCreateOrConnectWithoutAccount_managerInput[]
    createMany?: ClientCreateManyAccount_managerInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<TaskCreateWithoutReporterInput, TaskUncheckedCreateWithoutReporterInput> | TaskCreateWithoutReporterInput[] | TaskUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutReporterInput | TaskCreateOrConnectWithoutReporterInput[]
    createMany?: TaskCreateManyReporterInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<AssetCreateWithoutUploaderInput, AssetUncheckedCreateWithoutUploaderInput> | AssetCreateWithoutUploaderInput[] | AssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUploaderInput | AssetCreateOrConnectWithoutUploaderInput[]
    createMany?: AssetCreateManyUploaderInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AssetCommentCreateWithoutAuthorInput, AssetCommentUncheckedCreateWithoutAuthorInput> | AssetCommentCreateWithoutAuthorInput[] | AssetCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAuthorInput | AssetCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: AssetCommentCreateManyAuthorInputEnvelope
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientUpdateManyWithoutAccount_managerNestedInput = {
    create?: XOR<ClientCreateWithoutAccount_managerInput, ClientUncheckedCreateWithoutAccount_managerInput> | ClientCreateWithoutAccount_managerInput[] | ClientUncheckedCreateWithoutAccount_managerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccount_managerInput | ClientCreateOrConnectWithoutAccount_managerInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutAccount_managerInput | ClientUpsertWithWhereUniqueWithoutAccount_managerInput[]
    createMany?: ClientCreateManyAccount_managerInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutAccount_managerInput | ClientUpdateWithWhereUniqueWithoutAccount_managerInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutAccount_managerInput | ClientUpdateManyWithWhereWithoutAccount_managerInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutReporterNestedInput = {
    create?: XOR<TaskCreateWithoutReporterInput, TaskUncheckedCreateWithoutReporterInput> | TaskCreateWithoutReporterInput[] | TaskUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutReporterInput | TaskCreateOrConnectWithoutReporterInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutReporterInput | TaskUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: TaskCreateManyReporterInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutReporterInput | TaskUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutReporterInput | TaskUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutUserInput | TimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutUserInput | TimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutUserInput | TimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<AssetCreateWithoutUploaderInput, AssetUncheckedCreateWithoutUploaderInput> | AssetCreateWithoutUploaderInput[] | AssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUploaderInput | AssetCreateOrConnectWithoutUploaderInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutUploaderInput | AssetUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: AssetCreateManyUploaderInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutUploaderInput | AssetUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutUploaderInput | AssetUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AssetCommentCreateWithoutAuthorInput, AssetCommentUncheckedCreateWithoutAuthorInput> | AssetCommentCreateWithoutAuthorInput[] | AssetCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAuthorInput | AssetCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: AssetCommentUpsertWithWhereUniqueWithoutAuthorInput | AssetCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AssetCommentCreateManyAuthorInputEnvelope
    set?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    disconnect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    delete?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    update?: AssetCommentUpdateWithWhereUniqueWithoutAuthorInput | AssetCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AssetCommentUpdateManyWithWhereWithoutAuthorInput | AssetCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AssetCommentScalarWhereInput | AssetCommentScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutAccount_managerNestedInput = {
    create?: XOR<ClientCreateWithoutAccount_managerInput, ClientUncheckedCreateWithoutAccount_managerInput> | ClientCreateWithoutAccount_managerInput[] | ClientUncheckedCreateWithoutAccount_managerInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAccount_managerInput | ClientCreateOrConnectWithoutAccount_managerInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutAccount_managerInput | ClientUpsertWithWhereUniqueWithoutAccount_managerInput[]
    createMany?: ClientCreateManyAccount_managerInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutAccount_managerInput | ClientUpdateWithWhereUniqueWithoutAccount_managerInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutAccount_managerInput | ClientUpdateManyWithWhereWithoutAccount_managerInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<TaskCreateWithoutReporterInput, TaskUncheckedCreateWithoutReporterInput> | TaskCreateWithoutReporterInput[] | TaskUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutReporterInput | TaskCreateOrConnectWithoutReporterInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutReporterInput | TaskUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: TaskCreateManyReporterInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutReporterInput | TaskUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutReporterInput | TaskUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutUserInput | TimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutUserInput | TimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutUserInput | TimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<AssetCreateWithoutUploaderInput, AssetUncheckedCreateWithoutUploaderInput> | AssetCreateWithoutUploaderInput[] | AssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutUploaderInput | AssetCreateOrConnectWithoutUploaderInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutUploaderInput | AssetUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: AssetCreateManyUploaderInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutUploaderInput | AssetUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutUploaderInput | AssetUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AssetCommentCreateWithoutAuthorInput, AssetCommentUncheckedCreateWithoutAuthorInput> | AssetCommentCreateWithoutAuthorInput[] | AssetCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAuthorInput | AssetCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: AssetCommentUpsertWithWhereUniqueWithoutAuthorInput | AssetCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AssetCommentCreateManyAuthorInputEnvelope
    set?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    disconnect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    delete?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    update?: AssetCommentUpdateWithWhereUniqueWithoutAuthorInput | AssetCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AssetCommentUpdateManyWithWhereWithoutAuthorInput | AssetCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AssetCommentScalarWhereInput | AssetCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientsManagedInput = {
    create?: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsManagedInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutClientInput = {
    create?: XOR<CampaignCreateWithoutClientInput, CampaignUncheckedCreateWithoutClientInput> | CampaignCreateWithoutClientInput[] | CampaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClientInput | CampaignCreateOrConnectWithoutClientInput[]
    createMany?: CampaignCreateManyClientInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutClientInput = {
    create?: XOR<TaskCreateWithoutClientInput, TaskUncheckedCreateWithoutClientInput> | TaskCreateWithoutClientInput[] | TaskUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClientInput | TaskCreateOrConnectWithoutClientInput[]
    createMany?: TaskCreateManyClientInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AdAccountCreateNestedManyWithoutClientInput = {
    create?: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput> | AdAccountCreateWithoutClientInput[] | AdAccountUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutClientInput | AdAccountCreateOrConnectWithoutClientInput[]
    createMany?: AdAccountCreateManyClientInputEnvelope
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
  }

  export type ContentCalendarCreateNestedManyWithoutClientInput = {
    create?: XOR<ContentCalendarCreateWithoutClientInput, ContentCalendarUncheckedCreateWithoutClientInput> | ContentCalendarCreateWithoutClientInput[] | ContentCalendarUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutClientInput | ContentCalendarCreateOrConnectWithoutClientInput[]
    createMany?: ContentCalendarCreateManyClientInputEnvelope
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
  }

  export type LedgerCreateNestedManyWithoutClientInput = {
    create?: XOR<LedgerCreateWithoutClientInput, LedgerUncheckedCreateWithoutClientInput> | LedgerCreateWithoutClientInput[] | LedgerUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutClientInput | LedgerCreateOrConnectWithoutClientInput[]
    createMany?: LedgerCreateManyClientInputEnvelope
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CampaignCreateWithoutClientInput, CampaignUncheckedCreateWithoutClientInput> | CampaignCreateWithoutClientInput[] | CampaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClientInput | CampaignCreateOrConnectWithoutClientInput[]
    createMany?: CampaignCreateManyClientInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TaskCreateWithoutClientInput, TaskUncheckedCreateWithoutClientInput> | TaskCreateWithoutClientInput[] | TaskUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClientInput | TaskCreateOrConnectWithoutClientInput[]
    createMany?: TaskCreateManyClientInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AdAccountUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput> | AdAccountCreateWithoutClientInput[] | AdAccountUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutClientInput | AdAccountCreateOrConnectWithoutClientInput[]
    createMany?: AdAccountCreateManyClientInputEnvelope
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
  }

  export type ContentCalendarUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ContentCalendarCreateWithoutClientInput, ContentCalendarUncheckedCreateWithoutClientInput> | ContentCalendarCreateWithoutClientInput[] | ContentCalendarUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutClientInput | ContentCalendarCreateOrConnectWithoutClientInput[]
    createMany?: ContentCalendarCreateManyClientInputEnvelope
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
  }

  export type LedgerUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LedgerCreateWithoutClientInput, LedgerUncheckedCreateWithoutClientInput> | LedgerCreateWithoutClientInput[] | LedgerUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutClientInput | LedgerCreateOrConnectWithoutClientInput[]
    createMany?: LedgerCreateManyClientInputEnvelope
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutClientsManagedNestedInput = {
    create?: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsManagedInput
    upsert?: UserUpsertWithoutClientsManagedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsManagedInput, UserUpdateWithoutClientsManagedInput>, UserUncheckedUpdateWithoutClientsManagedInput>
  }

  export type CampaignUpdateManyWithoutClientNestedInput = {
    create?: XOR<CampaignCreateWithoutClientInput, CampaignUncheckedCreateWithoutClientInput> | CampaignCreateWithoutClientInput[] | CampaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClientInput | CampaignCreateOrConnectWithoutClientInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutClientInput | CampaignUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CampaignCreateManyClientInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutClientInput | CampaignUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutClientInput | CampaignUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutClientNestedInput = {
    create?: XOR<TaskCreateWithoutClientInput, TaskUncheckedCreateWithoutClientInput> | TaskCreateWithoutClientInput[] | TaskUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClientInput | TaskCreateOrConnectWithoutClientInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClientInput | TaskUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TaskCreateManyClientInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClientInput | TaskUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClientInput | TaskUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AdAccountUpdateManyWithoutClientNestedInput = {
    create?: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput> | AdAccountCreateWithoutClientInput[] | AdAccountUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutClientInput | AdAccountCreateOrConnectWithoutClientInput[]
    upsert?: AdAccountUpsertWithWhereUniqueWithoutClientInput | AdAccountUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AdAccountCreateManyClientInputEnvelope
    set?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    disconnect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    delete?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    update?: AdAccountUpdateWithWhereUniqueWithoutClientInput | AdAccountUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AdAccountUpdateManyWithWhereWithoutClientInput | AdAccountUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
  }

  export type ContentCalendarUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContentCalendarCreateWithoutClientInput, ContentCalendarUncheckedCreateWithoutClientInput> | ContentCalendarCreateWithoutClientInput[] | ContentCalendarUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutClientInput | ContentCalendarCreateOrConnectWithoutClientInput[]
    upsert?: ContentCalendarUpsertWithWhereUniqueWithoutClientInput | ContentCalendarUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContentCalendarCreateManyClientInputEnvelope
    set?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    disconnect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    delete?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    update?: ContentCalendarUpdateWithWhereUniqueWithoutClientInput | ContentCalendarUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContentCalendarUpdateManyWithWhereWithoutClientInput | ContentCalendarUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
  }

  export type LedgerUpdateManyWithoutClientNestedInput = {
    create?: XOR<LedgerCreateWithoutClientInput, LedgerUncheckedCreateWithoutClientInput> | LedgerCreateWithoutClientInput[] | LedgerUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutClientInput | LedgerCreateOrConnectWithoutClientInput[]
    upsert?: LedgerUpsertWithWhereUniqueWithoutClientInput | LedgerUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LedgerCreateManyClientInputEnvelope
    set?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    disconnect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    delete?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    update?: LedgerUpdateWithWhereUniqueWithoutClientInput | LedgerUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LedgerUpdateManyWithWhereWithoutClientInput | LedgerUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CampaignCreateWithoutClientInput, CampaignUncheckedCreateWithoutClientInput> | CampaignCreateWithoutClientInput[] | CampaignUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClientInput | CampaignCreateOrConnectWithoutClientInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutClientInput | CampaignUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CampaignCreateManyClientInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutClientInput | CampaignUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutClientInput | CampaignUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TaskCreateWithoutClientInput, TaskUncheckedCreateWithoutClientInput> | TaskCreateWithoutClientInput[] | TaskUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClientInput | TaskCreateOrConnectWithoutClientInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClientInput | TaskUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TaskCreateManyClientInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClientInput | TaskUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClientInput | TaskUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AdAccountUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput> | AdAccountCreateWithoutClientInput[] | AdAccountUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutClientInput | AdAccountCreateOrConnectWithoutClientInput[]
    upsert?: AdAccountUpsertWithWhereUniqueWithoutClientInput | AdAccountUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AdAccountCreateManyClientInputEnvelope
    set?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    disconnect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    delete?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    update?: AdAccountUpdateWithWhereUniqueWithoutClientInput | AdAccountUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AdAccountUpdateManyWithWhereWithoutClientInput | AdAccountUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
  }

  export type ContentCalendarUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContentCalendarCreateWithoutClientInput, ContentCalendarUncheckedCreateWithoutClientInput> | ContentCalendarCreateWithoutClientInput[] | ContentCalendarUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContentCalendarCreateOrConnectWithoutClientInput | ContentCalendarCreateOrConnectWithoutClientInput[]
    upsert?: ContentCalendarUpsertWithWhereUniqueWithoutClientInput | ContentCalendarUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContentCalendarCreateManyClientInputEnvelope
    set?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    disconnect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    delete?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    connect?: ContentCalendarWhereUniqueInput | ContentCalendarWhereUniqueInput[]
    update?: ContentCalendarUpdateWithWhereUniqueWithoutClientInput | ContentCalendarUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContentCalendarUpdateManyWithWhereWithoutClientInput | ContentCalendarUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
  }

  export type LedgerUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LedgerCreateWithoutClientInput, LedgerUncheckedCreateWithoutClientInput> | LedgerCreateWithoutClientInput[] | LedgerUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutClientInput | LedgerCreateOrConnectWithoutClientInput[]
    upsert?: LedgerUpsertWithWhereUniqueWithoutClientInput | LedgerUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LedgerCreateManyClientInputEnvelope
    set?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    disconnect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    delete?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    update?: LedgerUpdateWithWhereUniqueWithoutClientInput | LedgerUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LedgerUpdateManyWithWhereWithoutClientInput | LedgerUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutContentCalendarsInput = {
    create?: XOR<ClientCreateWithoutContentCalendarsInput, ClientUncheckedCreateWithoutContentCalendarsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContentCalendarsInput
    connect?: ClientWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdateOneRequiredWithoutContentCalendarsNestedInput = {
    create?: XOR<ClientCreateWithoutContentCalendarsInput, ClientUncheckedCreateWithoutContentCalendarsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContentCalendarsInput
    upsert?: ClientUpsertWithoutContentCalendarsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutContentCalendarsInput, ClientUpdateWithoutContentCalendarsInput>, ClientUncheckedUpdateWithoutContentCalendarsInput>
  }

  export type ClientCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ClientCreateWithoutCampaignsInput, ClientUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCampaignsInput
    connect?: ClientWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TaskCreateWithoutCampaignInput, TaskUncheckedCreateWithoutCampaignInput> | TaskCreateWithoutCampaignInput[] | TaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCampaignInput | TaskCreateOrConnectWithoutCampaignInput[]
    createMany?: TaskCreateManyCampaignInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AdGroupCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AdGroupCreateWithoutCampaignInput, AdGroupUncheckedCreateWithoutCampaignInput> | AdGroupCreateWithoutCampaignInput[] | AdGroupUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutCampaignInput | AdGroupCreateOrConnectWithoutCampaignInput[]
    createMany?: AdGroupCreateManyCampaignInputEnvelope
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
  }

  export type CampaignMetricCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMetricCreateWithoutCampaignInput, CampaignMetricUncheckedCreateWithoutCampaignInput> | CampaignMetricCreateWithoutCampaignInput[] | CampaignMetricUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricCreateOrConnectWithoutCampaignInput | CampaignMetricCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMetricCreateManyCampaignInputEnvelope
    connect?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TaskCreateWithoutCampaignInput, TaskUncheckedCreateWithoutCampaignInput> | TaskCreateWithoutCampaignInput[] | TaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCampaignInput | TaskCreateOrConnectWithoutCampaignInput[]
    createMany?: TaskCreateManyCampaignInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AdGroupUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AdGroupCreateWithoutCampaignInput, AdGroupUncheckedCreateWithoutCampaignInput> | AdGroupCreateWithoutCampaignInput[] | AdGroupUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutCampaignInput | AdGroupCreateOrConnectWithoutCampaignInput[]
    createMany?: AdGroupCreateManyCampaignInputEnvelope
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
  }

  export type CampaignMetricUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMetricCreateWithoutCampaignInput, CampaignMetricUncheckedCreateWithoutCampaignInput> | CampaignMetricCreateWithoutCampaignInput[] | CampaignMetricUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricCreateOrConnectWithoutCampaignInput | CampaignMetricCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMetricCreateManyCampaignInputEnvelope
    connect?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<ClientCreateWithoutCampaignsInput, ClientUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCampaignsInput
    upsert?: ClientUpsertWithoutCampaignsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutCampaignsInput, ClientUpdateWithoutCampaignsInput>, ClientUncheckedUpdateWithoutCampaignsInput>
  }

  export type TaskUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TaskCreateWithoutCampaignInput, TaskUncheckedCreateWithoutCampaignInput> | TaskCreateWithoutCampaignInput[] | TaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCampaignInput | TaskCreateOrConnectWithoutCampaignInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCampaignInput | TaskUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TaskCreateManyCampaignInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCampaignInput | TaskUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCampaignInput | TaskUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AdGroupUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AdGroupCreateWithoutCampaignInput, AdGroupUncheckedCreateWithoutCampaignInput> | AdGroupCreateWithoutCampaignInput[] | AdGroupUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutCampaignInput | AdGroupCreateOrConnectWithoutCampaignInput[]
    upsert?: AdGroupUpsertWithWhereUniqueWithoutCampaignInput | AdGroupUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AdGroupCreateManyCampaignInputEnvelope
    set?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    disconnect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    delete?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    update?: AdGroupUpdateWithWhereUniqueWithoutCampaignInput | AdGroupUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AdGroupUpdateManyWithWhereWithoutCampaignInput | AdGroupUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AdGroupScalarWhereInput | AdGroupScalarWhereInput[]
  }

  export type CampaignMetricUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMetricCreateWithoutCampaignInput, CampaignMetricUncheckedCreateWithoutCampaignInput> | CampaignMetricCreateWithoutCampaignInput[] | CampaignMetricUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricCreateOrConnectWithoutCampaignInput | CampaignMetricCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMetricUpsertWithWhereUniqueWithoutCampaignInput | CampaignMetricUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMetricCreateManyCampaignInputEnvelope
    set?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    disconnect?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    delete?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    connect?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    update?: CampaignMetricUpdateWithWhereUniqueWithoutCampaignInput | CampaignMetricUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMetricUpdateManyWithWhereWithoutCampaignInput | CampaignMetricUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMetricScalarWhereInput | CampaignMetricScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TaskCreateWithoutCampaignInput, TaskUncheckedCreateWithoutCampaignInput> | TaskCreateWithoutCampaignInput[] | TaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCampaignInput | TaskCreateOrConnectWithoutCampaignInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCampaignInput | TaskUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TaskCreateManyCampaignInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCampaignInput | TaskUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCampaignInput | TaskUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AdGroupUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AdGroupCreateWithoutCampaignInput, AdGroupUncheckedCreateWithoutCampaignInput> | AdGroupCreateWithoutCampaignInput[] | AdGroupUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutCampaignInput | AdGroupCreateOrConnectWithoutCampaignInput[]
    upsert?: AdGroupUpsertWithWhereUniqueWithoutCampaignInput | AdGroupUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AdGroupCreateManyCampaignInputEnvelope
    set?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    disconnect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    delete?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    update?: AdGroupUpdateWithWhereUniqueWithoutCampaignInput | AdGroupUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AdGroupUpdateManyWithWhereWithoutCampaignInput | AdGroupUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AdGroupScalarWhereInput | AdGroupScalarWhereInput[]
  }

  export type CampaignMetricUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMetricCreateWithoutCampaignInput, CampaignMetricUncheckedCreateWithoutCampaignInput> | CampaignMetricCreateWithoutCampaignInput[] | CampaignMetricUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricCreateOrConnectWithoutCampaignInput | CampaignMetricCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMetricUpsertWithWhereUniqueWithoutCampaignInput | CampaignMetricUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMetricCreateManyCampaignInputEnvelope
    set?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    disconnect?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    delete?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    connect?: CampaignMetricWhereUniqueInput | CampaignMetricWhereUniqueInput[]
    update?: CampaignMetricUpdateWithWhereUniqueWithoutCampaignInput | CampaignMetricUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMetricUpdateManyWithWhereWithoutCampaignInput | CampaignMetricUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMetricScalarWhereInput | CampaignMetricScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutAd_accountsInput = {
    create?: XOR<ClientCreateWithoutAd_accountsInput, ClientUncheckedCreateWithoutAd_accountsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAd_accountsInput
    connect?: ClientWhereUniqueInput
  }

  export type AdGroupCreateNestedManyWithoutAd_accountInput = {
    create?: XOR<AdGroupCreateWithoutAd_accountInput, AdGroupUncheckedCreateWithoutAd_accountInput> | AdGroupCreateWithoutAd_accountInput[] | AdGroupUncheckedCreateWithoutAd_accountInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutAd_accountInput | AdGroupCreateOrConnectWithoutAd_accountInput[]
    createMany?: AdGroupCreateManyAd_accountInputEnvelope
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
  }

  export type AdGroupUncheckedCreateNestedManyWithoutAd_accountInput = {
    create?: XOR<AdGroupCreateWithoutAd_accountInput, AdGroupUncheckedCreateWithoutAd_accountInput> | AdGroupCreateWithoutAd_accountInput[] | AdGroupUncheckedCreateWithoutAd_accountInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutAd_accountInput | AdGroupCreateOrConnectWithoutAd_accountInput[]
    createMany?: AdGroupCreateManyAd_accountInputEnvelope
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutAd_accountsNestedInput = {
    create?: XOR<ClientCreateWithoutAd_accountsInput, ClientUncheckedCreateWithoutAd_accountsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAd_accountsInput
    upsert?: ClientUpsertWithoutAd_accountsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAd_accountsInput, ClientUpdateWithoutAd_accountsInput>, ClientUncheckedUpdateWithoutAd_accountsInput>
  }

  export type AdGroupUpdateManyWithoutAd_accountNestedInput = {
    create?: XOR<AdGroupCreateWithoutAd_accountInput, AdGroupUncheckedCreateWithoutAd_accountInput> | AdGroupCreateWithoutAd_accountInput[] | AdGroupUncheckedCreateWithoutAd_accountInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutAd_accountInput | AdGroupCreateOrConnectWithoutAd_accountInput[]
    upsert?: AdGroupUpsertWithWhereUniqueWithoutAd_accountInput | AdGroupUpsertWithWhereUniqueWithoutAd_accountInput[]
    createMany?: AdGroupCreateManyAd_accountInputEnvelope
    set?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    disconnect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    delete?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    update?: AdGroupUpdateWithWhereUniqueWithoutAd_accountInput | AdGroupUpdateWithWhereUniqueWithoutAd_accountInput[]
    updateMany?: AdGroupUpdateManyWithWhereWithoutAd_accountInput | AdGroupUpdateManyWithWhereWithoutAd_accountInput[]
    deleteMany?: AdGroupScalarWhereInput | AdGroupScalarWhereInput[]
  }

  export type AdGroupUncheckedUpdateManyWithoutAd_accountNestedInput = {
    create?: XOR<AdGroupCreateWithoutAd_accountInput, AdGroupUncheckedCreateWithoutAd_accountInput> | AdGroupCreateWithoutAd_accountInput[] | AdGroupUncheckedCreateWithoutAd_accountInput[]
    connectOrCreate?: AdGroupCreateOrConnectWithoutAd_accountInput | AdGroupCreateOrConnectWithoutAd_accountInput[]
    upsert?: AdGroupUpsertWithWhereUniqueWithoutAd_accountInput | AdGroupUpsertWithWhereUniqueWithoutAd_accountInput[]
    createMany?: AdGroupCreateManyAd_accountInputEnvelope
    set?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    disconnect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    delete?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    connect?: AdGroupWhereUniqueInput | AdGroupWhereUniqueInput[]
    update?: AdGroupUpdateWithWhereUniqueWithoutAd_accountInput | AdGroupUpdateWithWhereUniqueWithoutAd_accountInput[]
    updateMany?: AdGroupUpdateManyWithWhereWithoutAd_accountInput | AdGroupUpdateManyWithWhereWithoutAd_accountInput[]
    deleteMany?: AdGroupScalarWhereInput | AdGroupScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutAd_groupsInput = {
    create?: XOR<CampaignCreateWithoutAd_groupsInput, CampaignUncheckedCreateWithoutAd_groupsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAd_groupsInput
    connect?: CampaignWhereUniqueInput
  }

  export type AdAccountCreateNestedOneWithoutAd_groupsInput = {
    create?: XOR<AdAccountCreateWithoutAd_groupsInput, AdAccountUncheckedCreateWithoutAd_groupsInput>
    connectOrCreate?: AdAccountCreateOrConnectWithoutAd_groupsInput
    connect?: AdAccountWhereUniqueInput
  }

  export type AdCreateNestedManyWithoutAd_groupInput = {
    create?: XOR<AdCreateWithoutAd_groupInput, AdUncheckedCreateWithoutAd_groupInput> | AdCreateWithoutAd_groupInput[] | AdUncheckedCreateWithoutAd_groupInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAd_groupInput | AdCreateOrConnectWithoutAd_groupInput[]
    createMany?: AdCreateManyAd_groupInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutAd_groupInput = {
    create?: XOR<AdCreateWithoutAd_groupInput, AdUncheckedCreateWithoutAd_groupInput> | AdCreateWithoutAd_groupInput[] | AdUncheckedCreateWithoutAd_groupInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAd_groupInput | AdCreateOrConnectWithoutAd_groupInput[]
    createMany?: AdCreateManyAd_groupInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutAd_groupsNestedInput = {
    create?: XOR<CampaignCreateWithoutAd_groupsInput, CampaignUncheckedCreateWithoutAd_groupsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAd_groupsInput
    upsert?: CampaignUpsertWithoutAd_groupsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAd_groupsInput, CampaignUpdateWithoutAd_groupsInput>, CampaignUncheckedUpdateWithoutAd_groupsInput>
  }

  export type AdAccountUpdateOneWithoutAd_groupsNestedInput = {
    create?: XOR<AdAccountCreateWithoutAd_groupsInput, AdAccountUncheckedCreateWithoutAd_groupsInput>
    connectOrCreate?: AdAccountCreateOrConnectWithoutAd_groupsInput
    upsert?: AdAccountUpsertWithoutAd_groupsInput
    disconnect?: AdAccountWhereInput | boolean
    delete?: AdAccountWhereInput | boolean
    connect?: AdAccountWhereUniqueInput
    update?: XOR<XOR<AdAccountUpdateToOneWithWhereWithoutAd_groupsInput, AdAccountUpdateWithoutAd_groupsInput>, AdAccountUncheckedUpdateWithoutAd_groupsInput>
  }

  export type AdUpdateManyWithoutAd_groupNestedInput = {
    create?: XOR<AdCreateWithoutAd_groupInput, AdUncheckedCreateWithoutAd_groupInput> | AdCreateWithoutAd_groupInput[] | AdUncheckedCreateWithoutAd_groupInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAd_groupInput | AdCreateOrConnectWithoutAd_groupInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutAd_groupInput | AdUpsertWithWhereUniqueWithoutAd_groupInput[]
    createMany?: AdCreateManyAd_groupInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutAd_groupInput | AdUpdateWithWhereUniqueWithoutAd_groupInput[]
    updateMany?: AdUpdateManyWithWhereWithoutAd_groupInput | AdUpdateManyWithWhereWithoutAd_groupInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutAd_groupNestedInput = {
    create?: XOR<AdCreateWithoutAd_groupInput, AdUncheckedCreateWithoutAd_groupInput> | AdCreateWithoutAd_groupInput[] | AdUncheckedCreateWithoutAd_groupInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAd_groupInput | AdCreateOrConnectWithoutAd_groupInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutAd_groupInput | AdUpsertWithWhereUniqueWithoutAd_groupInput[]
    createMany?: AdCreateManyAd_groupInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutAd_groupInput | AdUpdateWithWhereUniqueWithoutAd_groupInput[]
    updateMany?: AdUpdateManyWithWhereWithoutAd_groupInput | AdUpdateManyWithWhereWithoutAd_groupInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdGroupCreateNestedOneWithoutAdsInput = {
    create?: XOR<AdGroupCreateWithoutAdsInput, AdGroupUncheckedCreateWithoutAdsInput>
    connectOrCreate?: AdGroupCreateOrConnectWithoutAdsInput
    connect?: AdGroupWhereUniqueInput
  }

  export type AssetCreateNestedOneWithoutAdsInput = {
    create?: XOR<AssetCreateWithoutAdsInput, AssetUncheckedCreateWithoutAdsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAdsInput
    connect?: AssetWhereUniqueInput
  }

  export type SpendSnapshotCreateNestedManyWithoutAdInput = {
    create?: XOR<SpendSnapshotCreateWithoutAdInput, SpendSnapshotUncheckedCreateWithoutAdInput> | SpendSnapshotCreateWithoutAdInput[] | SpendSnapshotUncheckedCreateWithoutAdInput[]
    connectOrCreate?: SpendSnapshotCreateOrConnectWithoutAdInput | SpendSnapshotCreateOrConnectWithoutAdInput[]
    createMany?: SpendSnapshotCreateManyAdInputEnvelope
    connect?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
  }

  export type SpendSnapshotUncheckedCreateNestedManyWithoutAdInput = {
    create?: XOR<SpendSnapshotCreateWithoutAdInput, SpendSnapshotUncheckedCreateWithoutAdInput> | SpendSnapshotCreateWithoutAdInput[] | SpendSnapshotUncheckedCreateWithoutAdInput[]
    connectOrCreate?: SpendSnapshotCreateOrConnectWithoutAdInput | SpendSnapshotCreateOrConnectWithoutAdInput[]
    createMany?: SpendSnapshotCreateManyAdInputEnvelope
    connect?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
  }

  export type AdGroupUpdateOneRequiredWithoutAdsNestedInput = {
    create?: XOR<AdGroupCreateWithoutAdsInput, AdGroupUncheckedCreateWithoutAdsInput>
    connectOrCreate?: AdGroupCreateOrConnectWithoutAdsInput
    upsert?: AdGroupUpsertWithoutAdsInput
    connect?: AdGroupWhereUniqueInput
    update?: XOR<XOR<AdGroupUpdateToOneWithWhereWithoutAdsInput, AdGroupUpdateWithoutAdsInput>, AdGroupUncheckedUpdateWithoutAdsInput>
  }

  export type AssetUpdateOneWithoutAdsNestedInput = {
    create?: XOR<AssetCreateWithoutAdsInput, AssetUncheckedCreateWithoutAdsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutAdsInput
    upsert?: AssetUpsertWithoutAdsInput
    disconnect?: AssetWhereInput | boolean
    delete?: AssetWhereInput | boolean
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutAdsInput, AssetUpdateWithoutAdsInput>, AssetUncheckedUpdateWithoutAdsInput>
  }

  export type SpendSnapshotUpdateManyWithoutAdNestedInput = {
    create?: XOR<SpendSnapshotCreateWithoutAdInput, SpendSnapshotUncheckedCreateWithoutAdInput> | SpendSnapshotCreateWithoutAdInput[] | SpendSnapshotUncheckedCreateWithoutAdInput[]
    connectOrCreate?: SpendSnapshotCreateOrConnectWithoutAdInput | SpendSnapshotCreateOrConnectWithoutAdInput[]
    upsert?: SpendSnapshotUpsertWithWhereUniqueWithoutAdInput | SpendSnapshotUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: SpendSnapshotCreateManyAdInputEnvelope
    set?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    disconnect?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    delete?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    connect?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    update?: SpendSnapshotUpdateWithWhereUniqueWithoutAdInput | SpendSnapshotUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: SpendSnapshotUpdateManyWithWhereWithoutAdInput | SpendSnapshotUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: SpendSnapshotScalarWhereInput | SpendSnapshotScalarWhereInput[]
  }

  export type SpendSnapshotUncheckedUpdateManyWithoutAdNestedInput = {
    create?: XOR<SpendSnapshotCreateWithoutAdInput, SpendSnapshotUncheckedCreateWithoutAdInput> | SpendSnapshotCreateWithoutAdInput[] | SpendSnapshotUncheckedCreateWithoutAdInput[]
    connectOrCreate?: SpendSnapshotCreateOrConnectWithoutAdInput | SpendSnapshotCreateOrConnectWithoutAdInput[]
    upsert?: SpendSnapshotUpsertWithWhereUniqueWithoutAdInput | SpendSnapshotUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: SpendSnapshotCreateManyAdInputEnvelope
    set?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    disconnect?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    delete?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    connect?: SpendSnapshotWhereUniqueInput | SpendSnapshotWhereUniqueInput[]
    update?: SpendSnapshotUpdateWithWhereUniqueWithoutAdInput | SpendSnapshotUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: SpendSnapshotUpdateManyWithWhereWithoutAdInput | SpendSnapshotUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: SpendSnapshotScalarWhereInput | SpendSnapshotScalarWhereInput[]
  }

  export type AdCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<AdCreateWithoutSnapshotsInput, AdUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: AdCreateOrConnectWithoutSnapshotsInput
    connect?: AdWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<AdCreateWithoutSnapshotsInput, AdUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: AdCreateOrConnectWithoutSnapshotsInput
    upsert?: AdUpsertWithoutSnapshotsInput
    connect?: AdWhereUniqueInput
    update?: XOR<XOR<AdUpdateToOneWithWhereWithoutSnapshotsInput, AdUpdateWithoutSnapshotsInput>, AdUncheckedUpdateWithoutSnapshotsInput>
  }

  export type CampaignCreateNestedOneWithoutMetricsInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    upsert?: CampaignUpsertWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMetricsInput, CampaignUpdateWithoutMetricsInput>, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type LedgerCreateNestedManyWithoutAccount_headInput = {
    create?: XOR<LedgerCreateWithoutAccount_headInput, LedgerUncheckedCreateWithoutAccount_headInput> | LedgerCreateWithoutAccount_headInput[] | LedgerUncheckedCreateWithoutAccount_headInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutAccount_headInput | LedgerCreateOrConnectWithoutAccount_headInput[]
    createMany?: LedgerCreateManyAccount_headInputEnvelope
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
  }

  export type JournalLineCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type LedgerUncheckedCreateNestedManyWithoutAccount_headInput = {
    create?: XOR<LedgerCreateWithoutAccount_headInput, LedgerUncheckedCreateWithoutAccount_headInput> | LedgerCreateWithoutAccount_headInput[] | LedgerUncheckedCreateWithoutAccount_headInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutAccount_headInput | LedgerCreateOrConnectWithoutAccount_headInput[]
    createMany?: LedgerCreateManyAccount_headInputEnvelope
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LedgerUpdateManyWithoutAccount_headNestedInput = {
    create?: XOR<LedgerCreateWithoutAccount_headInput, LedgerUncheckedCreateWithoutAccount_headInput> | LedgerCreateWithoutAccount_headInput[] | LedgerUncheckedCreateWithoutAccount_headInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutAccount_headInput | LedgerCreateOrConnectWithoutAccount_headInput[]
    upsert?: LedgerUpsertWithWhereUniqueWithoutAccount_headInput | LedgerUpsertWithWhereUniqueWithoutAccount_headInput[]
    createMany?: LedgerCreateManyAccount_headInputEnvelope
    set?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    disconnect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    delete?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    update?: LedgerUpdateWithWhereUniqueWithoutAccount_headInput | LedgerUpdateWithWhereUniqueWithoutAccount_headInput[]
    updateMany?: LedgerUpdateManyWithWhereWithoutAccount_headInput | LedgerUpdateManyWithWhereWithoutAccount_headInput[]
    deleteMany?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
  }

  export type JournalLineUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type LedgerUncheckedUpdateManyWithoutAccount_headNestedInput = {
    create?: XOR<LedgerCreateWithoutAccount_headInput, LedgerUncheckedCreateWithoutAccount_headInput> | LedgerCreateWithoutAccount_headInput[] | LedgerUncheckedCreateWithoutAccount_headInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutAccount_headInput | LedgerCreateOrConnectWithoutAccount_headInput[]
    upsert?: LedgerUpsertWithWhereUniqueWithoutAccount_headInput | LedgerUpsertWithWhereUniqueWithoutAccount_headInput[]
    createMany?: LedgerCreateManyAccount_headInputEnvelope
    set?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    disconnect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    delete?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    update?: LedgerUpdateWithWhereUniqueWithoutAccount_headInput | LedgerUpdateWithWhereUniqueWithoutAccount_headInput[]
    updateMany?: LedgerUpdateManyWithWhereWithoutAccount_headInput | LedgerUpdateManyWithWhereWithoutAccount_headInput[]
    deleteMany?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AccountHeadCreateNestedOneWithoutLedgersInput = {
    create?: XOR<AccountHeadCreateWithoutLedgersInput, AccountHeadUncheckedCreateWithoutLedgersInput>
    connectOrCreate?: AccountHeadCreateOrConnectWithoutLedgersInput
    connect?: AccountHeadWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutLedgersInput = {
    create?: XOR<ClientCreateWithoutLedgersInput, ClientUncheckedCreateWithoutLedgersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLedgersInput
    connect?: ClientWhereUniqueInput
  }

  export type AccountHeadUpdateOneRequiredWithoutLedgersNestedInput = {
    create?: XOR<AccountHeadCreateWithoutLedgersInput, AccountHeadUncheckedCreateWithoutLedgersInput>
    connectOrCreate?: AccountHeadCreateOrConnectWithoutLedgersInput
    upsert?: AccountHeadUpsertWithoutLedgersInput
    connect?: AccountHeadWhereUniqueInput
    update?: XOR<XOR<AccountHeadUpdateToOneWithWhereWithoutLedgersInput, AccountHeadUpdateWithoutLedgersInput>, AccountHeadUncheckedUpdateWithoutLedgersInput>
  }

  export type ClientUpdateOneWithoutLedgersNestedInput = {
    create?: XOR<ClientCreateWithoutLedgersInput, ClientUncheckedCreateWithoutLedgersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLedgersInput
    upsert?: ClientUpsertWithoutLedgersInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutLedgersInput, ClientUpdateWithoutLedgersInput>, ClientUncheckedUpdateWithoutLedgersInput>
  }

  export type JournalLineCreateNestedManyWithoutEntryInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutJournal_entryInput = {
    create?: XOR<InvoiceCreateWithoutJournal_entryInput, InvoiceUncheckedCreateWithoutJournal_entryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutJournal_entryInput
    connect?: InvoiceWhereUniqueInput
  }

  export type JournalLineUncheckedCreateNestedManyWithoutEntryInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutJournal_entryInput = {
    create?: XOR<InvoiceCreateWithoutJournal_entryInput, InvoiceUncheckedCreateWithoutJournal_entryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutJournal_entryInput
    connect?: InvoiceWhereUniqueInput
  }

  export type JournalLineUpdateManyWithoutEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutEntryInput | JournalLineUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutEntryInput | JournalLineUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutEntryInput | JournalLineUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutJournal_entryNestedInput = {
    create?: XOR<InvoiceCreateWithoutJournal_entryInput, InvoiceUncheckedCreateWithoutJournal_entryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutJournal_entryInput
    upsert?: InvoiceUpsertWithoutJournal_entryInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutJournal_entryInput, InvoiceUpdateWithoutJournal_entryInput>, InvoiceUncheckedUpdateWithoutJournal_entryInput>
  }

  export type JournalLineUncheckedUpdateManyWithoutEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutEntryInput | JournalLineUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutEntryInput | JournalLineUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutEntryInput | JournalLineUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutJournal_entryNestedInput = {
    create?: XOR<InvoiceCreateWithoutJournal_entryInput, InvoiceUncheckedCreateWithoutJournal_entryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutJournal_entryInput
    upsert?: InvoiceUpsertWithoutJournal_entryInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutJournal_entryInput, InvoiceUpdateWithoutJournal_entryInput>, InvoiceUncheckedUpdateWithoutJournal_entryInput>
  }

  export type JournalEntryCreateNestedOneWithoutLinesInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type AccountHeadCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<AccountHeadCreateWithoutJournalLinesInput, AccountHeadUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AccountHeadCreateOrConnectWithoutJournalLinesInput
    connect?: AccountHeadWhereUniqueInput
  }

  export type JournalEntryUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    upsert?: JournalEntryUpsertWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<XOR<JournalEntryUpdateToOneWithWhereWithoutLinesInput, JournalEntryUpdateWithoutLinesInput>, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type AccountHeadUpdateOneRequiredWithoutJournalLinesNestedInput = {
    create?: XOR<AccountHeadCreateWithoutJournalLinesInput, AccountHeadUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AccountHeadCreateOrConnectWithoutJournalLinesInput
    upsert?: AccountHeadUpsertWithoutJournalLinesInput
    connect?: AccountHeadWhereUniqueInput
    update?: XOR<XOR<AccountHeadUpdateToOneWithWhereWithoutJournalLinesInput, AccountHeadUpdateWithoutJournalLinesInput>, AccountHeadUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ClientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<JournalEntryCreateWithoutInvoiceInput, JournalEntryUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutInvoiceInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    upsert?: ClientUpsertWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutInvoicesInput, ClientUpdateWithoutInvoicesInput>, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type JournalEntryUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<JournalEntryCreateWithoutInvoiceInput, JournalEntryUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutInvoiceInput
    upsert?: JournalEntryUpsertWithoutInvoiceInput
    disconnect?: JournalEntryWhereInput | boolean
    delete?: JournalEntryWhereInput | boolean
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<XOR<JournalEntryUpdateToOneWithWhereWithoutInvoiceInput, JournalEntryUpdateWithoutInvoiceInput>, JournalEntryUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type CampaignCreateNestedOneWithoutTasksInput = {
    create?: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTasksInput
    connect?: CampaignWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutTasksInput = {
    create?: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTasksInput
    connect?: ClientWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutSub_tasksInput = {
    create?: XOR<TaskCreateWithoutSub_tasksInput, TaskUncheckedCreateWithoutSub_tasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSub_tasksInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutParent_taskInput = {
    create?: XOR<TaskCreateWithoutParent_taskInput, TaskUncheckedCreateWithoutParent_taskInput> | TaskCreateWithoutParent_taskInput[] | TaskUncheckedCreateWithoutParent_taskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParent_taskInput | TaskCreateOrConnectWithoutParent_taskInput[]
    createMany?: TaskCreateManyParent_taskInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskDependencyCreateNestedManyWithoutBlocking_taskInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocking_taskInput, TaskDependencyUncheckedCreateWithoutBlocking_taskInput> | TaskDependencyCreateWithoutBlocking_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocking_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocking_taskInput | TaskDependencyCreateOrConnectWithoutBlocking_taskInput[]
    createMany?: TaskDependencyCreateManyBlocking_taskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskDependencyCreateNestedManyWithoutBlocked_taskInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocked_taskInput, TaskDependencyUncheckedCreateWithoutBlocked_taskInput> | TaskDependencyCreateWithoutBlocked_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocked_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocked_taskInput | TaskDependencyCreateOrConnectWithoutBlocked_taskInput[]
    createMany?: TaskDependencyCreateManyBlocked_taskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTasksAssignedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksReportedInput = {
    create?: XOR<UserCreateWithoutTasksReportedInput, UserUncheckedCreateWithoutTasksReportedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksReportedInput
    connect?: UserWhereUniqueInput
  }

  export type AssetCreateNestedManyWithoutTaskInput = {
    create?: XOR<AssetCreateWithoutTaskInput, AssetUncheckedCreateWithoutTaskInput> | AssetCreateWithoutTaskInput[] | AssetUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTaskInput | AssetCreateOrConnectWithoutTaskInput[]
    createMany?: AssetCreateManyTaskInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutParent_taskInput = {
    create?: XOR<TaskCreateWithoutParent_taskInput, TaskUncheckedCreateWithoutParent_taskInput> | TaskCreateWithoutParent_taskInput[] | TaskUncheckedCreateWithoutParent_taskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParent_taskInput | TaskCreateOrConnectWithoutParent_taskInput[]
    createMany?: TaskCreateManyParent_taskInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocking_taskInput, TaskDependencyUncheckedCreateWithoutBlocking_taskInput> | TaskDependencyCreateWithoutBlocking_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocking_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocking_taskInput | TaskDependencyCreateOrConnectWithoutBlocking_taskInput[]
    createMany?: TaskDependencyCreateManyBlocking_taskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocked_taskInput, TaskDependencyUncheckedCreateWithoutBlocked_taskInput> | TaskDependencyCreateWithoutBlocked_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocked_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocked_taskInput | TaskDependencyCreateOrConnectWithoutBlocked_taskInput[]
    createMany?: TaskDependencyCreateManyBlocked_taskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<AssetCreateWithoutTaskInput, AssetUncheckedCreateWithoutTaskInput> | AssetCreateWithoutTaskInput[] | AssetUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTaskInput | AssetCreateOrConnectWithoutTaskInput[]
    createMany?: AssetCreateManyTaskInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type CampaignUpdateOneWithoutTasksNestedInput = {
    create?: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTasksInput
    upsert?: CampaignUpsertWithoutTasksInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTasksInput, CampaignUpdateWithoutTasksInput>, CampaignUncheckedUpdateWithoutTasksInput>
  }

  export type ClientUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTasksInput
    upsert?: ClientUpsertWithoutTasksInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTasksInput, ClientUpdateWithoutTasksInput>, ClientUncheckedUpdateWithoutTasksInput>
  }

  export type TaskUpdateOneWithoutSub_tasksNestedInput = {
    create?: XOR<TaskCreateWithoutSub_tasksInput, TaskUncheckedCreateWithoutSub_tasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSub_tasksInput
    upsert?: TaskUpsertWithoutSub_tasksInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSub_tasksInput, TaskUpdateWithoutSub_tasksInput>, TaskUncheckedUpdateWithoutSub_tasksInput>
  }

  export type TaskUpdateManyWithoutParent_taskNestedInput = {
    create?: XOR<TaskCreateWithoutParent_taskInput, TaskUncheckedCreateWithoutParent_taskInput> | TaskCreateWithoutParent_taskInput[] | TaskUncheckedCreateWithoutParent_taskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParent_taskInput | TaskCreateOrConnectWithoutParent_taskInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutParent_taskInput | TaskUpsertWithWhereUniqueWithoutParent_taskInput[]
    createMany?: TaskCreateManyParent_taskInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutParent_taskInput | TaskUpdateWithWhereUniqueWithoutParent_taskInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutParent_taskInput | TaskUpdateManyWithWhereWithoutParent_taskInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskDependencyUpdateManyWithoutBlocking_taskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocking_taskInput, TaskDependencyUncheckedCreateWithoutBlocking_taskInput> | TaskDependencyCreateWithoutBlocking_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocking_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocking_taskInput | TaskDependencyCreateOrConnectWithoutBlocking_taskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutBlocking_taskInput | TaskDependencyUpsertWithWhereUniqueWithoutBlocking_taskInput[]
    createMany?: TaskDependencyCreateManyBlocking_taskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutBlocking_taskInput | TaskDependencyUpdateWithWhereUniqueWithoutBlocking_taskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutBlocking_taskInput | TaskDependencyUpdateManyWithWhereWithoutBlocking_taskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskDependencyUpdateManyWithoutBlocked_taskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocked_taskInput, TaskDependencyUncheckedCreateWithoutBlocked_taskInput> | TaskDependencyCreateWithoutBlocked_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocked_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocked_taskInput | TaskDependencyCreateOrConnectWithoutBlocked_taskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutBlocked_taskInput | TaskDependencyUpsertWithWhereUniqueWithoutBlocked_taskInput[]
    createMany?: TaskDependencyCreateManyBlocked_taskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutBlocked_taskInput | TaskDependencyUpdateWithWhereUniqueWithoutBlocked_taskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutBlocked_taskInput | TaskDependencyUpdateManyWithWhereWithoutBlocked_taskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type UserUpdateOneWithoutTasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    upsert?: UserUpsertWithoutTasksAssignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksAssignedInput, UserUpdateWithoutTasksAssignedInput>, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateOneRequiredWithoutTasksReportedNestedInput = {
    create?: XOR<UserCreateWithoutTasksReportedInput, UserUncheckedCreateWithoutTasksReportedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksReportedInput
    upsert?: UserUpsertWithoutTasksReportedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksReportedInput, UserUpdateWithoutTasksReportedInput>, UserUncheckedUpdateWithoutTasksReportedInput>
  }

  export type AssetUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AssetCreateWithoutTaskInput, AssetUncheckedCreateWithoutTaskInput> | AssetCreateWithoutTaskInput[] | AssetUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTaskInput | AssetCreateOrConnectWithoutTaskInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutTaskInput | AssetUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AssetCreateManyTaskInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutTaskInput | AssetUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutTaskInput | AssetUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutTaskInput | TimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutTaskInput | TimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutTaskInput | TimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutParent_taskNestedInput = {
    create?: XOR<TaskCreateWithoutParent_taskInput, TaskUncheckedCreateWithoutParent_taskInput> | TaskCreateWithoutParent_taskInput[] | TaskUncheckedCreateWithoutParent_taskInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutParent_taskInput | TaskCreateOrConnectWithoutParent_taskInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutParent_taskInput | TaskUpsertWithWhereUniqueWithoutParent_taskInput[]
    createMany?: TaskCreateManyParent_taskInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutParent_taskInput | TaskUpdateWithWhereUniqueWithoutParent_taskInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutParent_taskInput | TaskUpdateManyWithWhereWithoutParent_taskInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocking_taskInput, TaskDependencyUncheckedCreateWithoutBlocking_taskInput> | TaskDependencyCreateWithoutBlocking_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocking_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocking_taskInput | TaskDependencyCreateOrConnectWithoutBlocking_taskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutBlocking_taskInput | TaskDependencyUpsertWithWhereUniqueWithoutBlocking_taskInput[]
    createMany?: TaskDependencyCreateManyBlocking_taskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutBlocking_taskInput | TaskDependencyUpdateWithWhereUniqueWithoutBlocking_taskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutBlocking_taskInput | TaskDependencyUpdateManyWithWhereWithoutBlocking_taskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutBlocked_taskInput, TaskDependencyUncheckedCreateWithoutBlocked_taskInput> | TaskDependencyCreateWithoutBlocked_taskInput[] | TaskDependencyUncheckedCreateWithoutBlocked_taskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutBlocked_taskInput | TaskDependencyCreateOrConnectWithoutBlocked_taskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutBlocked_taskInput | TaskDependencyUpsertWithWhereUniqueWithoutBlocked_taskInput[]
    createMany?: TaskDependencyCreateManyBlocked_taskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutBlocked_taskInput | TaskDependencyUpdateWithWhereUniqueWithoutBlocked_taskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutBlocked_taskInput | TaskDependencyUpdateManyWithWhereWithoutBlocked_taskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AssetCreateWithoutTaskInput, AssetUncheckedCreateWithoutTaskInput> | AssetCreateWithoutTaskInput[] | AssetUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTaskInput | AssetCreateOrConnectWithoutTaskInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutTaskInput | AssetUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AssetCreateManyTaskInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutTaskInput | AssetUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutTaskInput | AssetUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutTaskInput | TimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutTaskInput | TimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutTaskInput | TimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutDependentsInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput
    upsert?: TaskUpsertWithoutDependenciesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependenciesInput, TaskUpdateWithoutDependenciesInput>, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type TaskUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    upsert?: TaskUpsertWithoutDependentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependentsInput, TaskUpdateWithoutDependentsInput>, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskCreateNestedOneWithoutAssetsInput = {
    create?: XOR<TaskCreateWithoutAssetsInput, TaskUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssetsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssetsUploadedInput = {
    create?: XOR<UserCreateWithoutAssetsUploadedInput, UserUncheckedCreateWithoutAssetsUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetsUploadedInput
    connect?: UserWhereUniqueInput
  }

  export type AssetCommentCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetCommentCreateWithoutAssetInput, AssetCommentUncheckedCreateWithoutAssetInput> | AssetCommentCreateWithoutAssetInput[] | AssetCommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAssetInput | AssetCommentCreateOrConnectWithoutAssetInput[]
    createMany?: AssetCommentCreateManyAssetInputEnvelope
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutCreativeInput = {
    create?: XOR<AdCreateWithoutCreativeInput, AdUncheckedCreateWithoutCreativeInput> | AdCreateWithoutCreativeInput[] | AdUncheckedCreateWithoutCreativeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCreativeInput | AdCreateOrConnectWithoutCreativeInput[]
    createMany?: AdCreateManyCreativeInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AssetCommentUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetCommentCreateWithoutAssetInput, AssetCommentUncheckedCreateWithoutAssetInput> | AssetCommentCreateWithoutAssetInput[] | AssetCommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAssetInput | AssetCommentCreateOrConnectWithoutAssetInput[]
    createMany?: AssetCommentCreateManyAssetInputEnvelope
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutCreativeInput = {
    create?: XOR<AdCreateWithoutCreativeInput, AdUncheckedCreateWithoutCreativeInput> | AdCreateWithoutCreativeInput[] | AdUncheckedCreateWithoutCreativeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCreativeInput | AdCreateOrConnectWithoutCreativeInput[]
    createMany?: AdCreateManyCreativeInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaskUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<TaskCreateWithoutAssetsInput, TaskUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAssetsInput
    upsert?: TaskUpsertWithoutAssetsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAssetsInput, TaskUpdateWithoutAssetsInput>, TaskUncheckedUpdateWithoutAssetsInput>
  }

  export type UserUpdateOneRequiredWithoutAssetsUploadedNestedInput = {
    create?: XOR<UserCreateWithoutAssetsUploadedInput, UserUncheckedCreateWithoutAssetsUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetsUploadedInput
    upsert?: UserUpsertWithoutAssetsUploadedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetsUploadedInput, UserUpdateWithoutAssetsUploadedInput>, UserUncheckedUpdateWithoutAssetsUploadedInput>
  }

  export type AssetCommentUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetCommentCreateWithoutAssetInput, AssetCommentUncheckedCreateWithoutAssetInput> | AssetCommentCreateWithoutAssetInput[] | AssetCommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAssetInput | AssetCommentCreateOrConnectWithoutAssetInput[]
    upsert?: AssetCommentUpsertWithWhereUniqueWithoutAssetInput | AssetCommentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetCommentCreateManyAssetInputEnvelope
    set?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    disconnect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    delete?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    update?: AssetCommentUpdateWithWhereUniqueWithoutAssetInput | AssetCommentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetCommentUpdateManyWithWhereWithoutAssetInput | AssetCommentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetCommentScalarWhereInput | AssetCommentScalarWhereInput[]
  }

  export type AdUpdateManyWithoutCreativeNestedInput = {
    create?: XOR<AdCreateWithoutCreativeInput, AdUncheckedCreateWithoutCreativeInput> | AdCreateWithoutCreativeInput[] | AdUncheckedCreateWithoutCreativeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCreativeInput | AdCreateOrConnectWithoutCreativeInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutCreativeInput | AdUpsertWithWhereUniqueWithoutCreativeInput[]
    createMany?: AdCreateManyCreativeInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutCreativeInput | AdUpdateWithWhereUniqueWithoutCreativeInput[]
    updateMany?: AdUpdateManyWithWhereWithoutCreativeInput | AdUpdateManyWithWhereWithoutCreativeInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AssetCommentUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetCommentCreateWithoutAssetInput, AssetCommentUncheckedCreateWithoutAssetInput> | AssetCommentCreateWithoutAssetInput[] | AssetCommentUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetCommentCreateOrConnectWithoutAssetInput | AssetCommentCreateOrConnectWithoutAssetInput[]
    upsert?: AssetCommentUpsertWithWhereUniqueWithoutAssetInput | AssetCommentUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetCommentCreateManyAssetInputEnvelope
    set?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    disconnect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    delete?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    connect?: AssetCommentWhereUniqueInput | AssetCommentWhereUniqueInput[]
    update?: AssetCommentUpdateWithWhereUniqueWithoutAssetInput | AssetCommentUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetCommentUpdateManyWithWhereWithoutAssetInput | AssetCommentUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetCommentScalarWhereInput | AssetCommentScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutCreativeNestedInput = {
    create?: XOR<AdCreateWithoutCreativeInput, AdUncheckedCreateWithoutCreativeInput> | AdCreateWithoutCreativeInput[] | AdUncheckedCreateWithoutCreativeInput[]
    connectOrCreate?: AdCreateOrConnectWithoutCreativeInput | AdCreateOrConnectWithoutCreativeInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutCreativeInput | AdUpsertWithWhereUniqueWithoutCreativeInput[]
    createMany?: AdCreateManyCreativeInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutCreativeInput | AdUpdateWithWhereUniqueWithoutCreativeInput[]
    updateMany?: AdUpdateManyWithWhereWithoutCreativeInput | AdUpdateManyWithWhereWithoutCreativeInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParent_commentInput = {
    create?: XOR<CommentCreateWithoutParent_commentInput, CommentUncheckedCreateWithoutParent_commentInput> | CommentCreateWithoutParent_commentInput[] | CommentUncheckedCreateWithoutParent_commentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParent_commentInput | CommentCreateOrConnectWithoutParent_commentInput[]
    createMany?: CommentCreateManyParent_commentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParent_commentInput = {
    create?: XOR<CommentCreateWithoutParent_commentInput, CommentUncheckedCreateWithoutParent_commentInput> | CommentCreateWithoutParent_commentInput[] | CommentUncheckedCreateWithoutParent_commentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParent_commentInput | CommentCreateOrConnectWithoutParent_commentInput[]
    createMany?: CommentCreateManyParent_commentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParent_commentNestedInput = {
    create?: XOR<CommentCreateWithoutParent_commentInput, CommentUncheckedCreateWithoutParent_commentInput> | CommentCreateWithoutParent_commentInput[] | CommentUncheckedCreateWithoutParent_commentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParent_commentInput | CommentCreateOrConnectWithoutParent_commentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParent_commentInput | CommentUpsertWithWhereUniqueWithoutParent_commentInput[]
    createMany?: CommentCreateManyParent_commentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParent_commentInput | CommentUpdateWithWhereUniqueWithoutParent_commentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParent_commentInput | CommentUpdateManyWithWhereWithoutParent_commentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParent_commentNestedInput = {
    create?: XOR<CommentCreateWithoutParent_commentInput, CommentUncheckedCreateWithoutParent_commentInput> | CommentCreateWithoutParent_commentInput[] | CommentUncheckedCreateWithoutParent_commentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParent_commentInput | CommentCreateOrConnectWithoutParent_commentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParent_commentInput | CommentUpsertWithWhereUniqueWithoutParent_commentInput[]
    createMany?: CommentCreateManyParent_commentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParent_commentInput | CommentUpdateWithWhereUniqueWithoutParent_commentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParent_commentInput | CommentUpdateManyWithWhereWithoutParent_commentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutCommentsInput
    connect?: AssetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssetCommentsInput = {
    create?: XOR<UserCreateWithoutAssetCommentsInput, UserUncheckedCreateWithoutAssetCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutCommentsInput
    upsert?: AssetUpsertWithoutCommentsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutCommentsInput, AssetUpdateWithoutCommentsInput>, AssetUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssetCommentsNestedInput = {
    create?: XOR<UserCreateWithoutAssetCommentsInput, UserUncheckedCreateWithoutAssetCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetCommentsInput
    upsert?: UserUpsertWithoutAssetCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetCommentsInput, UserUpdateWithoutAssetCommentsInput>, UserUncheckedUpdateWithoutAssetCommentsInput>
  }

  export type TaskCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    upsert?: TaskUpsertWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimeLogsInput, TaskUpdateWithoutTimeLogsInput>, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    upsert?: UserUpsertWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeLogsInput, UserUpdateWithoutTimeLogsInput>, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ClientCreateWithoutAccount_managerInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAccount_managerInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAccount_managerInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAccount_managerInput, ClientUncheckedCreateWithoutAccount_managerInput>
  }

  export type ClientCreateManyAccount_managerInputEnvelope = {
    data: ClientCreateManyAccount_managerInput | ClientCreateManyAccount_managerInput[]
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
  }

  export type TaskCreateWithoutReporterInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutReporterInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutReporterInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutReporterInput, TaskUncheckedCreateWithoutReporterInput>
  }

  export type TaskCreateManyReporterInputEnvelope = {
    data: TaskCreateManyReporterInput | TaskCreateManyReporterInput[]
  }

  export type TimeLogCreateWithoutUserInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutUserInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    task_id: string
  }

  export type TimeLogCreateOrConnectWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeLogCreateManyUserInputEnvelope = {
    data: TimeLogCreateManyUserInput | TimeLogCreateManyUserInput[]
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    parent_comment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParent_commentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    parent_comment_id?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParent_commentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type AssetCreateWithoutUploaderInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAssetsInput
    comments?: AssetCommentCreateNestedManyWithoutAssetInput
    ads?: AdCreateNestedManyWithoutCreativeInput
  }

  export type AssetUncheckedCreateWithoutUploaderInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task_id: string
    comments?: AssetCommentUncheckedCreateNestedManyWithoutAssetInput
    ads?: AdUncheckedCreateNestedManyWithoutCreativeInput
  }

  export type AssetCreateOrConnectWithoutUploaderInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutUploaderInput, AssetUncheckedCreateWithoutUploaderInput>
  }

  export type AssetCreateManyUploaderInputEnvelope = {
    data: AssetCreateManyUploaderInput | AssetCreateManyUploaderInput[]
  }

  export type AssetCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutCommentsInput
  }

  export type AssetCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    asset_id: string
  }

  export type AssetCommentCreateOrConnectWithoutAuthorInput = {
    where: AssetCommentWhereUniqueInput
    create: XOR<AssetCommentCreateWithoutAuthorInput, AssetCommentUncheckedCreateWithoutAuthorInput>
  }

  export type AssetCommentCreateManyAuthorInputEnvelope = {
    data: AssetCommentCreateManyAuthorInput | AssetCommentCreateManyAuthorInput[]
  }

  export type ClientUpsertWithWhereUniqueWithoutAccount_managerInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutAccount_managerInput, ClientUncheckedUpdateWithoutAccount_managerInput>
    create: XOR<ClientCreateWithoutAccount_managerInput, ClientUncheckedCreateWithoutAccount_managerInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutAccount_managerInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutAccount_managerInput, ClientUncheckedUpdateWithoutAccount_managerInput>
  }

  export type ClientUpdateManyWithWhereWithoutAccount_managerInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutAccount_managerInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    brand_colors?: StringNullableFilter<"Client"> | string | null
    logo_url?: StringNullableFilter<"Client"> | string | null
    industry?: StringNullableFilter<"Client"> | string | null
    contract_type?: StringNullableFilter<"Client"> | string | null
    client_number?: StringNullableFilter<"Client"> | string | null
    onboarding_date?: DateTimeNullableFilter<"Client"> | Date | string | null
    address?: StringNullableFilter<"Client"> | string | null
    contact_person?: StringNullableFilter<"Client"> | string | null
    contact_number?: StringNullableFilter<"Client"> | string | null
    website?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    whatsapp?: StringNullableFilter<"Client"> | string | null
    facebook?: StringNullableFilter<"Client"> | string | null
    instagram?: StringNullableFilter<"Client"> | string | null
    linkedin?: StringNullableFilter<"Client"> | string | null
    youtube?: StringNullableFilter<"Client"> | string | null
    competitorDetails?: StringNullableFilter<"Client"> | string | null
    customerAvatar?: StringNullableFilter<"Client"> | string | null
    contentSuggestions?: StringNullableFilter<"Client"> | string | null
    referenceLinks?: StringNullableFilter<"Client"> | string | null
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    account_manager_id?: StringNullableFilter<"Client"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    platform?: StringNullableFilter<"Task"> | string | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    actual_start_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    completed_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimated_hours?: FloatNullableFilter<"Task"> | number | null
    time_estimate?: FloatNullableFilter<"Task"> | number | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    campaign_id?: StringNullableFilter<"Task"> | string | null
    client_id?: StringNullableFilter<"Task"> | string | null
    parent_task_id?: StringNullableFilter<"Task"> | string | null
    assignee_id?: StringNullableFilter<"Task"> | string | null
    reporter_id?: StringFilter<"Task"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutReporterInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutReporterInput, TaskUncheckedUpdateWithoutReporterInput>
    create: XOR<TaskCreateWithoutReporterInput, TaskUncheckedCreateWithoutReporterInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutReporterInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutReporterInput, TaskUncheckedUpdateWithoutReporterInput>
  }

  export type TaskUpdateManyWithWhereWithoutReporterInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutReporterInput>
  }

  export type TimeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutUserInput, TimeLogUncheckedUpdateWithoutUserInput>
    create: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutUserInput, TimeLogUncheckedUpdateWithoutUserInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutUserInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeLogScalarWhereInput = {
    AND?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    OR?: TimeLogScalarWhereInput[]
    NOT?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    id?: StringFilter<"TimeLog"> | string
    start_time?: DateTimeFilter<"TimeLog"> | Date | string
    end_time?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    duration_minutes?: IntNullableFilter<"TimeLog"> | number | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    task_id?: StringFilter<"TimeLog"> | string
    user_id?: StringFilter<"TimeLog"> | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    is_revision_request?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    task_id?: StringFilter<"Comment"> | string
    author_id?: StringFilter<"Comment"> | string
    parent_comment_id?: StringNullableFilter<"Comment"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user_id?: StringFilter<"Notification"> | string
  }

  export type AssetUpsertWithWhereUniqueWithoutUploaderInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutUploaderInput, AssetUncheckedUpdateWithoutUploaderInput>
    create: XOR<AssetCreateWithoutUploaderInput, AssetUncheckedCreateWithoutUploaderInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutUploaderInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutUploaderInput, AssetUncheckedUpdateWithoutUploaderInput>
  }

  export type AssetUpdateManyWithWhereWithoutUploaderInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutUploaderInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    original_name?: StringFilter<"Asset"> | string
    file_url?: StringFilter<"Asset"> | string
    file_type?: StringFilter<"Asset"> | string
    size_bytes?: IntNullableFilter<"Asset"> | number | null
    version?: IntFilter<"Asset"> | number
    is_approved?: BoolFilter<"Asset"> | boolean
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    task_id?: StringFilter<"Asset"> | string
    uploader_id?: StringFilter<"Asset"> | string
  }

  export type AssetCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AssetCommentWhereUniqueInput
    update: XOR<AssetCommentUpdateWithoutAuthorInput, AssetCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<AssetCommentCreateWithoutAuthorInput, AssetCommentUncheckedCreateWithoutAuthorInput>
  }

  export type AssetCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AssetCommentWhereUniqueInput
    data: XOR<AssetCommentUpdateWithoutAuthorInput, AssetCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type AssetCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: AssetCommentScalarWhereInput
    data: XOR<AssetCommentUpdateManyMutationInput, AssetCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AssetCommentScalarWhereInput = {
    AND?: AssetCommentScalarWhereInput | AssetCommentScalarWhereInput[]
    OR?: AssetCommentScalarWhereInput[]
    NOT?: AssetCommentScalarWhereInput | AssetCommentScalarWhereInput[]
    id?: StringFilter<"AssetComment"> | string
    content?: StringFilter<"AssetComment"> | string
    x_coord?: FloatNullableFilter<"AssetComment"> | number | null
    y_coord?: FloatNullableFilter<"AssetComment"> | number | null
    createdAt?: DateTimeFilter<"AssetComment"> | Date | string
    asset_id?: StringFilter<"AssetComment"> | string
    author_id?: StringFilter<"AssetComment"> | string
  }

  export type UserCreateWithoutClientsManagedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutClientsManagedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutClientsManagedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
  }

  export type CampaignCreateWithoutClientInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutCampaignInput
    ad_groups?: AdGroupCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutCampaignInput
    ad_groups?: AdGroupUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutClientInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutClientInput, CampaignUncheckedCreateWithoutClientInput>
  }

  export type CampaignCreateManyClientInputEnvelope = {
    data: CampaignCreateManyClientInput | CampaignCreateManyClientInput[]
  }

  export type TaskCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutClientInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutClientInput, TaskUncheckedCreateWithoutClientInput>
  }

  export type TaskCreateManyClientInputEnvelope = {
    data: TaskCreateManyClientInput | TaskCreateManyClientInput[]
  }

  export type AdAccountCreateWithoutClientInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    ad_groups?: AdGroupCreateNestedManyWithoutAd_accountInput
  }

  export type AdAccountUncheckedCreateWithoutClientInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    ad_groups?: AdGroupUncheckedCreateNestedManyWithoutAd_accountInput
  }

  export type AdAccountCreateOrConnectWithoutClientInput = {
    where: AdAccountWhereUniqueInput
    create: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput>
  }

  export type AdAccountCreateManyClientInputEnvelope = {
    data: AdAccountCreateManyClientInput | AdAccountCreateManyClientInput[]
  }

  export type ContentCalendarCreateWithoutClientInput = {
    id?: string
    date: Date | string
    creativeType: string
    quantity?: number
    completed?: number
    inProgress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentCalendarUncheckedCreateWithoutClientInput = {
    id?: string
    date: Date | string
    creativeType: string
    quantity?: number
    completed?: number
    inProgress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentCalendarCreateOrConnectWithoutClientInput = {
    where: ContentCalendarWhereUniqueInput
    create: XOR<ContentCalendarCreateWithoutClientInput, ContentCalendarUncheckedCreateWithoutClientInput>
  }

  export type ContentCalendarCreateManyClientInputEnvelope = {
    data: ContentCalendarCreateManyClientInput | ContentCalendarCreateManyClientInput[]
  }

  export type LedgerCreateWithoutClientInput = {
    id?: string
    name: string
    type: string
    balance?: number
    updatedAt?: Date | string
    account_head: AccountHeadCreateNestedOneWithoutLedgersInput
  }

  export type LedgerUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    type: string
    account_head_id: string
    balance?: number
    updatedAt?: Date | string
  }

  export type LedgerCreateOrConnectWithoutClientInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutClientInput, LedgerUncheckedCreateWithoutClientInput>
  }

  export type LedgerCreateManyClientInputEnvelope = {
    data: LedgerCreateManyClientInput | LedgerCreateManyClientInput[]
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    journal_entry?: JournalEntryCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    journal_entry_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
  }

  export type UserUpsertWithoutClientsManagedInput = {
    update: XOR<UserUpdateWithoutClientsManagedInput, UserUncheckedUpdateWithoutClientsManagedInput>
    create: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsManagedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsManagedInput, UserUncheckedUpdateWithoutClientsManagedInput>
  }

  export type UserUpdateWithoutClientsManagedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsManagedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutClientInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutClientInput, CampaignUncheckedUpdateWithoutClientInput>
    create: XOR<CampaignCreateWithoutClientInput, CampaignUncheckedCreateWithoutClientInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutClientInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutClientInput, CampaignUncheckedUpdateWithoutClientInput>
  }

  export type CampaignUpdateManyWithWhereWithoutClientInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutClientInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    title?: StringFilter<"Campaign"> | string
    start_date?: DateTimeFilter<"Campaign"> | Date | string
    end_date?: DateTimeFilter<"Campaign"> | Date | string
    status?: StringFilter<"Campaign"> | string
    budget?: FloatNullableFilter<"Campaign"> | number | null
    goals?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    client_id?: StringFilter<"Campaign"> | string
  }

  export type TaskUpsertWithWhereUniqueWithoutClientInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutClientInput, TaskUncheckedUpdateWithoutClientInput>
    create: XOR<TaskCreateWithoutClientInput, TaskUncheckedCreateWithoutClientInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutClientInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutClientInput, TaskUncheckedUpdateWithoutClientInput>
  }

  export type TaskUpdateManyWithWhereWithoutClientInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutClientInput>
  }

  export type AdAccountUpsertWithWhereUniqueWithoutClientInput = {
    where: AdAccountWhereUniqueInput
    update: XOR<AdAccountUpdateWithoutClientInput, AdAccountUncheckedUpdateWithoutClientInput>
    create: XOR<AdAccountCreateWithoutClientInput, AdAccountUncheckedCreateWithoutClientInput>
  }

  export type AdAccountUpdateWithWhereUniqueWithoutClientInput = {
    where: AdAccountWhereUniqueInput
    data: XOR<AdAccountUpdateWithoutClientInput, AdAccountUncheckedUpdateWithoutClientInput>
  }

  export type AdAccountUpdateManyWithWhereWithoutClientInput = {
    where: AdAccountScalarWhereInput
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyWithoutClientInput>
  }

  export type AdAccountScalarWhereInput = {
    AND?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
    OR?: AdAccountScalarWhereInput[]
    NOT?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
    id?: StringFilter<"AdAccount"> | string
    platform?: StringFilter<"AdAccount"> | string
    external_id?: StringFilter<"AdAccount"> | string
    status?: StringFilter<"AdAccount"> | string
    currency?: StringFilter<"AdAccount"> | string
    client_id?: StringFilter<"AdAccount"> | string
  }

  export type ContentCalendarUpsertWithWhereUniqueWithoutClientInput = {
    where: ContentCalendarWhereUniqueInput
    update: XOR<ContentCalendarUpdateWithoutClientInput, ContentCalendarUncheckedUpdateWithoutClientInput>
    create: XOR<ContentCalendarCreateWithoutClientInput, ContentCalendarUncheckedCreateWithoutClientInput>
  }

  export type ContentCalendarUpdateWithWhereUniqueWithoutClientInput = {
    where: ContentCalendarWhereUniqueInput
    data: XOR<ContentCalendarUpdateWithoutClientInput, ContentCalendarUncheckedUpdateWithoutClientInput>
  }

  export type ContentCalendarUpdateManyWithWhereWithoutClientInput = {
    where: ContentCalendarScalarWhereInput
    data: XOR<ContentCalendarUpdateManyMutationInput, ContentCalendarUncheckedUpdateManyWithoutClientInput>
  }

  export type ContentCalendarScalarWhereInput = {
    AND?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
    OR?: ContentCalendarScalarWhereInput[]
    NOT?: ContentCalendarScalarWhereInput | ContentCalendarScalarWhereInput[]
    id?: StringFilter<"ContentCalendar"> | string
    date?: DateTimeFilter<"ContentCalendar"> | Date | string
    creativeType?: StringFilter<"ContentCalendar"> | string
    quantity?: IntFilter<"ContentCalendar"> | number
    completed?: IntFilter<"ContentCalendar"> | number
    inProgress?: IntFilter<"ContentCalendar"> | number
    createdAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"ContentCalendar"> | Date | string
    client_id?: StringFilter<"ContentCalendar"> | string
  }

  export type LedgerUpsertWithWhereUniqueWithoutClientInput = {
    where: LedgerWhereUniqueInput
    update: XOR<LedgerUpdateWithoutClientInput, LedgerUncheckedUpdateWithoutClientInput>
    create: XOR<LedgerCreateWithoutClientInput, LedgerUncheckedCreateWithoutClientInput>
  }

  export type LedgerUpdateWithWhereUniqueWithoutClientInput = {
    where: LedgerWhereUniqueInput
    data: XOR<LedgerUpdateWithoutClientInput, LedgerUncheckedUpdateWithoutClientInput>
  }

  export type LedgerUpdateManyWithWhereWithoutClientInput = {
    where: LedgerScalarWhereInput
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyWithoutClientInput>
  }

  export type LedgerScalarWhereInput = {
    AND?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
    OR?: LedgerScalarWhereInput[]
    NOT?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
    id?: StringFilter<"Ledger"> | string
    name?: StringFilter<"Ledger"> | string
    type?: StringFilter<"Ledger"> | string
    account_head_id?: StringFilter<"Ledger"> | string
    client_id?: StringNullableFilter<"Ledger"> | string | null
    balance?: FloatFilter<"Ledger"> | number
    updatedAt?: DateTimeFilter<"Ledger"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    client_id?: StringFilter<"Invoice"> | string
    subtotal?: FloatFilter<"Invoice"> | number
    tax_rate?: FloatFilter<"Invoice"> | number
    tax_amount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    journal_entry_id?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type ClientCreateWithoutContentCalendarsInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutContentCalendarsInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutContentCalendarsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutContentCalendarsInput, ClientUncheckedCreateWithoutContentCalendarsInput>
  }

  export type ClientUpsertWithoutContentCalendarsInput = {
    update: XOR<ClientUpdateWithoutContentCalendarsInput, ClientUncheckedUpdateWithoutContentCalendarsInput>
    create: XOR<ClientCreateWithoutContentCalendarsInput, ClientUncheckedCreateWithoutContentCalendarsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutContentCalendarsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutContentCalendarsInput, ClientUncheckedUpdateWithoutContentCalendarsInput>
  }

  export type ClientUpdateWithoutContentCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutContentCalendarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutCampaignsInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCampaignsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCampaignsInput, ClientUncheckedCreateWithoutCampaignsInput>
  }

  export type TaskCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCampaignInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCampaignInput, TaskUncheckedCreateWithoutCampaignInput>
  }

  export type TaskCreateManyCampaignInputEnvelope = {
    data: TaskCreateManyCampaignInput | TaskCreateManyCampaignInput[]
  }

  export type AdGroupCreateWithoutCampaignInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    ad_account?: AdAccountCreateNestedOneWithoutAd_groupsInput
    ads?: AdCreateNestedManyWithoutAd_groupInput
  }

  export type AdGroupUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    ad_account_id?: string | null
    ads?: AdUncheckedCreateNestedManyWithoutAd_groupInput
  }

  export type AdGroupCreateOrConnectWithoutCampaignInput = {
    where: AdGroupWhereUniqueInput
    create: XOR<AdGroupCreateWithoutCampaignInput, AdGroupUncheckedCreateWithoutCampaignInput>
  }

  export type AdGroupCreateManyCampaignInputEnvelope = {
    data: AdGroupCreateManyCampaignInput | AdGroupCreateManyCampaignInput[]
  }

  export type CampaignMetricCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
  }

  export type CampaignMetricUncheckedCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
  }

  export type CampaignMetricCreateOrConnectWithoutCampaignInput = {
    where: CampaignMetricWhereUniqueInput
    create: XOR<CampaignMetricCreateWithoutCampaignInput, CampaignMetricUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMetricCreateManyCampaignInputEnvelope = {
    data: CampaignMetricCreateManyCampaignInput | CampaignMetricCreateManyCampaignInput[]
  }

  export type ClientUpsertWithoutCampaignsInput = {
    update: XOR<ClientUpdateWithoutCampaignsInput, ClientUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ClientCreateWithoutCampaignsInput, ClientUncheckedCreateWithoutCampaignsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutCampaignsInput, ClientUncheckedUpdateWithoutCampaignsInput>
  }

  export type ClientUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCampaignInput, TaskUncheckedUpdateWithoutCampaignInput>
    create: XOR<TaskCreateWithoutCampaignInput, TaskUncheckedCreateWithoutCampaignInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCampaignInput, TaskUncheckedUpdateWithoutCampaignInput>
  }

  export type TaskUpdateManyWithWhereWithoutCampaignInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCampaignInput>
  }

  export type AdGroupUpsertWithWhereUniqueWithoutCampaignInput = {
    where: AdGroupWhereUniqueInput
    update: XOR<AdGroupUpdateWithoutCampaignInput, AdGroupUncheckedUpdateWithoutCampaignInput>
    create: XOR<AdGroupCreateWithoutCampaignInput, AdGroupUncheckedCreateWithoutCampaignInput>
  }

  export type AdGroupUpdateWithWhereUniqueWithoutCampaignInput = {
    where: AdGroupWhereUniqueInput
    data: XOR<AdGroupUpdateWithoutCampaignInput, AdGroupUncheckedUpdateWithoutCampaignInput>
  }

  export type AdGroupUpdateManyWithWhereWithoutCampaignInput = {
    where: AdGroupScalarWhereInput
    data: XOR<AdGroupUpdateManyMutationInput, AdGroupUncheckedUpdateManyWithoutCampaignInput>
  }

  export type AdGroupScalarWhereInput = {
    AND?: AdGroupScalarWhereInput | AdGroupScalarWhereInput[]
    OR?: AdGroupScalarWhereInput[]
    NOT?: AdGroupScalarWhereInput | AdGroupScalarWhereInput[]
    id?: StringFilter<"AdGroup"> | string
    name?: StringFilter<"AdGroup"> | string
    external_id?: StringNullableFilter<"AdGroup"> | string | null
    status?: StringFilter<"AdGroup"> | string
    campaign_id?: StringFilter<"AdGroup"> | string
    ad_account_id?: StringNullableFilter<"AdGroup"> | string | null
  }

  export type CampaignMetricUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMetricWhereUniqueInput
    update: XOR<CampaignMetricUpdateWithoutCampaignInput, CampaignMetricUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMetricCreateWithoutCampaignInput, CampaignMetricUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMetricUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMetricWhereUniqueInput
    data: XOR<CampaignMetricUpdateWithoutCampaignInput, CampaignMetricUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMetricUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignMetricScalarWhereInput
    data: XOR<CampaignMetricUpdateManyMutationInput, CampaignMetricUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignMetricScalarWhereInput = {
    AND?: CampaignMetricScalarWhereInput | CampaignMetricScalarWhereInput[]
    OR?: CampaignMetricScalarWhereInput[]
    NOT?: CampaignMetricScalarWhereInput | CampaignMetricScalarWhereInput[]
    id?: StringFilter<"CampaignMetric"> | string
    date?: DateTimeFilter<"CampaignMetric"> | Date | string
    campaign_id?: StringFilter<"CampaignMetric"> | string
    spend?: FloatFilter<"CampaignMetric"> | number
    impressions?: IntFilter<"CampaignMetric"> | number
    clicks?: IntFilter<"CampaignMetric"> | number
    conversions?: IntFilter<"CampaignMetric"> | number
    revenue?: FloatFilter<"CampaignMetric"> | number
  }

  export type ClientCreateWithoutAd_accountsInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAd_accountsInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAd_accountsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAd_accountsInput, ClientUncheckedCreateWithoutAd_accountsInput>
  }

  export type AdGroupCreateWithoutAd_accountInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign: CampaignCreateNestedOneWithoutAd_groupsInput
    ads?: AdCreateNestedManyWithoutAd_groupInput
  }

  export type AdGroupUncheckedCreateWithoutAd_accountInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign_id: string
    ads?: AdUncheckedCreateNestedManyWithoutAd_groupInput
  }

  export type AdGroupCreateOrConnectWithoutAd_accountInput = {
    where: AdGroupWhereUniqueInput
    create: XOR<AdGroupCreateWithoutAd_accountInput, AdGroupUncheckedCreateWithoutAd_accountInput>
  }

  export type AdGroupCreateManyAd_accountInputEnvelope = {
    data: AdGroupCreateManyAd_accountInput | AdGroupCreateManyAd_accountInput[]
  }

  export type ClientUpsertWithoutAd_accountsInput = {
    update: XOR<ClientUpdateWithoutAd_accountsInput, ClientUncheckedUpdateWithoutAd_accountsInput>
    create: XOR<ClientCreateWithoutAd_accountsInput, ClientUncheckedCreateWithoutAd_accountsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAd_accountsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAd_accountsInput, ClientUncheckedUpdateWithoutAd_accountsInput>
  }

  export type ClientUpdateWithoutAd_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAd_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AdGroupUpsertWithWhereUniqueWithoutAd_accountInput = {
    where: AdGroupWhereUniqueInput
    update: XOR<AdGroupUpdateWithoutAd_accountInput, AdGroupUncheckedUpdateWithoutAd_accountInput>
    create: XOR<AdGroupCreateWithoutAd_accountInput, AdGroupUncheckedCreateWithoutAd_accountInput>
  }

  export type AdGroupUpdateWithWhereUniqueWithoutAd_accountInput = {
    where: AdGroupWhereUniqueInput
    data: XOR<AdGroupUpdateWithoutAd_accountInput, AdGroupUncheckedUpdateWithoutAd_accountInput>
  }

  export type AdGroupUpdateManyWithWhereWithoutAd_accountInput = {
    where: AdGroupScalarWhereInput
    data: XOR<AdGroupUpdateManyMutationInput, AdGroupUncheckedUpdateManyWithoutAd_accountInput>
  }

  export type CampaignCreateWithoutAd_groupsInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutCampaignsInput
    tasks?: TaskCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAd_groupsInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
    tasks?: TaskUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAd_groupsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAd_groupsInput, CampaignUncheckedCreateWithoutAd_groupsInput>
  }

  export type AdAccountCreateWithoutAd_groupsInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    client: ClientCreateNestedOneWithoutAd_accountsInput
  }

  export type AdAccountUncheckedCreateWithoutAd_groupsInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
    client_id: string
  }

  export type AdAccountCreateOrConnectWithoutAd_groupsInput = {
    where: AdAccountWhereUniqueInput
    create: XOR<AdAccountCreateWithoutAd_groupsInput, AdAccountUncheckedCreateWithoutAd_groupsInput>
  }

  export type AdCreateWithoutAd_groupInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    creative?: AssetCreateNestedOneWithoutAdsInput
    snapshots?: SpendSnapshotCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutAd_groupInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    creative_id?: string | null
    snapshots?: SpendSnapshotUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutAd_groupInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutAd_groupInput, AdUncheckedCreateWithoutAd_groupInput>
  }

  export type AdCreateManyAd_groupInputEnvelope = {
    data: AdCreateManyAd_groupInput | AdCreateManyAd_groupInput[]
  }

  export type CampaignUpsertWithoutAd_groupsInput = {
    update: XOR<CampaignUpdateWithoutAd_groupsInput, CampaignUncheckedUpdateWithoutAd_groupsInput>
    create: XOR<CampaignCreateWithoutAd_groupsInput, CampaignUncheckedCreateWithoutAd_groupsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAd_groupsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAd_groupsInput, CampaignUncheckedUpdateWithoutAd_groupsInput>
  }

  export type CampaignUpdateWithoutAd_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutCampaignsNestedInput
    tasks?: TaskUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAd_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type AdAccountUpsertWithoutAd_groupsInput = {
    update: XOR<AdAccountUpdateWithoutAd_groupsInput, AdAccountUncheckedUpdateWithoutAd_groupsInput>
    create: XOR<AdAccountCreateWithoutAd_groupsInput, AdAccountUncheckedCreateWithoutAd_groupsInput>
    where?: AdAccountWhereInput
  }

  export type AdAccountUpdateToOneWithWhereWithoutAd_groupsInput = {
    where?: AdAccountWhereInput
    data: XOR<AdAccountUpdateWithoutAd_groupsInput, AdAccountUncheckedUpdateWithoutAd_groupsInput>
  }

  export type AdAccountUpdateWithoutAd_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneRequiredWithoutAd_accountsNestedInput
  }

  export type AdAccountUncheckedUpdateWithoutAd_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdUpsertWithWhereUniqueWithoutAd_groupInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutAd_groupInput, AdUncheckedUpdateWithoutAd_groupInput>
    create: XOR<AdCreateWithoutAd_groupInput, AdUncheckedCreateWithoutAd_groupInput>
  }

  export type AdUpdateWithWhereUniqueWithoutAd_groupInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutAd_groupInput, AdUncheckedUpdateWithoutAd_groupInput>
  }

  export type AdUpdateManyWithWhereWithoutAd_groupInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutAd_groupInput>
  }

  export type AdScalarWhereInput = {
    AND?: AdScalarWhereInput | AdScalarWhereInput[]
    OR?: AdScalarWhereInput[]
    NOT?: AdScalarWhereInput | AdScalarWhereInput[]
    id?: StringFilter<"Ad"> | string
    name?: StringFilter<"Ad"> | string
    external_id?: StringNullableFilter<"Ad"> | string | null
    status?: StringFilter<"Ad"> | string
    type?: StringNullableFilter<"Ad"> | string | null
    ad_group_id?: StringFilter<"Ad"> | string
    creative_id?: StringNullableFilter<"Ad"> | string | null
  }

  export type AdGroupCreateWithoutAdsInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign: CampaignCreateNestedOneWithoutAd_groupsInput
    ad_account?: AdAccountCreateNestedOneWithoutAd_groupsInput
  }

  export type AdGroupUncheckedCreateWithoutAdsInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign_id: string
    ad_account_id?: string | null
  }

  export type AdGroupCreateOrConnectWithoutAdsInput = {
    where: AdGroupWhereUniqueInput
    create: XOR<AdGroupCreateWithoutAdsInput, AdGroupUncheckedCreateWithoutAdsInput>
  }

  export type AssetCreateWithoutAdsInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAssetsInput
    uploader: UserCreateNestedOneWithoutAssetsUploadedInput
    comments?: AssetCommentCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutAdsInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task_id: string
    uploader_id: string
    comments?: AssetCommentUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutAdsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutAdsInput, AssetUncheckedCreateWithoutAdsInput>
  }

  export type SpendSnapshotCreateWithoutAdInput = {
    id?: string
    date: Date | string
    spend: number
    impressions?: number
    clicks?: number
    conversions?: number
    revenue?: number
    platform_data?: string | null
    createdAt?: Date | string
  }

  export type SpendSnapshotUncheckedCreateWithoutAdInput = {
    id?: string
    date: Date | string
    spend: number
    impressions?: number
    clicks?: number
    conversions?: number
    revenue?: number
    platform_data?: string | null
    createdAt?: Date | string
  }

  export type SpendSnapshotCreateOrConnectWithoutAdInput = {
    where: SpendSnapshotWhereUniqueInput
    create: XOR<SpendSnapshotCreateWithoutAdInput, SpendSnapshotUncheckedCreateWithoutAdInput>
  }

  export type SpendSnapshotCreateManyAdInputEnvelope = {
    data: SpendSnapshotCreateManyAdInput | SpendSnapshotCreateManyAdInput[]
  }

  export type AdGroupUpsertWithoutAdsInput = {
    update: XOR<AdGroupUpdateWithoutAdsInput, AdGroupUncheckedUpdateWithoutAdsInput>
    create: XOR<AdGroupCreateWithoutAdsInput, AdGroupUncheckedCreateWithoutAdsInput>
    where?: AdGroupWhereInput
  }

  export type AdGroupUpdateToOneWithWhereWithoutAdsInput = {
    where?: AdGroupWhereInput
    data: XOR<AdGroupUpdateWithoutAdsInput, AdGroupUncheckedUpdateWithoutAdsInput>
  }

  export type AdGroupUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutAd_groupsNestedInput
    ad_account?: AdAccountUpdateOneWithoutAd_groupsNestedInput
  }

  export type AdGroupUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    ad_account_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetUpsertWithoutAdsInput = {
    update: XOR<AssetUpdateWithoutAdsInput, AssetUncheckedUpdateWithoutAdsInput>
    create: XOR<AssetCreateWithoutAdsInput, AssetUncheckedCreateWithoutAdsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutAdsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutAdsInput, AssetUncheckedUpdateWithoutAdsInput>
  }

  export type AssetUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssetsNestedInput
    uploader?: UserUpdateOneRequiredWithoutAssetsUploadedNestedInput
    comments?: AssetCommentUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    uploader_id?: StringFieldUpdateOperationsInput | string
    comments?: AssetCommentUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type SpendSnapshotUpsertWithWhereUniqueWithoutAdInput = {
    where: SpendSnapshotWhereUniqueInput
    update: XOR<SpendSnapshotUpdateWithoutAdInput, SpendSnapshotUncheckedUpdateWithoutAdInput>
    create: XOR<SpendSnapshotCreateWithoutAdInput, SpendSnapshotUncheckedCreateWithoutAdInput>
  }

  export type SpendSnapshotUpdateWithWhereUniqueWithoutAdInput = {
    where: SpendSnapshotWhereUniqueInput
    data: XOR<SpendSnapshotUpdateWithoutAdInput, SpendSnapshotUncheckedUpdateWithoutAdInput>
  }

  export type SpendSnapshotUpdateManyWithWhereWithoutAdInput = {
    where: SpendSnapshotScalarWhereInput
    data: XOR<SpendSnapshotUpdateManyMutationInput, SpendSnapshotUncheckedUpdateManyWithoutAdInput>
  }

  export type SpendSnapshotScalarWhereInput = {
    AND?: SpendSnapshotScalarWhereInput | SpendSnapshotScalarWhereInput[]
    OR?: SpendSnapshotScalarWhereInput[]
    NOT?: SpendSnapshotScalarWhereInput | SpendSnapshotScalarWhereInput[]
    id?: StringFilter<"SpendSnapshot"> | string
    date?: DateTimeFilter<"SpendSnapshot"> | Date | string
    ad_id?: StringFilter<"SpendSnapshot"> | string
    spend?: FloatFilter<"SpendSnapshot"> | number
    impressions?: IntFilter<"SpendSnapshot"> | number
    clicks?: IntFilter<"SpendSnapshot"> | number
    conversions?: IntFilter<"SpendSnapshot"> | number
    revenue?: FloatFilter<"SpendSnapshot"> | number
    platform_data?: StringNullableFilter<"SpendSnapshot"> | string | null
    createdAt?: DateTimeFilter<"SpendSnapshot"> | Date | string
  }

  export type AdCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group: AdGroupCreateNestedOneWithoutAdsInput
    creative?: AssetCreateNestedOneWithoutAdsInput
  }

  export type AdUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group_id: string
    creative_id?: string | null
  }

  export type AdCreateOrConnectWithoutSnapshotsInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutSnapshotsInput, AdUncheckedCreateWithoutSnapshotsInput>
  }

  export type AdUpsertWithoutSnapshotsInput = {
    update: XOR<AdUpdateWithoutSnapshotsInput, AdUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<AdCreateWithoutSnapshotsInput, AdUncheckedCreateWithoutSnapshotsInput>
    where?: AdWhereInput
  }

  export type AdUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: AdWhereInput
    data: XOR<AdUpdateWithoutSnapshotsInput, AdUncheckedUpdateWithoutSnapshotsInput>
  }

  export type AdUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group?: AdGroupUpdateOneRequiredWithoutAdsNestedInput
    creative?: AssetUpdateOneWithoutAdsNestedInput
  }

  export type AdUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group_id?: StringFieldUpdateOperationsInput | string
    creative_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateWithoutMetricsInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutCampaignsInput
    tasks?: TaskCreateNestedManyWithoutCampaignInput
    ad_groups?: AdGroupCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMetricsInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
    tasks?: TaskUncheckedCreateNestedManyWithoutCampaignInput
    ad_groups?: AdGroupUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMetricsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
  }

  export type CampaignUpsertWithoutMetricsInput = {
    update: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMetricsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type CampaignUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutCampaignsNestedInput
    tasks?: TaskUpdateManyWithoutCampaignNestedInput
    ad_groups?: AdGroupUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutCampaignNestedInput
    ad_groups?: AdGroupUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LedgerCreateWithoutAccount_headInput = {
    id?: string
    name: string
    type: string
    balance?: number
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutLedgersInput
  }

  export type LedgerUncheckedCreateWithoutAccount_headInput = {
    id?: string
    name: string
    type: string
    client_id?: string | null
    balance?: number
    updatedAt?: Date | string
  }

  export type LedgerCreateOrConnectWithoutAccount_headInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutAccount_headInput, LedgerUncheckedCreateWithoutAccount_headInput>
  }

  export type LedgerCreateManyAccount_headInputEnvelope = {
    data: LedgerCreateManyAccount_headInput | LedgerCreateManyAccount_headInput[]
  }

  export type JournalLineCreateWithoutAccountInput = {
    id?: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
    entry: JournalEntryCreateNestedOneWithoutLinesInput
  }

  export type JournalLineUncheckedCreateWithoutAccountInput = {
    id?: string
    entry_id: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
  }

  export type JournalLineCreateOrConnectWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineCreateManyAccountInputEnvelope = {
    data: JournalLineCreateManyAccountInput | JournalLineCreateManyAccountInput[]
  }

  export type LedgerUpsertWithWhereUniqueWithoutAccount_headInput = {
    where: LedgerWhereUniqueInput
    update: XOR<LedgerUpdateWithoutAccount_headInput, LedgerUncheckedUpdateWithoutAccount_headInput>
    create: XOR<LedgerCreateWithoutAccount_headInput, LedgerUncheckedCreateWithoutAccount_headInput>
  }

  export type LedgerUpdateWithWhereUniqueWithoutAccount_headInput = {
    where: LedgerWhereUniqueInput
    data: XOR<LedgerUpdateWithoutAccount_headInput, LedgerUncheckedUpdateWithoutAccount_headInput>
  }

  export type LedgerUpdateManyWithWhereWithoutAccount_headInput = {
    where: LedgerScalarWhereInput
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyWithoutAccount_headInput>
  }

  export type JournalLineUpsertWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutAccountInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutAccountInput>
  }

  export type JournalLineScalarWhereInput = {
    AND?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    OR?: JournalLineScalarWhereInput[]
    NOT?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    id?: StringFilter<"JournalLine"> | string
    entry_id?: StringFilter<"JournalLine"> | string
    account_id?: StringFilter<"JournalLine"> | string
    debit?: FloatFilter<"JournalLine"> | number
    credit?: FloatFilter<"JournalLine"> | number
    description?: StringNullableFilter<"JournalLine"> | string | null
    invoice_id?: StringNullableFilter<"JournalLine"> | string | null
  }

  export type AccountHeadCreateWithoutLedgersInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
  }

  export type AccountHeadUncheckedCreateWithoutLedgersInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountHeadCreateOrConnectWithoutLedgersInput = {
    where: AccountHeadWhereUniqueInput
    create: XOR<AccountHeadCreateWithoutLedgersInput, AccountHeadUncheckedCreateWithoutLedgersInput>
  }

  export type ClientCreateWithoutLedgersInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutLedgersInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutLedgersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutLedgersInput, ClientUncheckedCreateWithoutLedgersInput>
  }

  export type AccountHeadUpsertWithoutLedgersInput = {
    update: XOR<AccountHeadUpdateWithoutLedgersInput, AccountHeadUncheckedUpdateWithoutLedgersInput>
    create: XOR<AccountHeadCreateWithoutLedgersInput, AccountHeadUncheckedCreateWithoutLedgersInput>
    where?: AccountHeadWhereInput
  }

  export type AccountHeadUpdateToOneWithWhereWithoutLedgersInput = {
    where?: AccountHeadWhereInput
    data: XOR<AccountHeadUpdateWithoutLedgersInput, AccountHeadUncheckedUpdateWithoutLedgersInput>
  }

  export type AccountHeadUpdateWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
  }

  export type AccountHeadUncheckedUpdateWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ClientUpsertWithoutLedgersInput = {
    update: XOR<ClientUpdateWithoutLedgersInput, ClientUncheckedUpdateWithoutLedgersInput>
    create: XOR<ClientCreateWithoutLedgersInput, ClientUncheckedCreateWithoutLedgersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutLedgersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutLedgersInput, ClientUncheckedUpdateWithoutLedgersInput>
  }

  export type ClientUpdateWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutLedgersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type JournalLineCreateWithoutEntryInput = {
    id?: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
    account: AccountHeadCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutEntryInput = {
    id?: string
    account_id: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
  }

  export type JournalLineCreateOrConnectWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput>
  }

  export type JournalLineCreateManyEntryInputEnvelope = {
    data: JournalLineCreateManyEntryInput | JournalLineCreateManyEntryInput[]
  }

  export type InvoiceCreateWithoutJournal_entryInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutJournal_entryInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    client_id: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutJournal_entryInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutJournal_entryInput, InvoiceUncheckedCreateWithoutJournal_entryInput>
  }

  export type JournalLineUpsertWithWhereUniqueWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutEntryInput, JournalLineUncheckedUpdateWithoutEntryInput>
    create: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutEntryInput, JournalLineUncheckedUpdateWithoutEntryInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutEntryInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutEntryInput>
  }

  export type InvoiceUpsertWithoutJournal_entryInput = {
    update: XOR<InvoiceUpdateWithoutJournal_entryInput, InvoiceUncheckedUpdateWithoutJournal_entryInput>
    create: XOR<InvoiceCreateWithoutJournal_entryInput, InvoiceUncheckedCreateWithoutJournal_entryInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutJournal_entryInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutJournal_entryInput, InvoiceUncheckedUpdateWithoutJournal_entryInput>
  }

  export type InvoiceUpdateWithoutJournal_entryInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutJournal_entryInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type JournalEntryCreateWithoutLinesInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
    invoice?: InvoiceCreateNestedOneWithoutJournal_entryInput
  }

  export type JournalEntryUncheckedCreateWithoutLinesInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutJournal_entryInput
  }

  export type JournalEntryCreateOrConnectWithoutLinesInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
  }

  export type AccountHeadCreateWithoutJournalLinesInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
    ledgers?: LedgerCreateNestedManyWithoutAccount_headInput
  }

  export type AccountHeadUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    code: string
    name: string
    type: string
    is_system?: boolean
    ledgers?: LedgerUncheckedCreateNestedManyWithoutAccount_headInput
  }

  export type AccountHeadCreateOrConnectWithoutJournalLinesInput = {
    where: AccountHeadWhereUniqueInput
    create: XOR<AccountHeadCreateWithoutJournalLinesInput, AccountHeadUncheckedCreateWithoutJournalLinesInput>
  }

  export type JournalEntryUpsertWithoutLinesInput = {
    update: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    where?: JournalEntryWhereInput
  }

  export type JournalEntryUpdateToOneWithWhereWithoutLinesInput = {
    where?: JournalEntryWhereInput
    data: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type JournalEntryUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    invoice?: InvoiceUpdateOneWithoutJournal_entryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    invoice?: InvoiceUncheckedUpdateOneWithoutJournal_entryNestedInput
  }

  export type AccountHeadUpsertWithoutJournalLinesInput = {
    update: XOR<AccountHeadUpdateWithoutJournalLinesInput, AccountHeadUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<AccountHeadCreateWithoutJournalLinesInput, AccountHeadUncheckedCreateWithoutJournalLinesInput>
    where?: AccountHeadWhereInput
  }

  export type AccountHeadUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: AccountHeadWhereInput
    data: XOR<AccountHeadUpdateWithoutJournalLinesInput, AccountHeadUncheckedUpdateWithoutJournalLinesInput>
  }

  export type AccountHeadUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
    ledgers?: LedgerUpdateManyWithoutAccount_headNestedInput
  }

  export type AccountHeadUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_system?: BoolFieldUpdateOperationsInput | boolean
    ledgers?: LedgerUncheckedUpdateManyWithoutAccount_headNestedInput
  }

  export type ClientCreateWithoutInvoicesInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    tasks?: TaskCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    tasks?: TaskUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutInvoicesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unit_price: number
    amount: number
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unit_price: number
    amount: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
  }

  export type JournalEntryCreateWithoutInvoiceInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
    lines?: JournalLineCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutInvoiceInput = {
    id?: string
    date: Date | string
    description: string
    reference?: string | null
    type: string
    createdAt?: Date | string
    created_by: string
    lines?: JournalLineUncheckedCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutInvoiceInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutInvoiceInput, JournalEntryUncheckedCreateWithoutInvoiceInput>
  }

  export type ClientUpsertWithoutInvoicesInput = {
    update: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unit_price?: FloatFilter<"InvoiceItem"> | number
    amount?: FloatFilter<"InvoiceItem"> | number
    invoice_id?: StringFilter<"InvoiceItem"> | string
  }

  export type JournalEntryUpsertWithoutInvoiceInput = {
    update: XOR<JournalEntryUpdateWithoutInvoiceInput, JournalEntryUncheckedUpdateWithoutInvoiceInput>
    create: XOR<JournalEntryCreateWithoutInvoiceInput, JournalEntryUncheckedCreateWithoutInvoiceInput>
    where?: JournalEntryWhereInput
  }

  export type JournalEntryUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: JournalEntryWhereInput
    data: XOR<JournalEntryUpdateWithoutInvoiceInput, JournalEntryUncheckedUpdateWithoutInvoiceInput>
  }

  export type JournalEntryUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    lines?: JournalLineUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    lines?: JournalLineUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutInvoicesInput
    journal_entry?: JournalEntryCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    client_id: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    journal_entry_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    journal_entry?: JournalEntryUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    journal_entry_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateWithoutTasksInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutCampaignsInput
    ad_groups?: AdGroupCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id: string
    ad_groups?: AdGroupUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTasksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
  }

  export type ClientCreateWithoutTasksInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager?: UserCreateNestedOneWithoutClientsManagedInput
    campaigns?: CampaignCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarCreateNestedManyWithoutClientInput
    ledgers?: LedgerCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account_manager_id?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClientInput
    ad_accounts?: AdAccountUncheckedCreateNestedManyWithoutClientInput
    contentCalendars?: ContentCalendarUncheckedCreateNestedManyWithoutClientInput
    ledgers?: LedgerUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTasksInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
  }

  export type TaskCreateWithoutSub_tasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSub_tasksInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSub_tasksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSub_tasksInput, TaskUncheckedCreateWithoutSub_tasksInput>
  }

  export type TaskCreateWithoutParent_taskInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutParent_taskInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutParent_taskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutParent_taskInput, TaskUncheckedCreateWithoutParent_taskInput>
  }

  export type TaskCreateManyParent_taskInputEnvelope = {
    data: TaskCreateManyParent_taskInput | TaskCreateManyParent_taskInput[]
  }

  export type TaskDependencyCreateWithoutBlocking_taskInput = {
    id?: string
    createdAt?: Date | string
    blocked_task: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskDependencyUncheckedCreateWithoutBlocking_taskInput = {
    id?: string
    blocked_task_id: string
    createdAt?: Date | string
  }

  export type TaskDependencyCreateOrConnectWithoutBlocking_taskInput = {
    where: TaskDependencyWhereUniqueInput
    create: XOR<TaskDependencyCreateWithoutBlocking_taskInput, TaskDependencyUncheckedCreateWithoutBlocking_taskInput>
  }

  export type TaskDependencyCreateManyBlocking_taskInputEnvelope = {
    data: TaskDependencyCreateManyBlocking_taskInput | TaskDependencyCreateManyBlocking_taskInput[]
  }

  export type TaskDependencyCreateWithoutBlocked_taskInput = {
    id?: string
    createdAt?: Date | string
    blocking_task: TaskCreateNestedOneWithoutDependenciesInput
  }

  export type TaskDependencyUncheckedCreateWithoutBlocked_taskInput = {
    id?: string
    blocking_task_id: string
    createdAt?: Date | string
  }

  export type TaskDependencyCreateOrConnectWithoutBlocked_taskInput = {
    where: TaskDependencyWhereUniqueInput
    create: XOR<TaskDependencyCreateWithoutBlocked_taskInput, TaskDependencyUncheckedCreateWithoutBlocked_taskInput>
  }

  export type TaskDependencyCreateManyBlocked_taskInputEnvelope = {
    data: TaskDependencyCreateManyBlocked_taskInput | TaskDependencyCreateManyBlocked_taskInput[]
  }

  export type UserCreateWithoutTasksAssignedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTasksAssignedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
  }

  export type UserCreateWithoutTasksReportedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTasksReportedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTasksReportedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksReportedInput, UserUncheckedCreateWithoutTasksReportedInput>
  }

  export type AssetCreateWithoutTaskInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    uploader: UserCreateNestedOneWithoutAssetsUploadedInput
    comments?: AssetCommentCreateNestedManyWithoutAssetInput
    ads?: AdCreateNestedManyWithoutCreativeInput
  }

  export type AssetUncheckedCreateWithoutTaskInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    uploader_id: string
    comments?: AssetCommentUncheckedCreateNestedManyWithoutAssetInput
    ads?: AdUncheckedCreateNestedManyWithoutCreativeInput
  }

  export type AssetCreateOrConnectWithoutTaskInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutTaskInput, AssetUncheckedCreateWithoutTaskInput>
  }

  export type AssetCreateManyTaskInputEnvelope = {
    data: AssetCreateManyTaskInput | AssetCreateManyTaskInput[]
  }

  export type CommentCreateWithoutTaskInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    parent_comment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParent_commentInput
  }

  export type CommentUncheckedCreateWithoutTaskInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    author_id: string
    parent_comment_id?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParent_commentInput
  }

  export type CommentCreateOrConnectWithoutTaskInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentCreateManyTaskInputEnvelope = {
    data: CommentCreateManyTaskInput | CommentCreateManyTaskInput[]
  }

  export type TimeLogCreateWithoutTaskInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutTaskInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    user_id: string
  }

  export type TimeLogCreateOrConnectWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TimeLogCreateManyTaskInputEnvelope = {
    data: TimeLogCreateManyTaskInput | TimeLogCreateManyTaskInput[]
  }

  export type CampaignUpsertWithoutTasksInput = {
    update: XOR<CampaignUpdateWithoutTasksInput, CampaignUncheckedUpdateWithoutTasksInput>
    create: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTasksInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTasksInput, CampaignUncheckedUpdateWithoutTasksInput>
  }

  export type CampaignUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutCampaignsNestedInput
    ad_groups?: AdGroupUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: StringFieldUpdateOperationsInput | string
    ad_groups?: AdGroupUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ClientUpsertWithoutTasksInput = {
    update: XOR<ClientUpdateWithoutTasksInput, ClientUncheckedUpdateWithoutTasksInput>
    create: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTasksInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTasksInput, ClientUncheckedUpdateWithoutTasksInput>
  }

  export type ClientUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager?: UserUpdateOneWithoutClientsManagedNestedInput
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TaskUpsertWithoutSub_tasksInput = {
    update: XOR<TaskUpdateWithoutSub_tasksInput, TaskUncheckedUpdateWithoutSub_tasksInput>
    create: XOR<TaskCreateWithoutSub_tasksInput, TaskUncheckedCreateWithoutSub_tasksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSub_tasksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSub_tasksInput, TaskUncheckedUpdateWithoutSub_tasksInput>
  }

  export type TaskUpdateWithoutSub_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSub_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutParent_taskInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutParent_taskInput, TaskUncheckedUpdateWithoutParent_taskInput>
    create: XOR<TaskCreateWithoutParent_taskInput, TaskUncheckedCreateWithoutParent_taskInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutParent_taskInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutParent_taskInput, TaskUncheckedUpdateWithoutParent_taskInput>
  }

  export type TaskUpdateManyWithWhereWithoutParent_taskInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutParent_taskInput>
  }

  export type TaskDependencyUpsertWithWhereUniqueWithoutBlocking_taskInput = {
    where: TaskDependencyWhereUniqueInput
    update: XOR<TaskDependencyUpdateWithoutBlocking_taskInput, TaskDependencyUncheckedUpdateWithoutBlocking_taskInput>
    create: XOR<TaskDependencyCreateWithoutBlocking_taskInput, TaskDependencyUncheckedCreateWithoutBlocking_taskInput>
  }

  export type TaskDependencyUpdateWithWhereUniqueWithoutBlocking_taskInput = {
    where: TaskDependencyWhereUniqueInput
    data: XOR<TaskDependencyUpdateWithoutBlocking_taskInput, TaskDependencyUncheckedUpdateWithoutBlocking_taskInput>
  }

  export type TaskDependencyUpdateManyWithWhereWithoutBlocking_taskInput = {
    where: TaskDependencyScalarWhereInput
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyWithoutBlocking_taskInput>
  }

  export type TaskDependencyScalarWhereInput = {
    AND?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
    OR?: TaskDependencyScalarWhereInput[]
    NOT?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
    id?: StringFilter<"TaskDependency"> | string
    blocking_task_id?: StringFilter<"TaskDependency"> | string
    blocked_task_id?: StringFilter<"TaskDependency"> | string
    createdAt?: DateTimeFilter<"TaskDependency"> | Date | string
  }

  export type TaskDependencyUpsertWithWhereUniqueWithoutBlocked_taskInput = {
    where: TaskDependencyWhereUniqueInput
    update: XOR<TaskDependencyUpdateWithoutBlocked_taskInput, TaskDependencyUncheckedUpdateWithoutBlocked_taskInput>
    create: XOR<TaskDependencyCreateWithoutBlocked_taskInput, TaskDependencyUncheckedCreateWithoutBlocked_taskInput>
  }

  export type TaskDependencyUpdateWithWhereUniqueWithoutBlocked_taskInput = {
    where: TaskDependencyWhereUniqueInput
    data: XOR<TaskDependencyUpdateWithoutBlocked_taskInput, TaskDependencyUncheckedUpdateWithoutBlocked_taskInput>
  }

  export type TaskDependencyUpdateManyWithWhereWithoutBlocked_taskInput = {
    where: TaskDependencyScalarWhereInput
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyWithoutBlocked_taskInput>
  }

  export type UserUpsertWithoutTasksAssignedInput = {
    update: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateWithoutTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutTasksReportedInput = {
    update: XOR<UserUpdateWithoutTasksReportedInput, UserUncheckedUpdateWithoutTasksReportedInput>
    create: XOR<UserCreateWithoutTasksReportedInput, UserUncheckedCreateWithoutTasksReportedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksReportedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksReportedInput, UserUncheckedUpdateWithoutTasksReportedInput>
  }

  export type UserUpdateWithoutTasksReportedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksReportedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AssetUpsertWithWhereUniqueWithoutTaskInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutTaskInput, AssetUncheckedUpdateWithoutTaskInput>
    create: XOR<AssetCreateWithoutTaskInput, AssetUncheckedCreateWithoutTaskInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutTaskInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutTaskInput, AssetUncheckedUpdateWithoutTaskInput>
  }

  export type AssetUpdateManyWithWhereWithoutTaskInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutTaskInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
  }

  export type CommentUpdateManyWithWhereWithoutTaskInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TimeLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutTaskInput, TimeLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutTaskInput, TimeLogUncheckedUpdateWithoutTaskInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutTaskInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCreateWithoutDependenciesInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutDependenciesInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutDependenciesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
  }

  export type TaskCreateWithoutDependentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutDependentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutDependentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
  }

  export type TaskUpsertWithoutDependenciesInput = {
    update: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type TaskUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUpsertWithoutDependentsInput = {
    update: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateWithoutAssetsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssetsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssetsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssetsInput, TaskUncheckedCreateWithoutAssetsInput>
  }

  export type UserCreateWithoutAssetsUploadedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAssetsUploadedInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAssetsUploadedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetsUploadedInput, UserUncheckedCreateWithoutAssetsUploadedInput>
  }

  export type AssetCommentCreateWithoutAssetInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutAssetCommentsInput
  }

  export type AssetCommentUncheckedCreateWithoutAssetInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    author_id: string
  }

  export type AssetCommentCreateOrConnectWithoutAssetInput = {
    where: AssetCommentWhereUniqueInput
    create: XOR<AssetCommentCreateWithoutAssetInput, AssetCommentUncheckedCreateWithoutAssetInput>
  }

  export type AssetCommentCreateManyAssetInputEnvelope = {
    data: AssetCommentCreateManyAssetInput | AssetCommentCreateManyAssetInput[]
  }

  export type AdCreateWithoutCreativeInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group: AdGroupCreateNestedOneWithoutAdsInput
    snapshots?: SpendSnapshotCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutCreativeInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group_id: string
    snapshots?: SpendSnapshotUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutCreativeInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutCreativeInput, AdUncheckedCreateWithoutCreativeInput>
  }

  export type AdCreateManyCreativeInputEnvelope = {
    data: AdCreateManyCreativeInput | AdCreateManyCreativeInput[]
  }

  export type TaskUpsertWithoutAssetsInput = {
    update: XOR<TaskUpdateWithoutAssetsInput, TaskUncheckedUpdateWithoutAssetsInput>
    create: XOR<TaskCreateWithoutAssetsInput, TaskUncheckedCreateWithoutAssetsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAssetsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAssetsInput, TaskUncheckedUpdateWithoutAssetsInput>
  }

  export type TaskUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutAssetsUploadedInput = {
    update: XOR<UserUpdateWithoutAssetsUploadedInput, UserUncheckedUpdateWithoutAssetsUploadedInput>
    create: XOR<UserCreateWithoutAssetsUploadedInput, UserUncheckedCreateWithoutAssetsUploadedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetsUploadedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetsUploadedInput, UserUncheckedUpdateWithoutAssetsUploadedInput>
  }

  export type UserUpdateWithoutAssetsUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetsUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AssetCommentUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetCommentWhereUniqueInput
    update: XOR<AssetCommentUpdateWithoutAssetInput, AssetCommentUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetCommentCreateWithoutAssetInput, AssetCommentUncheckedCreateWithoutAssetInput>
  }

  export type AssetCommentUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetCommentWhereUniqueInput
    data: XOR<AssetCommentUpdateWithoutAssetInput, AssetCommentUncheckedUpdateWithoutAssetInput>
  }

  export type AssetCommentUpdateManyWithWhereWithoutAssetInput = {
    where: AssetCommentScalarWhereInput
    data: XOR<AssetCommentUpdateManyMutationInput, AssetCommentUncheckedUpdateManyWithoutAssetInput>
  }

  export type AdUpsertWithWhereUniqueWithoutCreativeInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutCreativeInput, AdUncheckedUpdateWithoutCreativeInput>
    create: XOR<AdCreateWithoutCreativeInput, AdUncheckedCreateWithoutCreativeInput>
  }

  export type AdUpdateWithWhereUniqueWithoutCreativeInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutCreativeInput, AdUncheckedUpdateWithoutCreativeInput>
  }

  export type AdUpdateManyWithWhereWithoutCreativeInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutCreativeInput>
  }

  export type TaskCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent_comment?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    author_id: string
    parent_comment_id?: string | null
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParent_commentInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParent_commentInput
  }

  export type CommentUncheckedCreateWithoutParent_commentInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    author_id: string
    replies?: CommentUncheckedCreateNestedManyWithoutParent_commentInput
  }

  export type CommentCreateOrConnectWithoutParent_commentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParent_commentInput, CommentUncheckedCreateWithoutParent_commentInput>
  }

  export type CommentCreateManyParent_commentInputEnvelope = {
    data: CommentCreateManyParent_commentInput | CommentCreateManyParent_commentInput[]
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent_comment?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutParent_commentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParent_commentInput, CommentUncheckedUpdateWithoutParent_commentInput>
    create: XOR<CommentCreateWithoutParent_commentInput, CommentUncheckedCreateWithoutParent_commentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParent_commentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParent_commentInput, CommentUncheckedUpdateWithoutParent_commentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParent_commentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParent_commentInput>
  }

  export type AssetCreateWithoutCommentsInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutAssetsInput
    uploader: UserCreateNestedOneWithoutAssetsUploadedInput
    ads?: AdCreateNestedManyWithoutCreativeInput
  }

  export type AssetUncheckedCreateWithoutCommentsInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task_id: string
    uploader_id: string
    ads?: AdUncheckedCreateNestedManyWithoutCreativeInput
  }

  export type AssetCreateOrConnectWithoutCommentsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutAssetCommentsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
  }

  export type UserUncheckedCreateWithoutAssetCommentsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutAssetCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetCommentsInput, UserUncheckedCreateWithoutAssetCommentsInput>
  }

  export type AssetUpsertWithoutCommentsInput = {
    update: XOR<AssetUpdateWithoutCommentsInput, AssetUncheckedUpdateWithoutCommentsInput>
    create: XOR<AssetCreateWithoutCommentsInput, AssetUncheckedCreateWithoutCommentsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutCommentsInput, AssetUncheckedUpdateWithoutCommentsInput>
  }

  export type AssetUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssetsNestedInput
    uploader?: UserUpdateOneRequiredWithoutAssetsUploadedNestedInput
    ads?: AdUpdateManyWithoutCreativeNestedInput
  }

  export type AssetUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    uploader_id?: StringFieldUpdateOperationsInput | string
    ads?: AdUncheckedUpdateManyWithoutCreativeNestedInput
  }

  export type UserUpsertWithoutAssetCommentsInput = {
    update: XOR<UserUpdateWithoutAssetCommentsInput, UserUncheckedUpdateWithoutAssetCommentsInput>
    create: XOR<UserCreateWithoutAssetCommentsInput, UserUncheckedCreateWithoutAssetCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetCommentsInput, UserUncheckedUpdateWithoutAssetCommentsInput>
  }

  export type UserUpdateWithoutAssetCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type TaskCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutTasksInput
    client?: ClientCreateNestedOneWithoutTasksInput
    parent_task?: TaskCreateNestedOneWithoutSub_tasksInput
    sub_tasks?: TaskCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyCreateNestedManyWithoutBlocked_taskInput
    assignee?: UserCreateNestedOneWithoutTasksAssignedInput
    reporter: UserCreateNestedOneWithoutTasksReportedInput
    assets?: AssetCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
    sub_tasks?: TaskUncheckedCreateNestedManyWithoutParent_taskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutBlocking_taskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutBlocked_taskInput
    assets?: AssetUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTimeLogsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
  }

  export type UserCreateWithoutTimeLogsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTimeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
  }

  export type TaskUpsertWithoutTimeLogsInput = {
    update: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type TaskUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutTimeLogsInput = {
    update: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    assetsUploaded?: AssetCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password_hash: string
    full_name: string
    designation?: string | null
    role: string
    department: string
    avatar_url?: string | null
    staff_id_number?: string | null
    joining_date?: Date | string | null
    dob?: Date | string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutAccount_managerInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    tasksReported?: TaskUncheckedCreateNestedManyWithoutReporterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    assetsUploaded?: AssetUncheckedCreateNestedManyWithoutUploaderInput
    assetComments?: AssetCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    assetsUploaded?: AssetUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    staff_id_number?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutAccount_managerNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    tasksReported?: TaskUncheckedUpdateManyWithoutReporterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    assetsUploaded?: AssetUncheckedUpdateManyWithoutUploaderNestedInput
    assetComments?: AssetCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ClientCreateManyAccount_managerInput = {
    id?: string
    name: string
    brand_colors?: string | null
    logo_url?: string | null
    industry?: string | null
    contract_type?: string | null
    client_number?: string | null
    onboarding_date?: Date | string | null
    address?: string | null
    contact_person?: string | null
    contact_number?: string | null
    website?: string | null
    email?: string | null
    whatsapp?: string | null
    facebook?: string | null
    instagram?: string | null
    linkedin?: string | null
    youtube?: string | null
    competitorDetails?: string | null
    customerAvatar?: string | null
    contentSuggestions?: string | null
    referenceLinks?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    reporter_id: string
  }

  export type TaskCreateManyReporterInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
  }

  export type TimeLogCreateManyUserInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    task_id: string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    parent_comment_id?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type AssetCreateManyUploaderInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    task_id: string
  }

  export type AssetCommentCreateManyAuthorInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    asset_id: string
  }

  export type ClientUpdateWithoutAccount_managerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutClientNestedInput
    tasks?: TaskUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAccount_managerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutClientNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutClientNestedInput
    ad_accounts?: AdAccountUncheckedUpdateManyWithoutClientNestedInput
    contentCalendars?: ContentCalendarUncheckedUpdateManyWithoutClientNestedInput
    ledgers?: LedgerUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutAccount_managerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_colors?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    contract_type?: NullableStringFieldUpdateOperationsInput | string | null
    client_number?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    competitorDetails?: NullableStringFieldUpdateOperationsInput | string | null
    customerAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    contentSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLinks?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    parent_comment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAssetsNestedInput
    comments?: AssetCommentUpdateManyWithoutAssetNestedInput
    ads?: AdUpdateManyWithoutCreativeNestedInput
  }

  export type AssetUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    comments?: AssetCommentUncheckedUpdateManyWithoutAssetNestedInput
    ads?: AdUncheckedUpdateManyWithoutCreativeNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type AssetCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset_id?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateManyClientInput = {
    id?: string
    title: string
    start_date: Date | string
    end_date: Date | string
    status?: string
    budget?: number | null
    goals?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyClientInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
  }

  export type AdAccountCreateManyClientInput = {
    id?: string
    platform: string
    external_id: string
    status?: string
    currency?: string
  }

  export type ContentCalendarCreateManyClientInput = {
    id?: string
    date: Date | string
    creativeType: string
    quantity?: number
    completed?: number
    inProgress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerCreateManyClientInput = {
    id?: string
    name: string
    type: string
    account_head_id: string
    balance?: number
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    number: string
    date: Date | string
    due_date: Date | string
    status?: string
    subtotal: number
    tax_rate?: number
    tax_amount: number
    total: number
    journal_entry_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutCampaignNestedInput
    ad_groups?: AdGroupUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutCampaignNestedInput
    ad_groups?: AdGroupUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdAccountUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    ad_groups?: AdGroupUpdateManyWithoutAd_accountNestedInput
  }

  export type AdAccountUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    ad_groups?: AdGroupUncheckedUpdateManyWithoutAd_accountNestedInput
  }

  export type AdAccountUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    external_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ContentCalendarUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCalendarUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    creativeType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    completed?: IntFieldUpdateOperationsInput | number
    inProgress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account_head?: AccountHeadUpdateOneRequiredWithoutLedgersNestedInput
  }

  export type LedgerUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    account_head_id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    account_head_id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    journal_entry?: JournalEntryUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    journal_entry_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax_rate?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    journal_entry_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyCampaignInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client_id?: string | null
    parent_task_id?: string | null
    assignee_id?: string | null
    reporter_id: string
  }

  export type AdGroupCreateManyCampaignInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    ad_account_id?: string | null
  }

  export type CampaignMetricCreateManyCampaignInput = {
    id?: string
    date: Date | string
    spend: number
    impressions: number
    clicks: number
    conversions: number
    revenue: number
  }

  export type TaskUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutTasksNestedInput
    parent_task?: TaskUpdateOneWithoutSub_tasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_task_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdGroupUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ad_account?: AdAccountUpdateOneWithoutAd_groupsNestedInput
    ads?: AdUpdateManyWithoutAd_groupNestedInput
  }

  export type AdGroupUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ad_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    ads?: AdUncheckedUpdateManyWithoutAd_groupNestedInput
  }

  export type AdGroupUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ad_account_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMetricUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
  }

  export type CampaignMetricUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
  }

  export type CampaignMetricUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
  }

  export type AdGroupCreateManyAd_accountInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    campaign_id: string
  }

  export type AdGroupUpdateWithoutAd_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutAd_groupsNestedInput
    ads?: AdUpdateManyWithoutAd_groupNestedInput
  }

  export type AdGroupUncheckedUpdateWithoutAd_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
    ads?: AdUncheckedUpdateManyWithoutAd_groupNestedInput
  }

  export type AdGroupUncheckedUpdateManyWithoutAd_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    campaign_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdCreateManyAd_groupInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    creative_id?: string | null
  }

  export type AdUpdateWithoutAd_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    creative?: AssetUpdateOneWithoutAdsNestedInput
    snapshots?: SpendSnapshotUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutAd_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    creative_id?: NullableStringFieldUpdateOperationsInput | string | null
    snapshots?: SpendSnapshotUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateManyWithoutAd_groupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    creative_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendSnapshotCreateManyAdInput = {
    id?: string
    date: Date | string
    spend: number
    impressions?: number
    clicks?: number
    conversions?: number
    revenue?: number
    platform_data?: string | null
    createdAt?: Date | string
  }

  export type SpendSnapshotUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendSnapshotUncheckedUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendSnapshotUncheckedUpdateManyWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    spend?: FloatFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    platform_data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerCreateManyAccount_headInput = {
    id?: string
    name: string
    type: string
    client_id?: string | null
    balance?: number
    updatedAt?: Date | string
  }

  export type JournalLineCreateManyAccountInput = {
    id?: string
    entry_id: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
  }

  export type LedgerUpdateWithoutAccount_headInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutLedgersNestedInput
  }

  export type LedgerUncheckedUpdateWithoutAccount_headInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUncheckedUpdateManyWithoutAccount_headInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineCreateManyEntryInput = {
    id?: string
    account_id: string
    debit?: number
    credit?: number
    description?: string | null
    invoice_id?: string | null
  }

  export type JournalLineUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountHeadUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity: number
    unit_price: number
    amount: number
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TaskCreateManyParent_taskInput = {
    id?: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    type?: string
    category?: string
    platform?: string | null
    due_date?: Date | string | null
    start_date?: Date | string | null
    actual_start_date?: Date | string | null
    completed_date?: Date | string | null
    estimated_hours?: number | null
    time_estimate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign_id?: string | null
    client_id?: string | null
    assignee_id?: string | null
    reporter_id: string
  }

  export type TaskDependencyCreateManyBlocking_taskInput = {
    id?: string
    blocked_task_id: string
    createdAt?: Date | string
  }

  export type TaskDependencyCreateManyBlocked_taskInput = {
    id?: string
    blocking_task_id: string
    createdAt?: Date | string
  }

  export type AssetCreateManyTaskInput = {
    id?: string
    original_name: string
    file_url: string
    file_type: string
    size_bytes?: number | null
    version?: number
    is_approved?: boolean
    createdAt?: Date | string
    uploader_id: string
  }

  export type CommentCreateManyTaskInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    author_id: string
    parent_comment_id?: string | null
  }

  export type TimeLogCreateManyTaskInput = {
    id?: string
    start_time: Date | string
    end_time?: Date | string | null
    duration_minutes?: number | null
    createdAt?: Date | string
    user_id: string
  }

  export type TaskUpdateWithoutParent_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutTasksNestedInput
    client?: ClientUpdateOneWithoutTasksNestedInput
    sub_tasks?: TaskUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutBlocked_taskNestedInput
    assignee?: UserUpdateOneWithoutTasksAssignedNestedInput
    reporter?: UserUpdateOneRequiredWithoutTasksReportedNestedInput
    assets?: AssetUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutParent_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
    sub_tasks?: TaskUncheckedUpdateManyWithoutParent_taskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutBlocking_taskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutBlocked_taskNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutParent_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimated_hours?: NullableFloatFieldUpdateOperationsInput | number | null
    time_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: NullableStringFieldUpdateOperationsInput | string | null
    assignee_id?: NullableStringFieldUpdateOperationsInput | string | null
    reporter_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskDependencyUpdateWithoutBlocking_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked_task?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskDependencyUncheckedUpdateWithoutBlocking_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    blocked_task_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUncheckedUpdateManyWithoutBlocking_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    blocked_task_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUpdateWithoutBlocked_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocking_task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type TaskDependencyUncheckedUpdateWithoutBlocked_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    blocking_task_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUncheckedUpdateManyWithoutBlocked_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    blocking_task_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutAssetsUploadedNestedInput
    comments?: AssetCommentUpdateManyWithoutAssetNestedInput
    ads?: AdUpdateManyWithoutCreativeNestedInput
  }

  export type AssetUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader_id?: StringFieldUpdateOperationsInput | string
    comments?: AssetCommentUncheckedUpdateManyWithoutAssetNestedInput
    ads?: AdUncheckedUpdateManyWithoutCreativeNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    size_bytes?: NullableIntFieldUpdateOperationsInput | number | null
    version?: IntFieldUpdateOperationsInput | number
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader_id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent_comment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: StringFieldUpdateOperationsInput | string
    parent_comment_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCommentCreateManyAssetInput = {
    id?: string
    content: string
    x_coord?: number | null
    y_coord?: number | null
    createdAt?: Date | string
    author_id: string
  }

  export type AdCreateManyCreativeInput = {
    id?: string
    name: string
    external_id?: string | null
    status?: string
    type?: string | null
    ad_group_id: string
  }

  export type AssetCommentUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAssetCommentsNestedInput
  }

  export type AssetCommentUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCommentUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    x_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    y_coord?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdUpdateWithoutCreativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group?: AdGroupUpdateOneRequiredWithoutAdsNestedInput
    snapshots?: SpendSnapshotUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutCreativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group_id?: StringFieldUpdateOperationsInput | string
    snapshots?: SpendSnapshotUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateManyWithoutCreativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_group_id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyParent_commentInput = {
    id?: string
    content: string
    is_revision_request?: boolean
    createdAt?: Date | string
    task_id: string
    author_id: string
  }

  export type CommentUpdateWithoutParent_commentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParent_commentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    replies?: CommentUncheckedUpdateManyWithoutParent_commentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParent_commentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_revision_request?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdAccountCountOutputTypeDefaultArgs instead
     */
    export type AdAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdGroupCountOutputTypeDefaultArgs instead
     */
    export type AdGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdCountOutputTypeDefaultArgs instead
     */
    export type AdCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountHeadCountOutputTypeDefaultArgs instead
     */
    export type AccountHeadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountHeadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalEntryCountOutputTypeDefaultArgs instead
     */
    export type JournalEntryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCountOutputTypeDefaultArgs instead
     */
    export type AssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentCalendarDefaultArgs instead
     */
    export type ContentCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentCalendarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdAccountDefaultArgs instead
     */
    export type AdAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdGroupDefaultArgs instead
     */
    export type AdGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdDefaultArgs instead
     */
    export type AdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpendSnapshotDefaultArgs instead
     */
    export type SpendSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpendSnapshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignMetricDefaultArgs instead
     */
    export type CampaignMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountHeadDefaultArgs instead
     */
    export type AccountHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountHeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerDefaultArgs instead
     */
    export type LedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalEntryDefaultArgs instead
     */
    export type JournalEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalLineDefaultArgs instead
     */
    export type JournalLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDependencyDefaultArgs instead
     */
    export type TaskDependencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDependencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCommentDefaultArgs instead
     */
    export type AssetCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeLogDefaultArgs instead
     */
    export type TimeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}